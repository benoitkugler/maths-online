// Code generated by structgen. DO NOT EDIT

typedef JSON = Map<String, dynamic>; // alias to shorten JSON convertors

String stringFromJson(dynamic json) => json == null ? "" : json as String;

String stringToJson(String item) => item;

List<String> listStringFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(stringFromJson).toList();
}

List<dynamic> listStringToJson(List<String> item) {
  return item.map(stringToJson).toList();
}

// github.com/benoitkugler/maths-online/maths/proof.Equality
class Equality implements Assertion {
  final List<String> terms;

  const Equality(this.terms);

  @override
  String toString() {
    return "Equality($terms)";
  }
}

Equality equalityFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return Equality(listStringFromJson(json['Terms']));
}

JSON equalityToJson(Equality item) {
  return {"Terms": listStringToJson(item.terms)};
}

// github.com/benoitkugler/maths-online/maths/proof.Statement
class Statement implements Assertion {
  final String content;

  const Statement(this.content);

  @override
  String toString() {
    return "Statement($content)";
  }
}

Statement statementFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return Statement(stringFromJson(json['Content']));
}

JSON statementToJson(Statement item) {
  return {"Content": stringToJson(item.content)};
}

abstract class Assertion {}

Assertion assertionFromJson(dynamic json_) {
  final json = json_ as JSON;
  final kind = json['Kind'] as String;
  final data = json['Data'];
  switch (kind) {
    case "Equality":
      return equalityFromJson(data);
    case "Node":
      return nodeFromJson(data);
    case "Sequence":
      return sequenceFromJson(data);
    case "Statement":
      return statementFromJson(data);
    default:
      throw ("unexpected type");
  }
}

JSON assertionToJson(Assertion item) {
  if (item is Equality) {
    return {'Kind': "Equality", 'Data': equalityToJson(item)};
  } else if (item is Node) {
    return {'Kind': "Node", 'Data': nodeToJson(item)};
  } else if (item is Sequence) {
    return {'Kind': "Sequence", 'Data': sequenceToJson(item)};
  } else if (item is Statement) {
    return {'Kind': "Statement", 'Data': statementToJson(item)};
  } else {
    throw ("unexpected type");
  }
}

List<Assertion> listAssertionFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(assertionFromJson).toList();
}

List<dynamic> listAssertionToJson(List<Assertion> item) {
  return item.map(assertionToJson).toList();
}

// github.com/benoitkugler/maths-online/maths/proof.Assertions
typedef Assertions = List<Assertion>;

// github.com/benoitkugler/maths-online/maths/proof.Sequence
class Sequence implements Assertion {
  final Assertions parts;

  const Sequence(this.parts);

  @override
  String toString() {
    return "Sequence($parts)";
  }
}

Sequence sequenceFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return Sequence(listAssertionFromJson(json['Parts']));
}

JSON sequenceToJson(Sequence item) {
  return {"Parts": listAssertionToJson(item.parts)};
}

// github.com/benoitkugler/maths-online/maths/proof.Binary
enum Binary { invalid, and, or }

extension _BinaryExt on Binary {
  static Binary fromValue(int i) {
    return Binary.values[i];
  }

  int toValue() {
    return index;
  }
}

Binary binaryFromJson(dynamic json) => _BinaryExt.fromValue(json as int);

dynamic binaryToJson(Binary item) => item.toValue();

// github.com/benoitkugler/maths-online/maths/proof.Node
class Node implements Assertion {
  final Assertion left;
  final Assertion right;
  final Binary op;

  const Node(this.left, this.right, this.op);

  @override
  String toString() {
    return "Node($left, $right, $op)";
  }
}

Node nodeFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return Node(assertionFromJson(json['Left']), assertionFromJson(json['Right']),
      binaryFromJson(json['Op']));
}

JSON nodeToJson(Node item) {
  return {
    "Left": assertionToJson(item.left),
    "Right": assertionToJson(item.right),
    "Op": binaryToJson(item.op)
  };
}

// github.com/benoitkugler/maths-online/maths/proof.Proof
class Proof {
  final Sequence root;

  const Proof(this.root);

  @override
  String toString() {
    return "Proof($root)";
  }
}

Proof proofFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return Proof(sequenceFromJson(json['Root']));
}

JSON proofToJson(Proof item) {
  return {"Root": sequenceToJson(item.root)};
}
