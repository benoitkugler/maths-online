// Code generated by gomacro/generator/dart. DO NOT EDIT

import 'predefined.dart';
import 'src_maths_expression.dart';
import 'src_maths_functiongrapher.dart';
import 'src_maths_questions_client.dart';
import 'src_maths_repere.dart';

/// github.com/benoitkugler/maths-online/server/src/maths/questions.Block
abstract class Block {}

Block blockFromJson(dynamic json_) {
  final json = json_ as Map<String, dynamic>;
  final kind = json['Kind'] as String;
  final data = json['Data'];
  switch (kind) {
    case "ExpressionFieldBlock":
      return expressionFieldBlockFromJson(data);
    case "FigureAffineLineFieldBlock":
      return figureAffineLineFieldBlockFromJson(data);
    case "FigureBlock":
      return figureBlockFromJson(data);
    case "FigurePointFieldBlock":
      return figurePointFieldBlockFromJson(data);
    case "FigureVectorFieldBlock":
      return figureVectorFieldBlockFromJson(data);
    case "FigureVectorPairFieldBlock":
      return figureVectorPairFieldBlockFromJson(data);
    case "FormulaBlock":
      return formulaBlockFromJson(data);
    case "FunctionPointsFieldBlock":
      return functionPointsFieldBlockFromJson(data);
    case "FunctionsGraphBlock":
      return functionsGraphBlockFromJson(data);
    case "NumberFieldBlock":
      return numberFieldBlockFromJson(data);
    case "OrderedListFieldBlock":
      return orderedListFieldBlockFromJson(data);
    case "ProofFieldBlock":
      return proofFieldBlockFromJson(data);
    case "RadioFieldBlock":
      return radioFieldBlockFromJson(data);
    case "SignTableBlock":
      return signTableBlockFromJson(data);
    case "SignTableFieldBlock":
      return signTableFieldBlockFromJson(data);
    case "TableBlock":
      return tableBlockFromJson(data);
    case "TableFieldBlock":
      return tableFieldBlockFromJson(data);
    case "TextBlock":
      return textBlockFromJson(data);
    case "TreeFieldBlock":
      return treeFieldBlockFromJson(data);
    case "VariationTableBlock":
      return variationTableBlockFromJson(data);
    case "VariationTableFieldBlock":
      return variationTableFieldBlockFromJson(data);
    case "VectorFieldBlock":
      return vectorFieldBlockFromJson(data);
    default:
      throw ("unexpected type");
  }
}

Map<String, dynamic> blockToJson(Block item) {
  if (item is ExpressionFieldBlock) {
    return {
      'Kind': "ExpressionFieldBlock",
      'Data': expressionFieldBlockToJson(item)
    };
  } else if (item is FigureAffineLineFieldBlock) {
    return {
      'Kind': "FigureAffineLineFieldBlock",
      'Data': figureAffineLineFieldBlockToJson(item)
    };
  } else if (item is FigureBlock) {
    return {'Kind': "FigureBlock", 'Data': figureBlockToJson(item)};
  } else if (item is FigurePointFieldBlock) {
    return {
      'Kind': "FigurePointFieldBlock",
      'Data': figurePointFieldBlockToJson(item)
    };
  } else if (item is FigureVectorFieldBlock) {
    return {
      'Kind': "FigureVectorFieldBlock",
      'Data': figureVectorFieldBlockToJson(item)
    };
  } else if (item is FigureVectorPairFieldBlock) {
    return {
      'Kind': "FigureVectorPairFieldBlock",
      'Data': figureVectorPairFieldBlockToJson(item)
    };
  } else if (item is FormulaBlock) {
    return {'Kind': "FormulaBlock", 'Data': formulaBlockToJson(item)};
  } else if (item is FunctionPointsFieldBlock) {
    return {
      'Kind': "FunctionPointsFieldBlock",
      'Data': functionPointsFieldBlockToJson(item)
    };
  } else if (item is FunctionsGraphBlock) {
    return {
      'Kind': "FunctionsGraphBlock",
      'Data': functionsGraphBlockToJson(item)
    };
  } else if (item is NumberFieldBlock) {
    return {'Kind': "NumberFieldBlock", 'Data': numberFieldBlockToJson(item)};
  } else if (item is OrderedListFieldBlock) {
    return {
      'Kind': "OrderedListFieldBlock",
      'Data': orderedListFieldBlockToJson(item)
    };
  } else if (item is ProofFieldBlock) {
    return {'Kind': "ProofFieldBlock", 'Data': proofFieldBlockToJson(item)};
  } else if (item is RadioFieldBlock) {
    return {'Kind': "RadioFieldBlock", 'Data': radioFieldBlockToJson(item)};
  } else if (item is SignTableBlock) {
    return {'Kind': "SignTableBlock", 'Data': signTableBlockToJson(item)};
  } else if (item is SignTableFieldBlock) {
    return {
      'Kind': "SignTableFieldBlock",
      'Data': signTableFieldBlockToJson(item)
    };
  } else if (item is TableBlock) {
    return {'Kind': "TableBlock", 'Data': tableBlockToJson(item)};
  } else if (item is TableFieldBlock) {
    return {'Kind': "TableFieldBlock", 'Data': tableFieldBlockToJson(item)};
  } else if (item is TextBlock) {
    return {'Kind': "TextBlock", 'Data': textBlockToJson(item)};
  } else if (item is TreeFieldBlock) {
    return {'Kind': "TreeFieldBlock", 'Data': treeFieldBlockToJson(item)};
  } else if (item is VariationTableBlock) {
    return {
      'Kind': "VariationTableBlock",
      'Data': variationTableBlockToJson(item)
    };
  } else if (item is VariationTableFieldBlock) {
    return {
      'Kind': "VariationTableFieldBlock",
      'Data': variationTableFieldBlockToJson(item)
    };
  } else if (item is VectorFieldBlock) {
    return {'Kind': "VectorFieldBlock", 'Data': vectorFieldBlockToJson(item)};
  } else {
    throw ("unexpected type");
  }
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.Co
typedef Co = String;

// github.com/benoitkugler/maths-online/server/src/maths/questions.ComparisonLevel
enum ComparisonLevel {
  asLinearEquation,
  expandedSubstitutions,
  simpleSubstitutions,
  strict
}

extension _ComparisonLevelExt on ComparisonLevel {
  static const _values = [102, 2, 1, 0];
  static ComparisonLevel fromValue(int s) {
    return ComparisonLevel.values[_values.indexOf(s)];
  }

  int toValue() {
    return _values[index];
  }
}

ComparisonLevel comparisonLevelFromJson(dynamic json) =>
    _ComparisonLevelExt.fromValue(json as int);

dynamic comparisonLevelToJson(ComparisonLevel item) => item.toValue();

// github.com/benoitkugler/maths-online/server/src/maths/questions.CoordExpression
class CoordExpression {
  final String x;
  final String y;

  const CoordExpression(this.x, this.y);

  @override
  String toString() {
    return "CoordExpression($x, $y)";
  }
}

CoordExpression coordExpressionFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return CoordExpression(stringFromJson(json['X']), stringFromJson(json['Y']));
}

Map<String, dynamic> coordExpressionToJson(CoordExpression item) {
  return {"X": stringToJson(item.x), "Y": stringToJson(item.y)};
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.Enonce
typedef Enonce = List<Block>;

Enonce enonceFromJson(dynamic json) {
  return listBlockFromJson(json);
}

dynamic enonceToJson(Enonce item) {
  return listBlockToJson(item);
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.ExpressionFieldBlock
class ExpressionFieldBlock implements Block {
  final String expression;
  final Interpolated label;
  final ComparisonLevel comparisonLevel;
  final bool showFractionHelp;

  const ExpressionFieldBlock(
      this.expression, this.label, this.comparisonLevel, this.showFractionHelp);

  @override
  String toString() {
    return "ExpressionFieldBlock($expression, $label, $comparisonLevel, $showFractionHelp)";
  }
}

ExpressionFieldBlock expressionFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return ExpressionFieldBlock(
      stringFromJson(json['Expression']),
      stringFromJson(json['Label']),
      comparisonLevelFromJson(json['ComparisonLevel']),
      boolFromJson(json['ShowFractionHelp']));
}

Map<String, dynamic> expressionFieldBlockToJson(ExpressionFieldBlock item) {
  return {
    "Expression": stringToJson(item.expression),
    "Label": stringToJson(item.label),
    "ComparisonLevel": comparisonLevelToJson(item.comparisonLevel),
    "ShowFractionHelp": boolToJson(item.showFractionHelp)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.FigureAffineLineFieldBlock
class FigureAffineLineFieldBlock implements Block {
  final String label;
  final String a;
  final String b;
  final FigureBlock figure;

  const FigureAffineLineFieldBlock(this.label, this.a, this.b, this.figure);

  @override
  String toString() {
    return "FigureAffineLineFieldBlock($label, $a, $b, $figure)";
  }
}

FigureAffineLineFieldBlock figureAffineLineFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return FigureAffineLineFieldBlock(
      stringFromJson(json['Label']),
      stringFromJson(json['A']),
      stringFromJson(json['B']),
      figureBlockFromJson(json['Figure']));
}

Map<String, dynamic> figureAffineLineFieldBlockToJson(
    FigureAffineLineFieldBlock item) {
  return {
    "Label": stringToJson(item.label),
    "A": stringToJson(item.a),
    "B": stringToJson(item.b),
    "Figure": figureBlockToJson(item.figure)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.FigureBlock
class FigureBlock implements Block {
  final RandomDrawings drawings;
  final RepereBounds bounds;
  final bool showGrid;
  final bool showOrigin;

  const FigureBlock(this.drawings, this.bounds, this.showGrid, this.showOrigin);

  @override
  String toString() {
    return "FigureBlock($drawings, $bounds, $showGrid, $showOrigin)";
  }
}

FigureBlock figureBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return FigureBlock(
      randomDrawingsFromJson(json['Drawings']),
      repereBoundsFromJson(json['Bounds']),
      boolFromJson(json['ShowGrid']),
      boolFromJson(json['ShowOrigin']));
}

Map<String, dynamic> figureBlockToJson(FigureBlock item) {
  return {
    "Drawings": randomDrawingsToJson(item.drawings),
    "Bounds": repereBoundsToJson(item.bounds),
    "ShowGrid": boolToJson(item.showGrid),
    "ShowOrigin": boolToJson(item.showOrigin)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.FigurePointFieldBlock
class FigurePointFieldBlock implements Block {
  final CoordExpression answer;
  final FigureBlock figure;

  const FigurePointFieldBlock(this.answer, this.figure);

  @override
  String toString() {
    return "FigurePointFieldBlock($answer, $figure)";
  }
}

FigurePointFieldBlock figurePointFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return FigurePointFieldBlock(coordExpressionFromJson(json['Answer']),
      figureBlockFromJson(json['Figure']));
}

Map<String, dynamic> figurePointFieldBlockToJson(FigurePointFieldBlock item) {
  return {
    "Answer": coordExpressionToJson(item.answer),
    "Figure": figureBlockToJson(item.figure)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.FigureVectorFieldBlock
class FigureVectorFieldBlock implements Block {
  final CoordExpression answer;
  final CoordExpression answerOrigin;
  final FigureBlock figure;
  final bool mustHaveOrigin;

  const FigureVectorFieldBlock(
      this.answer, this.answerOrigin, this.figure, this.mustHaveOrigin);

  @override
  String toString() {
    return "FigureVectorFieldBlock($answer, $answerOrigin, $figure, $mustHaveOrigin)";
  }
}

FigureVectorFieldBlock figureVectorFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return FigureVectorFieldBlock(
      coordExpressionFromJson(json['Answer']),
      coordExpressionFromJson(json['AnswerOrigin']),
      figureBlockFromJson(json['Figure']),
      boolFromJson(json['MustHaveOrigin']));
}

Map<String, dynamic> figureVectorFieldBlockToJson(FigureVectorFieldBlock item) {
  return {
    "Answer": coordExpressionToJson(item.answer),
    "AnswerOrigin": coordExpressionToJson(item.answerOrigin),
    "Figure": figureBlockToJson(item.figure),
    "MustHaveOrigin": boolToJson(item.mustHaveOrigin)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.FigureVectorPairFieldBlock
class FigureVectorPairFieldBlock implements Block {
  final FigureBlock figure;
  final VectorPairCriterion criterion;

  const FigureVectorPairFieldBlock(this.figure, this.criterion);

  @override
  String toString() {
    return "FigureVectorPairFieldBlock($figure, $criterion)";
  }
}

FigureVectorPairFieldBlock figureVectorPairFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return FigureVectorPairFieldBlock(figureBlockFromJson(json['Figure']),
      vectorPairCriterionFromJson(json['Criterion']));
}

Map<String, dynamic> figureVectorPairFieldBlockToJson(
    FigureVectorPairFieldBlock item) {
  return {
    "Figure": figureBlockToJson(item.figure),
    "Criterion": vectorPairCriterionToJson(item.criterion)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.FormulaBlock
class FormulaBlock implements Block {
  final Interpolated parts;

  const FormulaBlock(this.parts);

  @override
  String toString() {
    return "FormulaBlock($parts)";
  }
}

FormulaBlock formulaBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return FormulaBlock(stringFromJson(json['Parts']));
}

Map<String, dynamic> formulaBlockToJson(FormulaBlock item) {
  return {"Parts": stringToJson(item.parts)};
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.FunctionArea
class FunctionArea {
  final Interpolated bottom;
  final Interpolated top;
  final String left;
  final String right;
  final String color;

  const FunctionArea(this.bottom, this.top, this.left, this.right, this.color);

  @override
  String toString() {
    return "FunctionArea($bottom, $top, $left, $right, $color)";
  }
}

FunctionArea functionAreaFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return FunctionArea(
      stringFromJson(json['Bottom']),
      stringFromJson(json['Top']),
      stringFromJson(json['Left']),
      stringFromJson(json['Right']),
      stringFromJson(json['Color']));
}

Map<String, dynamic> functionAreaToJson(FunctionArea item) {
  return {
    "Bottom": stringToJson(item.bottom),
    "Top": stringToJson(item.top),
    "Left": stringToJson(item.left),
    "Right": stringToJson(item.right),
    "Color": stringToJson(item.color)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.FunctionDefinition
class FunctionDefinition {
  final String function;
  final FunctionDecoration decoration;
  final Variable variable;
  final String from;
  final String to;

  const FunctionDefinition(
      this.function, this.decoration, this.variable, this.from, this.to);

  @override
  String toString() {
    return "FunctionDefinition($function, $decoration, $variable, $from, $to)";
  }
}

FunctionDefinition functionDefinitionFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return FunctionDefinition(
      stringFromJson(json['Function']),
      functionDecorationFromJson(json['Decoration']),
      variableFromJson(json['Variable']),
      stringFromJson(json['From']),
      stringFromJson(json['To']));
}

Map<String, dynamic> functionDefinitionToJson(FunctionDefinition item) {
  return {
    "Function": stringToJson(item.function),
    "Decoration": functionDecorationToJson(item.decoration),
    "Variable": variableToJson(item.variable),
    "From": stringToJson(item.from),
    "To": stringToJson(item.to)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.FunctionPoint
class FunctionPoint {
  final Interpolated function;
  final String x;
  final String color;
  final Interpolated legend;

  const FunctionPoint(this.function, this.x, this.color, this.legend);

  @override
  String toString() {
    return "FunctionPoint($function, $x, $color, $legend)";
  }
}

FunctionPoint functionPointFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return FunctionPoint(
      stringFromJson(json['Function']),
      stringFromJson(json['X']),
      stringFromJson(json['Color']),
      stringFromJson(json['Legend']));
}

Map<String, dynamic> functionPointToJson(FunctionPoint item) {
  return {
    "Function": stringToJson(item.function),
    "X": stringToJson(item.x),
    "Color": stringToJson(item.color),
    "Legend": stringToJson(item.legend)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.FunctionPointsFieldBlock
class FunctionPointsFieldBlock implements Block {
  final String function;
  final String label;
  final Variable variable;
  final List<String> xGrid;

  const FunctionPointsFieldBlock(
      this.function, this.label, this.variable, this.xGrid);

  @override
  String toString() {
    return "FunctionPointsFieldBlock($function, $label, $variable, $xGrid)";
  }
}

FunctionPointsFieldBlock functionPointsFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return FunctionPointsFieldBlock(
      stringFromJson(json['Function']),
      stringFromJson(json['Label']),
      variableFromJson(json['Variable']),
      listStringFromJson(json['XGrid']));
}

Map<String, dynamic> functionPointsFieldBlockToJson(
    FunctionPointsFieldBlock item) {
  return {
    "Function": stringToJson(item.function),
    "Label": stringToJson(item.label),
    "Variable": variableToJson(item.variable),
    "XGrid": listStringToJson(item.xGrid)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.FunctionsGraphBlock
class FunctionsGraphBlock implements Block {
  final List<FunctionDefinition> functionExprs;
  final List<VariationTableBlock> functionVariations;
  final List<FunctionArea> areas;
  final List<FunctionPoint> points;

  const FunctionsGraphBlock(
      this.functionExprs, this.functionVariations, this.areas, this.points);

  @override
  String toString() {
    return "FunctionsGraphBlock($functionExprs, $functionVariations, $areas, $points)";
  }
}

FunctionsGraphBlock functionsGraphBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return FunctionsGraphBlock(
      listFunctionDefinitionFromJson(json['FunctionExprs']),
      listVariationTableBlockFromJson(json['FunctionVariations']),
      listFunctionAreaFromJson(json['Areas']),
      listFunctionPointFromJson(json['Points']));
}

Map<String, dynamic> functionsGraphBlockToJson(FunctionsGraphBlock item) {
  return {
    "FunctionExprs": listFunctionDefinitionToJson(item.functionExprs),
    "FunctionVariations":
        listVariationTableBlockToJson(item.functionVariations),
    "Areas": listFunctionAreaToJson(item.areas),
    "Points": listFunctionPointToJson(item.points)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.In
typedef In = String;

// github.com/benoitkugler/maths-online/server/src/maths/questions.Interpolated
typedef Interpolated = String;

// github.com/benoitkugler/maths-online/server/src/maths/questions.NumberFieldBlock
class NumberFieldBlock implements Block {
  final String expression;

  const NumberFieldBlock(this.expression);

  @override
  String toString() {
    return "NumberFieldBlock($expression)";
  }
}

NumberFieldBlock numberFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return NumberFieldBlock(stringFromJson(json['Expression']));
}

Map<String, dynamic> numberFieldBlockToJson(NumberFieldBlock item) {
  return {"Expression": stringToJson(item.expression)};
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.OrderedListFieldBlock
class OrderedListFieldBlock implements Block {
  final Interpolated label;
  final List<Interpolated> answer;
  final List<Interpolated> additionalProposals;

  const OrderedListFieldBlock(
      this.label, this.answer, this.additionalProposals);

  @override
  String toString() {
    return "OrderedListFieldBlock($label, $answer, $additionalProposals)";
  }
}

OrderedListFieldBlock orderedListFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return OrderedListFieldBlock(
      stringFromJson(json['Label']),
      listStringFromJson(json['Answer']),
      listStringFromJson(json['AdditionalProposals']));
}

Map<String, dynamic> orderedListFieldBlockToJson(OrderedListFieldBlock item) {
  return {
    "Label": stringToJson(item.label),
    "Answer": listStringToJson(item.answer),
    "AdditionalProposals": listStringToJson(item.additionalProposals)
  };
}

/// github.com/benoitkugler/maths-online/server/src/maths/questions.ParameterEntry
abstract class ParameterEntry {}

ParameterEntry parameterEntryFromJson(dynamic json_) {
  final json = json_ as Map<String, dynamic>;
  final kind = json['Kind'] as String;
  final data = json['Data'];
  switch (kind) {
    case "Co":
      return stringFromJson(data);
    case "In":
      return stringFromJson(data);
    case "Rp":
      return rpFromJson(data);
    default:
      throw ("unexpected type");
  }
}

Map<String, dynamic> parameterEntryToJson(ParameterEntry item) {
  if (item is Co) {
    return {'Kind': "Co", 'Data': stringToJson(item)};
  } else if (item is In) {
    return {'Kind': "In", 'Data': stringToJson(item)};
  } else if (item is Rp) {
    return {'Kind': "Rp", 'Data': rpToJson(item)};
  } else {
    throw ("unexpected type");
  }
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.Parameters
typedef Parameters = List<ParameterEntry>;

Parameters parametersFromJson(dynamic json) {
  return listParameterEntryFromJson(json);
}

dynamic parametersToJson(Parameters item) {
  return listParameterEntryToJson(item);
}

/// github.com/benoitkugler/maths-online/server/src/maths/questions.ProofAssertion
abstract class ProofAssertion {}

ProofAssertion proofAssertionFromJson(dynamic json_) {
  final json = json_ as Map<String, dynamic>;
  final kind = json['Kind'] as String;
  final data = json['Data'];
  switch (kind) {
    case "ProofEquality":
      return proofEqualityFromJson(data);
    case "ProofInvalid":
      return proofInvalidFromJson(data);
    case "ProofNode":
      return proofNodeFromJson(data);
    case "ProofSequence":
      return proofSequenceFromJson(data);
    case "ProofStatement":
      return proofStatementFromJson(data);
    default:
      throw ("unexpected type");
  }
}

Map<String, dynamic> proofAssertionToJson(ProofAssertion item) {
  if (item is ProofEquality) {
    return {'Kind': "ProofEquality", 'Data': proofEqualityToJson(item)};
  } else if (item is ProofInvalid) {
    return {'Kind': "ProofInvalid", 'Data': proofInvalidToJson(item)};
  } else if (item is ProofNode) {
    return {'Kind': "ProofNode", 'Data': proofNodeToJson(item)};
  } else if (item is ProofSequence) {
    return {'Kind': "ProofSequence", 'Data': proofSequenceToJson(item)};
  } else if (item is ProofStatement) {
    return {'Kind': "ProofStatement", 'Data': proofStatementToJson(item)};
  } else {
    throw ("unexpected type");
  }
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.ProofAssertions
typedef ProofAssertions = List<ProofAssertion>;

ProofAssertions proofAssertionsFromJson(dynamic json) {
  return listProofAssertionFromJson(json);
}

dynamic proofAssertionsToJson(ProofAssertions item) {
  return listProofAssertionToJson(item);
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.ProofEquality
class ProofEquality implements ProofAssertion {
  final String terms;

  const ProofEquality(this.terms);

  @override
  String toString() {
    return "ProofEquality($terms)";
  }
}

ProofEquality proofEqualityFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return ProofEquality(stringFromJson(json['Terms']));
}

Map<String, dynamic> proofEqualityToJson(ProofEquality item) {
  return {"Terms": stringToJson(item.terms)};
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.ProofFieldBlock
class ProofFieldBlock implements Block {
  final ProofSequence answer;

  const ProofFieldBlock(this.answer);

  @override
  String toString() {
    return "ProofFieldBlock($answer)";
  }
}

ProofFieldBlock proofFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return ProofFieldBlock(proofSequenceFromJson(json['Answer']));
}

Map<String, dynamic> proofFieldBlockToJson(ProofFieldBlock item) {
  return {"Answer": proofSequenceToJson(item.answer)};
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.ProofInvalid
class ProofInvalid implements ProofAssertion {
  const ProofInvalid();

  @override
  String toString() {
    return "ProofInvalid()";
  }
}

ProofInvalid proofInvalidFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return ProofInvalid();
}

Map<String, dynamic> proofInvalidToJson(ProofInvalid item) {
  return {};
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.ProofNode
class ProofNode implements ProofAssertion {
  final ProofAssertion left;
  final ProofAssertion right;
  final Binary op;

  const ProofNode(this.left, this.right, this.op);

  @override
  String toString() {
    return "ProofNode($left, $right, $op)";
  }
}

ProofNode proofNodeFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return ProofNode(proofAssertionFromJson(json['Left']),
      proofAssertionFromJson(json['Right']), binaryFromJson(json['Op']));
}

Map<String, dynamic> proofNodeToJson(ProofNode item) {
  return {
    "Left": proofAssertionToJson(item.left),
    "Right": proofAssertionToJson(item.right),
    "Op": binaryToJson(item.op)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.ProofSequence
class ProofSequence implements ProofAssertion {
  final ProofAssertions parts;

  const ProofSequence(this.parts);

  @override
  String toString() {
    return "ProofSequence($parts)";
  }
}

ProofSequence proofSequenceFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return ProofSequence(proofAssertionsFromJson(json['Parts']));
}

Map<String, dynamic> proofSequenceToJson(ProofSequence item) {
  return {"Parts": proofAssertionsToJson(item.parts)};
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.ProofStatement
class ProofStatement implements ProofAssertion {
  final Interpolated content;

  const ProofStatement(this.content);

  @override
  String toString() {
    return "ProofStatement($content)";
  }
}

ProofStatement proofStatementFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return ProofStatement(stringFromJson(json['Content']));
}

Map<String, dynamic> proofStatementToJson(ProofStatement item) {
  return {"Content": stringToJson(item.content)};
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.QuestionPage
class QuestionPage {
  final Enonce enonce;
  final Parameters parameters;

  const QuestionPage(this.enonce, this.parameters);

  @override
  String toString() {
    return "QuestionPage($enonce, $parameters)";
  }
}

QuestionPage questionPageFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return QuestionPage(
      enonceFromJson(json['enonce']), parametersFromJson(json['parameters']));
}

Map<String, dynamic> questionPageToJson(QuestionPage item) {
  return {
    "enonce": enonceToJson(item.enonce),
    "parameters": parametersToJson(item.parameters)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.RadioFieldBlock
class RadioFieldBlock implements Block {
  final String answer;
  final List<Interpolated> proposals;
  final bool asDropDown;

  const RadioFieldBlock(this.answer, this.proposals, this.asDropDown);

  @override
  String toString() {
    return "RadioFieldBlock($answer, $proposals, $asDropDown)";
  }
}

RadioFieldBlock radioFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return RadioFieldBlock(stringFromJson(json['Answer']),
      listStringFromJson(json['Proposals']), boolFromJson(json['AsDropDown']));
}

Map<String, dynamic> radioFieldBlockToJson(RadioFieldBlock item) {
  return {
    "Answer": stringToJson(item.answer),
    "Proposals": listStringToJson(item.proposals),
    "AsDropDown": boolToJson(item.asDropDown)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.Rp
class Rp implements ParameterEntry {
  final String expression;
  final Variable variable;

  const Rp(this.expression, this.variable);

  @override
  String toString() {
    return "Rp($expression, $variable)";
  }
}

Rp rpFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return Rp(
      stringFromJson(json['expression']), variableFromJson(json['variable']));
}

Map<String, dynamic> rpToJson(Rp item) {
  return {
    "expression": stringToJson(item.expression),
    "variable": variableToJson(item.variable)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.SignSymbol
enum SignSymbol { nothing, zero, forbiddenValue }

extension _SignSymbolExt on SignSymbol {
  static SignSymbol fromValue(int i) {
    return SignSymbol.values[i];
  }

  int toValue() {
    return index;
  }
}

SignSymbol signSymbolFromJson(dynamic json) =>
    _SignSymbolExt.fromValue(json as int);

dynamic signSymbolToJson(SignSymbol item) => item.toValue();

// github.com/benoitkugler/maths-online/server/src/maths/questions.SignTableBlock
class SignTableBlock implements Block {
  final String label;
  final List<SignSymbol> fxSymbols;
  final List<String> xs;
  final List<bool> signs;

  const SignTableBlock(this.label, this.fxSymbols, this.xs, this.signs);

  @override
  String toString() {
    return "SignTableBlock($label, $fxSymbols, $xs, $signs)";
  }
}

SignTableBlock signTableBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return SignTableBlock(
      stringFromJson(json['Label']),
      listSignSymbolFromJson(json['FxSymbols']),
      listStringFromJson(json['Xs']),
      listBoolFromJson(json['Signs']));
}

Map<String, dynamic> signTableBlockToJson(SignTableBlock item) {
  return {
    "Label": stringToJson(item.label),
    "FxSymbols": listSignSymbolToJson(item.fxSymbols),
    "Xs": listStringToJson(item.xs),
    "Signs": listBoolToJson(item.signs)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.SignTableFieldBlock
class SignTableFieldBlock implements Block {
  final SignTableBlock answer;

  const SignTableFieldBlock(this.answer);

  @override
  String toString() {
    return "SignTableFieldBlock($answer)";
  }
}

SignTableFieldBlock signTableFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return SignTableFieldBlock(signTableBlockFromJson(json['Answer']));
}

Map<String, dynamic> signTableFieldBlockToJson(SignTableFieldBlock item) {
  return {"Answer": signTableBlockToJson(item.answer)};
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.TableBlock
class TableBlock implements Block {
  final List<TextPart> horizontalHeaders;
  final List<TextPart> verticalHeaders;
  final List<List<TextPart>> values;

  const TableBlock(this.horizontalHeaders, this.verticalHeaders, this.values);

  @override
  String toString() {
    return "TableBlock($horizontalHeaders, $verticalHeaders, $values)";
  }
}

TableBlock tableBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return TableBlock(
      listTextPartFromJson(json['HorizontalHeaders']),
      listTextPartFromJson(json['VerticalHeaders']),
      listListTextPartFromJson(json['Values']));
}

Map<String, dynamic> tableBlockToJson(TableBlock item) {
  return {
    "HorizontalHeaders": listTextPartToJson(item.horizontalHeaders),
    "VerticalHeaders": listTextPartToJson(item.verticalHeaders),
    "Values": listListTextPartToJson(item.values)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.TableFieldBlock
class TableFieldBlock implements Block {
  final List<TextPart> horizontalHeaders;
  final List<TextPart> verticalHeaders;
  final List<List<String>> answer;

  const TableFieldBlock(
      this.horizontalHeaders, this.verticalHeaders, this.answer);

  @override
  String toString() {
    return "TableFieldBlock($horizontalHeaders, $verticalHeaders, $answer)";
  }
}

TableFieldBlock tableFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return TableFieldBlock(
      listTextPartFromJson(json['HorizontalHeaders']),
      listTextPartFromJson(json['VerticalHeaders']),
      listListStringFromJson(json['Answer']));
}

Map<String, dynamic> tableFieldBlockToJson(TableFieldBlock item) {
  return {
    "HorizontalHeaders": listTextPartToJson(item.horizontalHeaders),
    "VerticalHeaders": listTextPartToJson(item.verticalHeaders),
    "Answer": listListStringToJson(item.answer)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.TextBlock
class TextBlock implements Block {
  final Interpolated parts;
  final bool bold;
  final bool italic;
  final bool smaller;

  const TextBlock(this.parts, this.bold, this.italic, this.smaller);

  @override
  String toString() {
    return "TextBlock($parts, $bold, $italic, $smaller)";
  }
}

TextBlock textBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return TextBlock(stringFromJson(json['Parts']), boolFromJson(json['Bold']),
      boolFromJson(json['Italic']), boolFromJson(json['Smaller']));
}

Map<String, dynamic> textBlockToJson(TextBlock item) {
  return {
    "Parts": stringToJson(item.parts),
    "Bold": boolToJson(item.bold),
    "Italic": boolToJson(item.italic),
    "Smaller": boolToJson(item.smaller)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.TextKind
enum TextKind { text, staticMath, expression }

extension _TextKindExt on TextKind {
  static TextKind fromValue(int i) {
    return TextKind.values[i];
  }

  int toValue() {
    return index;
  }
}

TextKind textKindFromJson(dynamic json) => _TextKindExt.fromValue(json as int);

dynamic textKindToJson(TextKind item) => item.toValue();

// github.com/benoitkugler/maths-online/server/src/maths/questions.TextPart
class TextPart {
  final String content;
  final TextKind kind;

  const TextPart(this.content, this.kind);

  @override
  String toString() {
    return "TextPart($content, $kind)";
  }
}

TextPart textPartFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return TextPart(
      stringFromJson(json['Content']), textKindFromJson(json['Kind']));
}

Map<String, dynamic> textPartToJson(TextPart item) {
  return {
    "Content": stringToJson(item.content),
    "Kind": textKindToJson(item.kind)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.TreeFieldBlock
class TreeFieldBlock implements Block {
  final List<String> eventsProposals;
  final TreeNodeAnswer answerRoot;

  const TreeFieldBlock(this.eventsProposals, this.answerRoot);

  @override
  String toString() {
    return "TreeFieldBlock($eventsProposals, $answerRoot)";
  }
}

TreeFieldBlock treeFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return TreeFieldBlock(listStringFromJson(json['EventsProposals']),
      treeNodeAnswerFromJson(json['AnswerRoot']));
}

Map<String, dynamic> treeFieldBlockToJson(TreeFieldBlock item) {
  return {
    "EventsProposals": listStringToJson(item.eventsProposals),
    "AnswerRoot": treeNodeAnswerToJson(item.answerRoot)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.TreeNodeAnswer
class TreeNodeAnswer {
  final List<TreeNodeAnswer> children;
  final List<String> probabilities;
  final int value;

  const TreeNodeAnswer(this.children, this.probabilities, this.value);

  @override
  String toString() {
    return "TreeNodeAnswer($children, $probabilities, $value)";
  }
}

TreeNodeAnswer treeNodeAnswerFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return TreeNodeAnswer(listTreeNodeAnswerFromJson(json['Children']),
      listStringFromJson(json['Probabilities']), intFromJson(json['Value']));
}

Map<String, dynamic> treeNodeAnswerToJson(TreeNodeAnswer item) {
  return {
    "Children": listTreeNodeAnswerToJson(item.children),
    "Probabilities": listStringToJson(item.probabilities),
    "Value": intToJson(item.value)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.VariationTableBlock
class VariationTableBlock implements Block {
  final Interpolated label;
  final List<String> xs;
  final List<String> fxs;

  const VariationTableBlock(this.label, this.xs, this.fxs);

  @override
  String toString() {
    return "VariationTableBlock($label, $xs, $fxs)";
  }
}

VariationTableBlock variationTableBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return VariationTableBlock(stringFromJson(json['Label']),
      listStringFromJson(json['Xs']), listStringFromJson(json['Fxs']));
}

Map<String, dynamic> variationTableBlockToJson(VariationTableBlock item) {
  return {
    "Label": stringToJson(item.label),
    "Xs": listStringToJson(item.xs),
    "Fxs": listStringToJson(item.fxs)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.VariationTableFieldBlock
class VariationTableFieldBlock implements Block {
  final VariationTableBlock answer;

  const VariationTableFieldBlock(this.answer);

  @override
  String toString() {
    return "VariationTableFieldBlock($answer)";
  }
}

VariationTableFieldBlock variationTableFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return VariationTableFieldBlock(variationTableBlockFromJson(json['Answer']));
}

Map<String, dynamic> variationTableFieldBlockToJson(
    VariationTableFieldBlock item) {
  return {"Answer": variationTableBlockToJson(item.answer)};
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.VectorFieldBlock
class VectorFieldBlock implements Block {
  final CoordExpression answer;
  final bool acceptColinear;
  final bool displayColumn;

  const VectorFieldBlock(this.answer, this.acceptColinear, this.displayColumn);

  @override
  String toString() {
    return "VectorFieldBlock($answer, $acceptColinear, $displayColumn)";
  }
}

VectorFieldBlock vectorFieldBlockFromJson(dynamic json_) {
  final json = (json_ as Map<String, dynamic>);
  return VectorFieldBlock(
      coordExpressionFromJson(json['Answer']),
      boolFromJson(json['AcceptColinear']),
      boolFromJson(json['DisplayColumn']));
}

Map<String, dynamic> vectorFieldBlockToJson(VectorFieldBlock item) {
  return {
    "Answer": coordExpressionToJson(item.answer),
    "AcceptColinear": boolToJson(item.acceptColinear),
    "DisplayColumn": boolToJson(item.displayColumn)
  };
}

// github.com/benoitkugler/maths-online/server/src/maths/questions.VectorPairCriterion
enum VectorPairCriterion { vectorEquals, vectorColinear, vectorOrthogonal }

extension _VectorPairCriterionExt on VectorPairCriterion {
  static VectorPairCriterion fromValue(int i) {
    return VectorPairCriterion.values[i];
  }

  int toValue() {
    return index;
  }
}

VectorPairCriterion vectorPairCriterionFromJson(dynamic json) =>
    _VectorPairCriterionExt.fromValue(json as int);

dynamic vectorPairCriterionToJson(VectorPairCriterion item) => item.toValue();

List<Block> listBlockFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(blockFromJson).toList();
}

List<dynamic> listBlockToJson(List<Block> item) {
  return item.map(blockToJson).toList();
}

List<bool> listBoolFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(boolFromJson).toList();
}

List<dynamic> listBoolToJson(List<bool> item) {
  return item.map(boolToJson).toList();
}

List<FunctionArea> listFunctionAreaFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(functionAreaFromJson).toList();
}

List<dynamic> listFunctionAreaToJson(List<FunctionArea> item) {
  return item.map(functionAreaToJson).toList();
}

List<FunctionDefinition> listFunctionDefinitionFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(functionDefinitionFromJson).toList();
}

List<dynamic> listFunctionDefinitionToJson(List<FunctionDefinition> item) {
  return item.map(functionDefinitionToJson).toList();
}

List<FunctionPoint> listFunctionPointFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(functionPointFromJson).toList();
}

List<dynamic> listFunctionPointToJson(List<FunctionPoint> item) {
  return item.map(functionPointToJson).toList();
}

List<List<String>> listListStringFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(listStringFromJson).toList();
}

List<dynamic> listListStringToJson(List<List<String>> item) {
  return item.map(listStringToJson).toList();
}

List<List<TextPart>> listListTextPartFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(listTextPartFromJson).toList();
}

List<dynamic> listListTextPartToJson(List<List<TextPart>> item) {
  return item.map(listTextPartToJson).toList();
}

List<ParameterEntry> listParameterEntryFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(parameterEntryFromJson).toList();
}

List<dynamic> listParameterEntryToJson(List<ParameterEntry> item) {
  return item.map(parameterEntryToJson).toList();
}

List<ProofAssertion> listProofAssertionFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(proofAssertionFromJson).toList();
}

List<dynamic> listProofAssertionToJson(List<ProofAssertion> item) {
  return item.map(proofAssertionToJson).toList();
}

List<SignSymbol> listSignSymbolFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(signSymbolFromJson).toList();
}

List<dynamic> listSignSymbolToJson(List<SignSymbol> item) {
  return item.map(signSymbolToJson).toList();
}

List<Interpolated> listStringFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(stringFromJson).toList();
}

List<dynamic> listStringToJson(List<Interpolated> item) {
  return item.map(stringToJson).toList();
}

List<TextPart> listTextPartFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(textPartFromJson).toList();
}

List<dynamic> listTextPartToJson(List<TextPart> item) {
  return item.map(textPartToJson).toList();
}

List<TreeNodeAnswer> listTreeNodeAnswerFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(treeNodeAnswerFromJson).toList();
}

List<dynamic> listTreeNodeAnswerToJson(List<TreeNodeAnswer> item) {
  return item.map(treeNodeAnswerToJson).toList();
}

List<VariationTableBlock> listVariationTableBlockFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(variationTableBlockFromJson).toList();
}

List<dynamic> listVariationTableBlockToJson(List<VariationTableBlock> item) {
  return item.map(variationTableBlockToJson).toList();
}
