// Code generated by gomacro/generator/dart. DO NOT EDIT

import 'questions/types.gen.dart';

// github.com/benoitkugler/maths-online/tasks.Answer
class Answer {
  final List<VarEntry> params;
  final QuestionAnswersIn answer;

  const Answer(this.params, this.answer);

  @override
  String toString() {
    return "Answer($params, $answer)";
  }
}

Answer answerFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return Answer(listVarEntryFromJson(json['Params']),
      questionAnswersInFromJson(json['Answer']));
}

JSON answerToJson(Answer item) {
  return {
    "Params": listVarEntryToJson(item.params),
    "Answer": questionAnswersInToJson(item.answer)
  };
}

// github.com/benoitkugler/maths-online/tasks.EvaluateWorkIn
class EvaluateWorkIn {
  final WorkID iD;
  final Map<int, Answer> answers;
  final ProgressionExt progression;

  const EvaluateWorkIn(this.iD, this.answers, this.progression);

  @override
  String toString() {
    return "EvaluateWorkIn($iD, $answers, $progression)";
  }
}

EvaluateWorkIn evaluateWorkInFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return EvaluateWorkIn(
      workIDFromJson(json['ID']),
      dictIntToAnswerFromJson(json['Answers']),
      progressionExtFromJson(json['Progression']));
}

JSON evaluateWorkInToJson(EvaluateWorkIn item) {
  return {
    "ID": workIDToJson(item.iD),
    "Answers": dictIntToAnswerToJson(item.answers),
    "Progression": progressionExtToJson(item.progression)
  };
}

// github.com/benoitkugler/maths-online/sql/editor.Flow
enum Flow { parallel, sequencial }

extension _FlowExt on Flow {
  static Flow fromValue(int i) {
    return Flow.values[i];
  }

  int toValue() {
    return index;
  }
}

Flow flowFromJson(dynamic json) => _FlowExt.fromValue(json as int);

dynamic flowToJson(Flow item) => item.toValue();

// github.com/benoitkugler/maths-online/sql/editor.IdQuestion
typedef IdQuestion = int;

// github.com/benoitkugler/maths-online/tasks.InstantiatedQuestion
class InstantiatedQuestion {
  final IdQuestion id;
  final Question question;
  final List<VarEntry> params;

  const InstantiatedQuestion(this.id, this.question, this.params);

  @override
  String toString() {
    return "InstantiatedQuestion($id, $question, $params)";
  }
}

InstantiatedQuestion instantiatedQuestionFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return InstantiatedQuestion(intFromJson(json['Id']),
      questionFromJson(json['Question']), listVarEntryFromJson(json['Params']));
}

JSON instantiatedQuestionToJson(InstantiatedQuestion item) {
  return {
    "Id": intToJson(item.id),
    "Question": questionToJson(item.question),
    "Params": listVarEntryToJson(item.params)
  };
}

// github.com/benoitkugler/maths-online/tasks.InstantiatedWork
class InstantiatedWork {
  final WorkID iD;
  final String title;
  final Flow flow;
  final List<InstantiatedQuestion> questions;
  final List<int> baremes;

  const InstantiatedWork(
      this.iD, this.title, this.flow, this.questions, this.baremes);

  @override
  String toString() {
    return "InstantiatedWork($iD, $title, $flow, $questions, $baremes)";
  }
}

InstantiatedWork instantiatedWorkFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return InstantiatedWork(
      workIDFromJson(json['ID']),
      stringFromJson(json['Title']),
      flowFromJson(json['Flow']),
      listInstantiatedQuestionFromJson(json['Questions']),
      listIntFromJson(json['Baremes']));
}

JSON instantiatedWorkToJson(InstantiatedWork item) {
  return {
    "ID": workIDToJson(item.iD),
    "Title": stringToJson(item.title),
    "Flow": flowToJson(item.flow),
    "Questions": listInstantiatedQuestionToJson(item.questions),
    "Baremes": listIntToJson(item.baremes)
  };
}

/// github.com/benoitkugler/maths-online/prof/editor.LoopbackClientEvent
abstract class LoopbackClientEvent {}

LoopbackClientEvent loopbackClientEventFromJson(dynamic json_) {
  final json = json_ as JSON;
  final kind = json['Kind'] as String;
  final data = json['Data'];
  switch (kind) {
    case "loopbackExerciceValidIn":
      return loopbackExerciceValidInFromJson(data);
    case "loopbackPing":
      return loopbackPingFromJson(data);
    case "loopbackQuestionCorrectAnswersIn":
      return loopbackQuestionCorrectAnswersInFromJson(data);
    case "loopbackQuestionValidIn":
      return loopbackQuestionValidInFromJson(data);
    default:
      throw ("unexpected type");
  }
}

JSON loopbackClientEventToJson(LoopbackClientEvent item) {
  if (item is LoopbackExerciceValidIn) {
    return {
      'Kind': "loopbackExerciceValidIn",
      'Data': loopbackExerciceValidInToJson(item)
    };
  } else if (item is LoopbackPing) {
    return {'Kind': "loopbackPing", 'Data': loopbackPingToJson(item)};
  } else if (item is LoopbackQuestionCorrectAnswersIn) {
    return {
      'Kind': "loopbackQuestionCorrectAnswersIn",
      'Data': loopbackQuestionCorrectAnswersInToJson(item)
    };
  } else if (item is LoopbackQuestionValidIn) {
    return {
      'Kind': "loopbackQuestionValidIn",
      'Data': loopbackQuestionValidInToJson(item)
    };
  } else {
    throw ("unexpected type");
  }
}

// github.com/benoitkugler/maths-online/prof/editor.loopbackExerciceValidIn
class LoopbackExerciceValidIn implements LoopbackClientEvent {
  final EvaluateWorkIn answer;

  const LoopbackExerciceValidIn(this.answer);

  @override
  String toString() {
    return "LoopbackExerciceValidIn($answer)";
  }
}

LoopbackExerciceValidIn loopbackExerciceValidInFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return LoopbackExerciceValidIn(evaluateWorkInFromJson(json['Answer']));
}

JSON loopbackExerciceValidInToJson(LoopbackExerciceValidIn item) {
  return {"Answer": evaluateWorkInToJson(item.answer)};
}

// github.com/benoitkugler/maths-online/prof/editor.loopbackPaused
class LoopbackPaused implements LoopbackServerEvent {
  const LoopbackPaused();

  @override
  String toString() {
    return "LoopbackPaused()";
  }
}

LoopbackPaused loopbackPausedFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return LoopbackPaused();
}

JSON loopbackPausedToJson(LoopbackPaused item) {
  return {};
}

// github.com/benoitkugler/maths-online/prof/editor.loopbackPing
class LoopbackPing implements LoopbackClientEvent {
  const LoopbackPing();

  @override
  String toString() {
    return "LoopbackPing()";
  }
}

LoopbackPing loopbackPingFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return LoopbackPing();
}

JSON loopbackPingToJson(LoopbackPing item) {
  return {};
}

// github.com/benoitkugler/maths-online/prof/editor.loopbackQuestion
class LoopbackQuestion implements LoopbackServerEvent {
  final Question question;

  const LoopbackQuestion(this.question);

  @override
  String toString() {
    return "LoopbackQuestion($question)";
  }
}

LoopbackQuestion loopbackQuestionFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return LoopbackQuestion(questionFromJson(json['Question']));
}

JSON loopbackQuestionToJson(LoopbackQuestion item) {
  return {"Question": questionToJson(item.question)};
}

// github.com/benoitkugler/maths-online/prof/editor.loopbackQuestionCorrectAnswersIn
class LoopbackQuestionCorrectAnswersIn implements LoopbackClientEvent {
  const LoopbackQuestionCorrectAnswersIn();

  @override
  String toString() {
    return "LoopbackQuestionCorrectAnswersIn()";
  }
}

LoopbackQuestionCorrectAnswersIn loopbackQuestionCorrectAnswersInFromJson(
    dynamic json_) {
  final json = (json_ as JSON);
  return LoopbackQuestionCorrectAnswersIn();
}

JSON loopbackQuestionCorrectAnswersInToJson(
    LoopbackQuestionCorrectAnswersIn item) {
  return {};
}

// github.com/benoitkugler/maths-online/prof/editor.loopbackQuestionCorrectAnswersOut
class LoopbackQuestionCorrectAnswersOut implements LoopbackServerEvent {
  final QuestionAnswersIn answers;

  const LoopbackQuestionCorrectAnswersOut(this.answers);

  @override
  String toString() {
    return "LoopbackQuestionCorrectAnswersOut($answers)";
  }
}

LoopbackQuestionCorrectAnswersOut loopbackQuestionCorrectAnswersOutFromJson(
    dynamic json_) {
  final json = (json_ as JSON);
  return LoopbackQuestionCorrectAnswersOut(
      questionAnswersInFromJson(json['Answers']));
}

JSON loopbackQuestionCorrectAnswersOutToJson(
    LoopbackQuestionCorrectAnswersOut item) {
  return {"Answers": questionAnswersInToJson(item.answers)};
}

// github.com/benoitkugler/maths-online/prof/editor.loopbackQuestionValidIn
class LoopbackQuestionValidIn implements LoopbackClientEvent {
  final QuestionAnswersIn answers;

  const LoopbackQuestionValidIn(this.answers);

  @override
  String toString() {
    return "LoopbackQuestionValidIn($answers)";
  }
}

LoopbackQuestionValidIn loopbackQuestionValidInFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return LoopbackQuestionValidIn(questionAnswersInFromJson(json['Answers']));
}

JSON loopbackQuestionValidInToJson(LoopbackQuestionValidIn item) {
  return {"Answers": questionAnswersInToJson(item.answers)};
}

// github.com/benoitkugler/maths-online/prof/editor.loopbackQuestionValidOut
class LoopbackQuestionValidOut implements LoopbackServerEvent {
  final QuestionAnswersOut answers;

  const LoopbackQuestionValidOut(this.answers);

  @override
  String toString() {
    return "LoopbackQuestionValidOut($answers)";
  }
}

LoopbackQuestionValidOut loopbackQuestionValidOutFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return LoopbackQuestionValidOut(questionAnswersOutFromJson(json['Answers']));
}

JSON loopbackQuestionValidOutToJson(LoopbackQuestionValidOut item) {
  return {"Answers": questionAnswersOutToJson(item.answers)};
}

/// github.com/benoitkugler/maths-online/prof/editor.LoopbackServerEvent
abstract class LoopbackServerEvent {}

LoopbackServerEvent loopbackServerEventFromJson(dynamic json_) {
  final json = json_ as JSON;
  final kind = json['Kind'] as String;
  final data = json['Data'];
  switch (kind) {
    case "loopbackPaused":
      return loopbackPausedFromJson(data);
    case "loopbackQuestion":
      return loopbackQuestionFromJson(data);
    case "loopbackQuestionCorrectAnswersOut":
      return loopbackQuestionCorrectAnswersOutFromJson(data);
    case "loopbackQuestionValidOut":
      return loopbackQuestionValidOutFromJson(data);
    case "loopbackShowExercice":
      return loopbackShowExerciceFromJson(data);
    default:
      throw ("unexpected type");
  }
}

JSON loopbackServerEventToJson(LoopbackServerEvent item) {
  if (item is LoopbackPaused) {
    return {'Kind': "loopbackPaused", 'Data': loopbackPausedToJson(item)};
  } else if (item is LoopbackQuestion) {
    return {'Kind': "loopbackQuestion", 'Data': loopbackQuestionToJson(item)};
  } else if (item is LoopbackQuestionCorrectAnswersOut) {
    return {
      'Kind': "loopbackQuestionCorrectAnswersOut",
      'Data': loopbackQuestionCorrectAnswersOutToJson(item)
    };
  } else if (item is LoopbackQuestionValidOut) {
    return {
      'Kind': "loopbackQuestionValidOut",
      'Data': loopbackQuestionValidOutToJson(item)
    };
  } else if (item is LoopbackShowExercice) {
    return {
      'Kind': "loopbackShowExercice",
      'Data': loopbackShowExerciceToJson(item)
    };
  } else {
    throw ("unexpected type");
  }
}

// github.com/benoitkugler/maths-online/prof/editor.loopbackShowExercice
class LoopbackShowExercice implements LoopbackServerEvent {
  final InstantiatedWork exercice;
  final ProgressionExt progression;

  const LoopbackShowExercice(this.exercice, this.progression);

  @override
  String toString() {
    return "LoopbackShowExercice($exercice, $progression)";
  }
}

LoopbackShowExercice loopbackShowExerciceFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return LoopbackShowExercice(instantiatedWorkFromJson(json['Exercice']),
      progressionExtFromJson(json['Progression']));
}

JSON loopbackShowExerciceToJson(LoopbackShowExercice item) {
  return {
    "Exercice": instantiatedWorkToJson(item.exercice),
    "Progression": progressionExtToJson(item.progression)
  };
}

// github.com/benoitkugler/maths-online/tasks.ProgressionExt
class ProgressionExt {
  final List<QuestionHistory> questions;
  final int nextQuestion;

  const ProgressionExt(this.questions, this.nextQuestion);

  @override
  String toString() {
    return "ProgressionExt($questions, $nextQuestion)";
  }
}

ProgressionExt progressionExtFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return ProgressionExt(listListBoolFromJson(json['Questions']),
      intFromJson(json['NextQuestion']));
}

JSON progressionExtToJson(ProgressionExt item) {
  return {
    "Questions": listListBoolToJson(item.questions),
    "NextQuestion": intToJson(item.nextQuestion)
  };
}

// github.com/benoitkugler/maths-online/sql/tasks.QuestionHistory
typedef QuestionHistory = List<bool>;

String stringFromJson(dynamic json) => json == null ? "" : json as String;

String stringToJson(String item) => item;

// github.com/benoitkugler/maths-online/tasks.VarEntry
class VarEntry {
  final Variable variable;
  final String resolved;

  const VarEntry(this.variable, this.resolved);

  @override
  String toString() {
    return "VarEntry($variable, $resolved)";
  }
}

VarEntry varEntryFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return VarEntry(
      variableFromJson(json['Variable']), stringFromJson(json['Resolved']));
}

JSON varEntryToJson(VarEntry item) {
  return {
    "Variable": variableToJson(item.variable),
    "Resolved": stringToJson(item.resolved)
  };
}

// github.com/benoitkugler/maths-online/maths/expression.Variable
class Variable {
  final String indice;
  final int name;

  const Variable(this.indice, this.name);

  @override
  String toString() {
    return "Variable($indice, $name)";
  }
}

Variable variableFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return Variable(stringFromJson(json['Indice']), intFromJson(json['Name']));
}

JSON variableToJson(Variable item) {
  return {"Indice": stringToJson(item.indice), "Name": intToJson(item.name)};
}

// github.com/benoitkugler/maths-online/tasks.WorkID
class WorkID {
  final int iD;
  final bool isExercice;

  const WorkID(this.iD, this.isExercice);

  @override
  String toString() {
    return "WorkID($iD, $isExercice)";
  }
}

WorkID workIDFromJson(dynamic json_) {
  final json = (json_ as JSON);
  return WorkID(intFromJson(json['ID']), boolFromJson(json['IsExercice']));
}

JSON workIDToJson(WorkID item) {
  return {"ID": intToJson(item.iD), "IsExercice": boolToJson(item.isExercice)};
}

typedef JSON = Map<String, dynamic>; // alias to shorten JSON convertors
bool boolFromJson(dynamic json) => json as bool;

bool boolToJson(bool item) => item;

Map<int, Answer> dictIntToAnswerFromJson(dynamic json) {
  if (json == null) {
    return {};
  }
  return (json as JSON)
      .map((k, v) => MapEntry(int.parse(k), answerFromJson(v)));
}

Map<String, dynamic> dictIntToAnswerToJson(Map<int, Answer> item) {
  return item.map((k, v) => MapEntry(intToJson(k).toString(), answerToJson(v)));
}

int intFromJson(dynamic json) => json as int;

int intToJson(int item) => item;

List<bool> listBoolFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(boolFromJson).toList();
}

List<dynamic> listBoolToJson(List<bool> item) {
  return item.map(boolToJson).toList();
}

List<InstantiatedQuestion> listInstantiatedQuestionFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(instantiatedQuestionFromJson).toList();
}

List<dynamic> listInstantiatedQuestionToJson(List<InstantiatedQuestion> item) {
  return item.map(instantiatedQuestionToJson).toList();
}

List<int> listIntFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(intFromJson).toList();
}

List<dynamic> listIntToJson(List<int> item) {
  return item.map(intToJson).toList();
}

List<QuestionHistory> listListBoolFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(listBoolFromJson).toList();
}

List<dynamic> listListBoolToJson(List<QuestionHistory> item) {
  return item.map(listBoolToJson).toList();
}

List<VarEntry> listVarEntryFromJson(dynamic json) {
  if (json == null) {
    return [];
  }
  return (json as List<dynamic>).map(varEntryFromJson).toList();
}

List<dynamic> listVarEntryToJson(List<VarEntry> item) {
  return item.map(varEntryToJson).toList();
}
