package game

import "encoding/json"

// Code generated by structgen/interfaces. DO NOT EDIT

// clientEventWrapper may be used as replacements for clientEvent
// when working with JSON
type clientEventWrapper struct {
	Data clientEvent
}

func (out *clientEventWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Data json.RawMessage
		Kind int
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case 0:
		var data answer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case 1:
		var data move
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case 2:
		var data Ping
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item clientEventWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind int
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case answer:
		wr = wrapper{Kind: 0, Data: data}
	case move:
		wr = wrapper{Kind: 1, Data: data}
	case Ping:
		wr = wrapper{Kind: 2, Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

// gameEventWrapper may be used as replacements for gameEvent
// when working with JSON
type gameEventWrapper struct {
	Data gameEvent
}

func (out *gameEventWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Data json.RawMessage
		Kind int
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case 0:
		var data diceThrow
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case 1:
		var data gameEnd
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case 2:
		var data gameStart
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case 3:
		var data move
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case 4:
		var data playerAnswerResult
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case 5:
		var data playerLeft
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case 6:
		var data playerTurn
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case 7:
		var data possibleMoves
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case 8:
		var data showQuestion
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item gameEventWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind int
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case diceThrow:
		wr = wrapper{Kind: 0, Data: data}
	case gameEnd:
		wr = wrapper{Kind: 1, Data: data}
	case gameStart:
		wr = wrapper{Kind: 2, Data: data}
	case move:
		wr = wrapper{Kind: 3, Data: data}
	case playerAnswerResult:
		wr = wrapper{Kind: 4, Data: data}
	case playerLeft:
		wr = wrapper{Kind: 5, Data: data}
	case playerTurn:
		wr = wrapper{Kind: 6, Data: data}
	case possibleMoves:
		wr = wrapper{Kind: 7, Data: data}
	case showQuestion:
		wr = wrapper{Kind: 8, Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}
