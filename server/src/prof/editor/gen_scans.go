package editor

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"

	"github.com/benoitkugler/maths-online/prof/teacher"
	"github.com/lib/pq"
)

	type scanner interface {
		Scan(...interface{}) error
	}
	
	// DB groups transaction like objects, and 
	// is implemented by *sql.DB and *sql.Tx
	type DB interface {
		Exec(query string, args ...interface{}) (sql.Result, error)
		Query(query string, args ...interface{}) (*sql.Rows, error)
		QueryRow(query string, args ...interface{}) *sql.Row 
		Prepare(query string) (*sql.Stmt, error)
	}
	

func scanOneExercice(row scanner) (Exercice, error) {
	var item Exercice
	err := row.Scan(
		&item.Id,
&item.Title,
&item.Description,
&item.Parameters,
&item.Flow,
&item.IdTeacher,
&item.Public,
	)
	return item, err
}

func ScanExercice(row *sql.Row) (Exercice, error) { return scanOneExercice(row) }

// SelectAll returns all the items in the exercices table.
func SelectAllExercices(db DB) (Exercices, error) {
	rows, err := db.Query("SELECT * FROM exercices")
	if err != nil {
		return nil, err
	}
	return ScanExercices(rows)
}

// SelectExercice returns the entry matching 'id'.
func SelectExercice(tx DB, id IdExercice) (Exercice, error) {
	row := tx.QueryRow("SELECT * FROM exercices WHERE id = $1", id)
	return ScanExercice(row)
}

// SelectExercices returns the entry matching the given 'ids'.
func SelectExercices(tx DB, ids ...IdExercice) (Exercices, error) {
	rows, err := tx.Query("SELECT * FROM exercices WHERE id = ANY($1)", IdExerciceArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanExercices(rows)
}

type Exercices map[IdExercice]Exercice

func (m Exercices) IDs() []IdExercice {
	out := make([]IdExercice, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanExercices(rs *sql.Rows) (Exercices, error) {
	var (
		s Exercice
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Exercices,  16)
	for rs.Next() {
		s, err = scanOneExercice(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Exercice in the database and returns the item with id filled.
func (item Exercice) Insert(tx DB) (out Exercice, err error) {
	row := tx.QueryRow(`INSERT INTO exercices (
		title, description, parameters, flow, idteacher, public
		) VALUES (
		$1, $2, $3, $4, $5, $6
		) RETURNING *;
		`,item.Title, item.Description, item.Parameters, item.Flow, item.IdTeacher, item.Public)
	return ScanExercice(row)
}

// Update Exercice in the database and returns the new version.
func (item Exercice) Update(tx DB) (out Exercice, err error) {
	row := tx.QueryRow(`UPDATE exercices SET (
		title, description, parameters, flow, idteacher, public
		) = (
		$1, $2, $3, $4, $5, $6
		) WHERE id = $7 RETURNING *;
		`,item.Title, item.Description, item.Parameters, item.Flow, item.IdTeacher, item.Public, item.Id)
	return ScanExercice(row)
}

// Deletes the Exercice and returns the item
func DeleteExerciceById(tx DB, id IdExercice) (Exercice, error) {
	row := tx.QueryRow("DELETE FROM exercices WHERE id = $1 RETURNING *;", id)
	return ScanExercice(row)
}

// Deletes the Exercice in the database and returns the ids.
func DeleteExercicesByIDs(tx DB, ids ...IdExercice) ([]IdExercice, error) {
	rows, err := tx.Query("DELETE FROM exercices WHERE id = ANY($1) RETURNING id", IdExerciceArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdExerciceArray(rows)
}	

		func SelectExercicesByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) (Exercices, error) {
			rows, err := tx.Query("SELECT * FROM exercices WHERE idteacher = ANY($1)", teacher.IdTeacherArrayToPQ(idTeachers))
			if err != nil {
				return nil, err
			}
			return ScanExercices(rows)
		}	

		func DeleteExercicesByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) ([]IdExercice, error) {
			rows, err := tx.Query("DELETE FROM exercices WHERE idteacher = ANY($1) RETURNING id", teacher.IdTeacherArrayToPQ(idTeachers))
			if err != nil {
				return nil, err
			}
			return ScanIdExerciceArray(rows)
		}	
		

	func scanOneExerciceQuestion(row scanner) (ExerciceQuestion, error) {
		var item ExerciceQuestion
		err := row.Scan(
			&item.IdExercice,
&item.IdQuestion,
&item.Bareme,
&item.Index,
		)
		return item, err
	}

	func ScanExerciceQuestion(row *sql.Row) (ExerciceQuestion, error) { return scanOneExerciceQuestion(row) }

	// SelectAll returns all the items in the exercice_questions table.
	func SelectAllExerciceQuestions(db DB) (ExerciceQuestions, error) {
		rows, err := db.Query("SELECT * FROM exercice_questions")
		if err != nil {
			return nil, err
		}
		return ScanExerciceQuestions(rows)
	}

	type ExerciceQuestions []ExerciceQuestion

	func ScanExerciceQuestions(rs *sql.Rows) (ExerciceQuestions , error) {
		var (
			item ExerciceQuestion
			err error
		)
		defer func() {
			errClose := rs.Close()
			if err == nil {
				err = errClose
			}
		}()
		structs := make(ExerciceQuestions , 0, 16)
		for rs.Next() {
			item, err = scanOneExerciceQuestion(rs)
			if err != nil {
				return nil, err
			}
			structs = append(structs, item)
		}
		if err = rs.Err(); err != nil {
			return nil, err
		}
		return structs, nil
	}

	// Insert the links ExerciceQuestion in the database.
	// It is a no-op if 'items' is empty.
	func InsertManyExerciceQuestions(tx *sql.Tx, items ...ExerciceQuestion) error {
		if len(items) == 0 {
			return nil
		}

		stmt, err := tx.Prepare(pq.CopyIn("exercice_questions", 
			"idexercice",
"idquestion",
"bareme",
"index",
		))
		if err != nil {
			return err
		}

		for _, item := range items {
			_, err = stmt.Exec(item.IdExercice, item.IdQuestion, item.Bareme, item.Index)
			if err != nil {
				return err
			}
		}

		if _, err = stmt.Exec(); err != nil {
			return err
		}
		
		if err = stmt.Close(); err != nil {
			return err
		}
		return nil
	}

	// Delete the link ExerciceQuestion from the database.
	// Only the foreign keys IdExercice, IdQuestion fields are used in 'item'.
	func (item ExerciceQuestion) Delete(tx DB) error {
		_, err := tx.Exec(`DELETE FROM exercice_questions WHERE IdExercice = $1 AND IdQuestion = $2;`, item.IdExercice, item.IdQuestion)
		return err
	}
	
				// ByIdExercice returns a map with 'IdExercice' as keys.
				func (items ExerciceQuestions) ByIdExercice() map[IdExercice]ExerciceQuestions {
					out := make(map[IdExercice]ExerciceQuestions)
					for _, target := range items {
						out[target.IdExercice] = append(out[target.IdExercice], target)
					}
					return out
				}	
				
			// IdExercices returns the list of ids of IdExercice
			// contained in this link table.
			// They are not garanteed to be distinct.
			func (items ExerciceQuestions) IdExercices() []IdExercice {
				out := make([]IdExercice, len(items))
				for index, target := range items {
					out[index] = target.IdExercice
				}
				return out
			}
			
		func SelectExerciceQuestionsByIdExercices(tx DB, idExercices ...IdExercice) (ExerciceQuestions, error) {
			rows, err := tx.Query("SELECT * FROM exercice_questions WHERE idexercice = ANY($1)", IdExerciceArrayToPQ(idExercices))
			if err != nil {
				return nil, err
			}
			return ScanExerciceQuestions(rows)
		}

		func DeleteExerciceQuestionsByIdExercices(tx DB, idExercices ...IdExercice) (ExerciceQuestions, error)  {
			rows, err := tx.Query("DELETE FROM exercice_questions WHERE idexercice = ANY($1) RETURNING *", IdExerciceArrayToPQ(idExercices))
			if err != nil {
				return nil, err
			}
			return ScanExerciceQuestions(rows)
		}	
		
				// ByIdQuestion returns a map with 'IdQuestion' as keys.
				func (items ExerciceQuestions) ByIdQuestion() map[IdQuestion]ExerciceQuestions {
					out := make(map[IdQuestion]ExerciceQuestions)
					for _, target := range items {
						out[target.IdQuestion] = append(out[target.IdQuestion], target)
					}
					return out
				}	
				
			// IdQuestions returns the list of ids of IdQuestion
			// contained in this link table.
			// They are not garanteed to be distinct.
			func (items ExerciceQuestions) IdQuestions() []IdQuestion {
				out := make([]IdQuestion, len(items))
				for index, target := range items {
					out[index] = target.IdQuestion
				}
				return out
			}
			
		func SelectExerciceQuestionsByIdQuestions(tx DB, idQuestions ...IdQuestion) (ExerciceQuestions, error) {
			rows, err := tx.Query("SELECT * FROM exercice_questions WHERE idquestion = ANY($1)", IdQuestionArrayToPQ(idQuestions))
			if err != nil {
				return nil, err
			}
			return ScanExerciceQuestions(rows)
		}

		func DeleteExerciceQuestionsByIdQuestions(tx DB, idQuestions ...IdQuestion) (ExerciceQuestions, error)  {
			rows, err := tx.Query("DELETE FROM exercice_questions WHERE idquestion = ANY($1) RETURNING *", IdQuestionArrayToPQ(idQuestions))
			if err != nil {
				return nil, err
			}
			return ScanExerciceQuestions(rows)
		}	
		

func scanOneProgression(row scanner) (Progression, error) {
	var item Progression
	err := row.Scan(
		&item.Id,
&item.IdExercice,
	)
	return item, err
}

func ScanProgression(row *sql.Row) (Progression, error) { return scanOneProgression(row) }

// SelectAll returns all the items in the progressions table.
func SelectAllProgressions(db DB) (Progressions, error) {
	rows, err := db.Query("SELECT * FROM progressions")
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

// SelectProgression returns the entry matching 'id'.
func SelectProgression(tx DB, id IdProgression) (Progression, error) {
	row := tx.QueryRow("SELECT * FROM progressions WHERE id = $1", id)
	return ScanProgression(row)
}

// SelectProgressions returns the entry matching the given 'ids'.
func SelectProgressions(tx DB, ids ...IdProgression) (Progressions, error) {
	rows, err := tx.Query("SELECT * FROM progressions WHERE id = ANY($1)", IdProgressionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

type Progressions map[IdProgression]Progression

func (m Progressions) IDs() []IdProgression {
	out := make([]IdProgression, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanProgressions(rs *sql.Rows) (Progressions, error) {
	var (
		s Progression
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Progressions,  16)
	for rs.Next() {
		s, err = scanOneProgression(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Progression in the database and returns the item with id filled.
func (item Progression) Insert(tx DB) (out Progression, err error) {
	row := tx.QueryRow(`INSERT INTO progressions (
		idexercice
		) VALUES (
		$1
		) RETURNING *;
		`,item.IdExercice)
	return ScanProgression(row)
}

// Update Progression in the database and returns the new version.
func (item Progression) Update(tx DB) (out Progression, err error) {
	row := tx.QueryRow(`UPDATE progressions SET (
		idexercice
		) = (
		$1
		) WHERE id = $2 RETURNING *;
		`,item.IdExercice, item.Id)
	return ScanProgression(row)
}

// Deletes the Progression and returns the item
func DeleteProgressionById(tx DB, id IdProgression) (Progression, error) {
	row := tx.QueryRow("DELETE FROM progressions WHERE id = $1 RETURNING *;", id)
	return ScanProgression(row)
}

// Deletes the Progression in the database and returns the ids.
func DeleteProgressionsByIDs(tx DB, ids ...IdProgression) ([]IdProgression, error) {
	rows, err := tx.Query("DELETE FROM progressions WHERE id = ANY($1) RETURNING id", IdProgressionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdProgressionArray(rows)
}	

		func SelectProgressionsByIdExercices(tx DB, idExercices ...IdExercice) (Progressions, error) {
			rows, err := tx.Query("SELECT * FROM progressions WHERE idexercice = ANY($1)", IdExerciceArrayToPQ(idExercices))
			if err != nil {
				return nil, err
			}
			return ScanProgressions(rows)
		}	

		func DeleteProgressionsByIdExercices(tx DB, idExercices ...IdExercice) ([]IdProgression, error) {
			rows, err := tx.Query("DELETE FROM progressions WHERE idexercice = ANY($1) RETURNING id", IdExerciceArrayToPQ(idExercices))
			if err != nil {
				return nil, err
			}
			return ScanIdProgressionArray(rows)
		}	
		

	func scanOneProgressionQuestion(row scanner) (ProgressionQuestion, error) {
		var item ProgressionQuestion
		err := row.Scan(
			&item.IdProgression,
&item.IdExercice,
&item.Index,
&item.History,
		)
		return item, err
	}

	func ScanProgressionQuestion(row *sql.Row) (ProgressionQuestion, error) { return scanOneProgressionQuestion(row) }

	// SelectAll returns all the items in the progression_questions table.
	func SelectAllProgressionQuestions(db DB) (ProgressionQuestions, error) {
		rows, err := db.Query("SELECT * FROM progression_questions")
		if err != nil {
			return nil, err
		}
		return ScanProgressionQuestions(rows)
	}

	type ProgressionQuestions []ProgressionQuestion

	func ScanProgressionQuestions(rs *sql.Rows) (ProgressionQuestions , error) {
		var (
			item ProgressionQuestion
			err error
		)
		defer func() {
			errClose := rs.Close()
			if err == nil {
				err = errClose
			}
		}()
		structs := make(ProgressionQuestions , 0, 16)
		for rs.Next() {
			item, err = scanOneProgressionQuestion(rs)
			if err != nil {
				return nil, err
			}
			structs = append(structs, item)
		}
		if err = rs.Err(); err != nil {
			return nil, err
		}
		return structs, nil
	}

	// Insert the links ProgressionQuestion in the database.
	// It is a no-op if 'items' is empty.
	func InsertManyProgressionQuestions(tx *sql.Tx, items ...ProgressionQuestion) error {
		if len(items) == 0 {
			return nil
		}

		stmt, err := tx.Prepare(pq.CopyIn("progression_questions", 
			"idprogression",
"idexercice",
"index",
"history",
		))
		if err != nil {
			return err
		}

		for _, item := range items {
			_, err = stmt.Exec(item.IdProgression, item.IdExercice, item.Index, item.History)
			if err != nil {
				return err
			}
		}

		if _, err = stmt.Exec(); err != nil {
			return err
		}
		
		if err = stmt.Close(); err != nil {
			return err
		}
		return nil
	}

	// Delete the link ProgressionQuestion from the database.
	// Only the foreign keys IdProgression, IdExercice fields are used in 'item'.
	func (item ProgressionQuestion) Delete(tx DB) error {
		_, err := tx.Exec(`DELETE FROM progression_questions WHERE IdProgression = $1 AND IdExercice = $2;`, item.IdProgression, item.IdExercice)
		return err
	}
	
				// ByIdProgression returns a map with 'IdProgression' as keys.
				func (items ProgressionQuestions) ByIdProgression() map[IdProgression]ProgressionQuestions {
					out := make(map[IdProgression]ProgressionQuestions)
					for _, target := range items {
						out[target.IdProgression] = append(out[target.IdProgression], target)
					}
					return out
				}	
				
			// IdProgressions returns the list of ids of IdProgression
			// contained in this link table.
			// They are not garanteed to be distinct.
			func (items ProgressionQuestions) IdProgressions() []IdProgression {
				out := make([]IdProgression, len(items))
				for index, target := range items {
					out[index] = target.IdProgression
				}
				return out
			}
			
		func SelectProgressionQuestionsByIdProgressions(tx DB, idProgressions ...IdProgression) (ProgressionQuestions, error) {
			rows, err := tx.Query("SELECT * FROM progression_questions WHERE idprogression = ANY($1)", IdProgressionArrayToPQ(idProgressions))
			if err != nil {
				return nil, err
			}
			return ScanProgressionQuestions(rows)
		}

		func DeleteProgressionQuestionsByIdProgressions(tx DB, idProgressions ...IdProgression) (ProgressionQuestions, error)  {
			rows, err := tx.Query("DELETE FROM progression_questions WHERE idprogression = ANY($1) RETURNING *", IdProgressionArrayToPQ(idProgressions))
			if err != nil {
				return nil, err
			}
			return ScanProgressionQuestions(rows)
		}	
		
				// ByIdExercice returns a map with 'IdExercice' as keys.
				func (items ProgressionQuestions) ByIdExercice() map[IdExercice]ProgressionQuestions {
					out := make(map[IdExercice]ProgressionQuestions)
					for _, target := range items {
						out[target.IdExercice] = append(out[target.IdExercice], target)
					}
					return out
				}	
				
			// IdExercices returns the list of ids of IdExercice
			// contained in this link table.
			// They are not garanteed to be distinct.
			func (items ProgressionQuestions) IdExercices() []IdExercice {
				out := make([]IdExercice, len(items))
				for index, target := range items {
					out[index] = target.IdExercice
				}
				return out
			}
			
		func SelectProgressionQuestionsByIdExercices(tx DB, idExercices ...IdExercice) (ProgressionQuestions, error) {
			rows, err := tx.Query("SELECT * FROM progression_questions WHERE idexercice = ANY($1)", IdExerciceArrayToPQ(idExercices))
			if err != nil {
				return nil, err
			}
			return ScanProgressionQuestions(rows)
		}

		func DeleteProgressionQuestionsByIdExercices(tx DB, idExercices ...IdExercice) (ProgressionQuestions, error)  {
			rows, err := tx.Query("DELETE FROM progression_questions WHERE idexercice = ANY($1) RETURNING *", IdExerciceArrayToPQ(idExercices))
			if err != nil {
				return nil, err
			}
			return ScanProgressionQuestions(rows)
		}	
		

func scanOneQuestion(row scanner) (Question, error) {
	var item Question
	err := row.Scan(
		&item.Id,
&item.Page,
&item.Public,
&item.IdTeacher,
&item.Description,
&item.NeedExercice,
	)
	return item, err
}

func ScanQuestion(row *sql.Row) (Question, error) { return scanOneQuestion(row) }

// SelectAll returns all the items in the questions table.
func SelectAllQuestions(db DB) (Questions, error) {
	rows, err := db.Query("SELECT * FROM questions")
	if err != nil {
		return nil, err
	}
	return ScanQuestions(rows)
}

// SelectQuestion returns the entry matching 'id'.
func SelectQuestion(tx DB, id IdQuestion) (Question, error) {
	row := tx.QueryRow("SELECT * FROM questions WHERE id = $1", id)
	return ScanQuestion(row)
}

// SelectQuestions returns the entry matching the given 'ids'.
func SelectQuestions(tx DB, ids ...IdQuestion) (Questions, error) {
	rows, err := tx.Query("SELECT * FROM questions WHERE id = ANY($1)", IdQuestionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanQuestions(rows)
}

type Questions map[IdQuestion]Question

func (m Questions) IDs() []IdQuestion {
	out := make([]IdQuestion, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanQuestions(rs *sql.Rows) (Questions, error) {
	var (
		s Question
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Questions,  16)
	for rs.Next() {
		s, err = scanOneQuestion(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Question in the database and returns the item with id filled.
func (item Question) Insert(tx DB) (out Question, err error) {
	row := tx.QueryRow(`INSERT INTO questions (
		page, public, idteacher, description, needexercice
		) VALUES (
		$1, $2, $3, $4, $5
		) RETURNING *;
		`,item.Page, item.Public, item.IdTeacher, item.Description, item.NeedExercice)
	return ScanQuestion(row)
}

// Update Question in the database and returns the new version.
func (item Question) Update(tx DB) (out Question, err error) {
	row := tx.QueryRow(`UPDATE questions SET (
		page, public, idteacher, description, needexercice
		) = (
		$1, $2, $3, $4, $5
		) WHERE id = $6 RETURNING *;
		`,item.Page, item.Public, item.IdTeacher, item.Description, item.NeedExercice, item.Id)
	return ScanQuestion(row)
}

// Deletes the Question and returns the item
func DeleteQuestionById(tx DB, id IdQuestion) (Question, error) {
	row := tx.QueryRow("DELETE FROM questions WHERE id = $1 RETURNING *;", id)
	return ScanQuestion(row)
}

// Deletes the Question in the database and returns the ids.
func DeleteQuestionsByIDs(tx DB, ids ...IdQuestion) ([]IdQuestion, error) {
	rows, err := tx.Query("DELETE FROM questions WHERE id = ANY($1) RETURNING id", IdQuestionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdQuestionArray(rows)
}	

		func SelectQuestionsByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) (Questions, error) {
			rows, err := tx.Query("SELECT * FROM questions WHERE idteacher = ANY($1)", teacher.IdTeacherArrayToPQ(idTeachers))
			if err != nil {
				return nil, err
			}
			return ScanQuestions(rows)
		}	

		func DeleteQuestionsByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) ([]IdQuestion, error) {
			rows, err := tx.Query("DELETE FROM questions WHERE idteacher = ANY($1) RETURNING id", teacher.IdTeacherArrayToPQ(idTeachers))
			if err != nil {
				return nil, err
			}
			return ScanIdQuestionArray(rows)
		}	
		
		func SelectQuestionsByNeedExercices(tx DB, needExercices ...int64) (Questions, error) {
			rows, err := tx.Query("SELECT * FROM questions WHERE needexercice = ANY($1)", int64ArrayToPQ(needExercices))
			if err != nil {
				return nil, err
			}
			return ScanQuestions(rows)
		}	

		func DeleteQuestionsByNeedExercices(tx DB, needExercices ...int64) ([]IdQuestion, error) {
			rows, err := tx.Query("DELETE FROM questions WHERE needexercice = ANY($1) RETURNING id", int64ArrayToPQ(needExercices))
			if err != nil {
				return nil, err
			}
			return ScanIdQuestionArray(rows)
		}	
		

	func scanOneQuestionTag(row scanner) (QuestionTag, error) {
		var item QuestionTag
		err := row.Scan(
			&item.Tag,
&item.IdQuestion,
		)
		return item, err
	}

	func ScanQuestionTag(row *sql.Row) (QuestionTag, error) { return scanOneQuestionTag(row) }

	// SelectAll returns all the items in the question_tags table.
	func SelectAllQuestionTags(db DB) (QuestionTags, error) {
		rows, err := db.Query("SELECT * FROM question_tags")
		if err != nil {
			return nil, err
		}
		return ScanQuestionTags(rows)
	}

	type QuestionTags []QuestionTag

	func ScanQuestionTags(rs *sql.Rows) (QuestionTags , error) {
		var (
			item QuestionTag
			err error
		)
		defer func() {
			errClose := rs.Close()
			if err == nil {
				err = errClose
			}
		}()
		structs := make(QuestionTags , 0, 16)
		for rs.Next() {
			item, err = scanOneQuestionTag(rs)
			if err != nil {
				return nil, err
			}
			structs = append(structs, item)
		}
		if err = rs.Err(); err != nil {
			return nil, err
		}
		return structs, nil
	}

	// Insert the links QuestionTag in the database.
	// It is a no-op if 'items' is empty.
	func InsertManyQuestionTags(tx *sql.Tx, items ...QuestionTag) error {
		if len(items) == 0 {
			return nil
		}

		stmt, err := tx.Prepare(pq.CopyIn("question_tags", 
			"tag",
"idquestion",
		))
		if err != nil {
			return err
		}

		for _, item := range items {
			_, err = stmt.Exec(item.Tag, item.IdQuestion)
			if err != nil {
				return err
			}
		}

		if _, err = stmt.Exec(); err != nil {
			return err
		}
		
		if err = stmt.Close(); err != nil {
			return err
		}
		return nil
	}

	// Delete the link QuestionTag from the database.
	// Only the foreign keys IdQuestion fields are used in 'item'.
	func (item QuestionTag) Delete(tx DB) error {
		_, err := tx.Exec(`DELETE FROM question_tags WHERE IdQuestion = $1;`, item.IdQuestion)
		return err
	}
	
				// ByIdQuestion returns a map with 'IdQuestion' as keys.
				func (items QuestionTags) ByIdQuestion() map[IdQuestion]QuestionTags {
					out := make(map[IdQuestion]QuestionTags)
					for _, target := range items {
						out[target.IdQuestion] = append(out[target.IdQuestion], target)
					}
					return out
				}	
				
			// IdQuestions returns the list of ids of IdQuestion
			// contained in this link table.
			// They are not garanteed to be distinct.
			func (items QuestionTags) IdQuestions() []IdQuestion {
				out := make([]IdQuestion, len(items))
				for index, target := range items {
					out[index] = target.IdQuestion
				}
				return out
			}
			
		func SelectQuestionTagsByIdQuestions(tx DB, idQuestions ...IdQuestion) (QuestionTags, error) {
			rows, err := tx.Query("SELECT * FROM question_tags WHERE idquestion = ANY($1)", IdQuestionArrayToPQ(idQuestions))
			if err != nil {
				return nil, err
			}
			return ScanQuestionTags(rows)
		}

		func DeleteQuestionTagsByIdQuestions(tx DB, idQuestions ...IdQuestion) (QuestionTags, error)  {
			rows, err := tx.Query("DELETE FROM question_tags WHERE idquestion = ANY($1) RETURNING *", IdQuestionArrayToPQ(idQuestions))
			if err != nil {
				return nil, err
			}
			return ScanQuestionTags(rows)
		}	
		

						func (s *QuestionHistory) Scan(src interface{}) error  { return (*pq.BoolArray)(s).Scan(src) }
						func (s QuestionHistory) Value() (driver.Value, error) { return pq.BoolArray(s).Value() }
						

		func IdExerciceArrayToPQ(ids []IdExercice) pq.Int64Array {
			out := make(pq.Int64Array, len(ids))
			for i, v := range ids {
				out[i] = int64(v)
			}
			return out
		}
		
	// ScanIdExerciceArray scans the result of a query returning a
	// list of ID's.
	func ScanIdExerciceArray(rs *sql.Rows) ([]IdExercice, error) {
		defer rs.Close()
		ints := make([]IdExercice, 0, 16)
		var err error
		for rs.Next() {
			var s IdExercice
			if err = rs.Scan(&s); err != nil {
				return nil, err
			}
			ints = append(ints, s)
		}
		if err = rs.Err(); err != nil {
			return nil, err
		}
		return ints, nil
	}
	
	type IdExerciceSet map[IdExercice]bool 

	func NewIdExerciceSetFrom(ids []IdExercice) IdExerciceSet { 
		out := make(IdExerciceSet, len(ids))
		for _, key := range ids {
			out[key] = true
		}
		return out
	}

	func (s IdExerciceSet) Add(id IdExercice) { s[id] = true }

	func (s IdExerciceSet) Has(id IdExercice) bool { return s[id] }

	func (s IdExerciceSet) Keys() []IdExercice {
		out := make([]IdExercice, 0, len(s))
		for k := range s {
			out = append(out, k)
		}
		return out
	}
	

		func IdProgressionArrayToPQ(ids []IdProgression) pq.Int64Array {
			out := make(pq.Int64Array, len(ids))
			for i, v := range ids {
				out[i] = int64(v)
			}
			return out
		}
		
	// ScanIdProgressionArray scans the result of a query returning a
	// list of ID's.
	func ScanIdProgressionArray(rs *sql.Rows) ([]IdProgression, error) {
		defer rs.Close()
		ints := make([]IdProgression, 0, 16)
		var err error
		for rs.Next() {
			var s IdProgression
			if err = rs.Scan(&s); err != nil {
				return nil, err
			}
			ints = append(ints, s)
		}
		if err = rs.Err(); err != nil {
			return nil, err
		}
		return ints, nil
	}
	
	type IdProgressionSet map[IdProgression]bool 

	func NewIdProgressionSetFrom(ids []IdProgression) IdProgressionSet { 
		out := make(IdProgressionSet, len(ids))
		for _, key := range ids {
			out[key] = true
		}
		return out
	}

	func (s IdProgressionSet) Add(id IdProgression) { s[id] = true }

	func (s IdProgressionSet) Has(id IdProgression) bool { return s[id] }

	func (s IdProgressionSet) Keys() []IdProgression {
		out := make([]IdProgression, 0, len(s))
		for k := range s {
			out = append(out, k)
		}
		return out
	}
	

		func IdQuestionArrayToPQ(ids []IdQuestion) pq.Int64Array {
			out := make(pq.Int64Array, len(ids))
			for i, v := range ids {
				out[i] = int64(v)
			}
			return out
		}
		
	// ScanIdQuestionArray scans the result of a query returning a
	// list of ID's.
	func ScanIdQuestionArray(rs *sql.Rows) ([]IdQuestion, error) {
		defer rs.Close()
		ints := make([]IdQuestion, 0, 16)
		var err error
		for rs.Next() {
			var s IdQuestion
			if err = rs.Scan(&s); err != nil {
				return nil, err
			}
			ints = append(ints, s)
		}
		if err = rs.Err(); err != nil {
			return nil, err
		}
		return ints, nil
	}
	
	type IdQuestionSet map[IdQuestion]bool 

	func NewIdQuestionSetFrom(ids []IdQuestion) IdQuestionSet { 
		out := make(IdQuestionSet, len(ids))
		for _, key := range ids {
			out[key] = true
		}
		return out
	}

	func (s IdQuestionSet) Add(id IdQuestion) { s[id] = true }

	func (s IdQuestionSet) Has(id IdQuestion) bool { return s[id] }

	func (s IdQuestionSet) Keys() []IdQuestion {
		out := make([]IdQuestion, 0, len(s))
		for k := range s {
			out = append(out, k)
		}
		return out
	}
	

		func int64ArrayToPQ(ids []int64) pq.Int64Array { return ids }
		
	// Scanint64Array scans the result of a query returning a
	// list of ID's.
	func Scanint64Array(rs *sql.Rows) ([]int64, error) {
		defer rs.Close()
		ints := make([]int64, 0, 16)
		var err error
		for rs.Next() {
			var s int64
			if err = rs.Scan(&s); err != nil {
				return nil, err
			}
			ints = append(ints, s)
		}
		if err = rs.Err(); err != nil {
			return nil, err
		}
		return ints, nil
	}
	
	type int64Set map[int64]bool 

	func Newint64SetFrom(ids []int64) int64Set { 
		out := make(int64Set, len(ids))
		for _, key := range ids {
			out[key] = true
		}
		return out
	}

	func (s int64Set) Add(id int64) { s[id] = true }

	func (s int64Set) Has(id int64) bool { return s[id] }

	func (s int64Set) Keys() []int64 {
		out := make([]int64, 0, len(s))
		for k := range s {
			out = append(out, k)
		}
		return out
	}
	
