package editor

// Code generated by structgen. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"

	"github.com/lib/pq"
)

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

// Set is a set of IDs.
type Set map[int64]bool

func NewSet() Set {
	return map[int64]bool{}
}

// NewSetFromSlice returns a set of unique IDs
func NewSetFromSlice(keys []int64) Set {
	out := make(Set, len(keys))
	for _, key := range keys {
		out[key] = true
	}
	return out
}

// Keys return the IDs contained in the set, as a slice.
func (s Set) Keys() []int64 {
	out := make([]int64, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s Set) Has(key int64) bool {
	_, has := s[key]
	return has
}

func (s Set) Add(key int64) {
	s[key] = true
}

type IDs []int64

func (ids IDs) AsSQL() pq.Int64Array {
	return pq.Int64Array(ids)
}

func (ids IDs) AsSet() Set {
	return NewSetFromSlice(ids)
}

// ScanIDs scans the result of a query returning a
// list of IDs.
func ScanIDs(rs *sql.Rows) (IDs, error) {
	defer rs.Close()
	ints := make(IDs, 0, 16)
	var err error
	for rs.Next() {
		var s int64
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneTeacherQuestion(row scanner) (TeacherQuestion, error) {
	var s TeacherQuestion
	err := row.Scan(
		&s.IdTeacher,
		&s.IdQuestion,
		&s.IsPublic,
	)
	return s, err
}

func ScanTeacherQuestion(row *sql.Row) (TeacherQuestion, error) {
	return scanOneTeacherQuestion(row)
}

func SelectAllTeacherQuestions(tx DB) (TeacherQuestions, error) {
	rows, err := tx.Query("SELECT * FROM teacher_questions")
	if err != nil {
		return nil, err
	}
	return ScanTeacherQuestions(rows)
}

type TeacherQuestions []TeacherQuestion

func ScanTeacherQuestions(rs *sql.Rows) (TeacherQuestions, error) {
	var (
		s   TeacherQuestion
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(TeacherQuestions, 0, 16)
	for rs.Next() {
		s, err = scanOneTeacherQuestion(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links TeacherQuestion in the database.
func InsertManyTeacherQuestions(tx *sql.Tx, items ...TeacherQuestion) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("teacher_questions",
		"id_teacher", "id_question", "is_public",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdTeacher, item.IdQuestion, item.IsPublic)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link TeacherQuestion in the database.
// Only the 'IdTeacher' 'IdQuestion' fields are used.
func (item TeacherQuestion) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM teacher_questions WHERE 
	id_teacher = $1 AND id_question = $2;`, item.IdTeacher, item.IdQuestion)
	return err
}

func SelectTeacherQuestionsByIdTeachers(tx DB, idTeachers ...int64) (TeacherQuestions, error) {
	rows, err := tx.Query("SELECT * FROM teacher_questions WHERE id_teacher = ANY($1)", pq.Int64Array(idTeachers))
	if err != nil {
		return nil, err
	}
	return ScanTeacherQuestions(rows)
}

func DeleteTeacherQuestionsByIdTeachers(tx DB, idTeachers ...int64) (TeacherQuestions, error) {
	rows, err := tx.Query("DELETE FROM teacher_questions WHERE id_teacher = ANY($1) RETURNING *", pq.Int64Array(idTeachers))
	if err != nil {
		return nil, err
	}
	return ScanTeacherQuestions(rows)
}

// SelectTeacherQuestionByIdQuestion return zero or one item, thanks to a UNIQUE constraint
func SelectTeacherQuestionByIdQuestion(tx DB, idQuestion int64) (item TeacherQuestion, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM teacher_questions WHERE id_question = $1", idQuestion)
	item, err = ScanTeacherQuestion(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectTeacherQuestionsByIdQuestions(tx DB, idQuestions ...int64) (TeacherQuestions, error) {
	rows, err := tx.Query("SELECT * FROM teacher_questions WHERE id_question = ANY($1)", pq.Int64Array(idQuestions))
	if err != nil {
		return nil, err
	}
	return ScanTeacherQuestions(rows)
}

func DeleteTeacherQuestionsByIdQuestions(tx DB, idQuestions ...int64) (TeacherQuestions, error) {
	rows, err := tx.Query("DELETE FROM teacher_questions WHERE id_question = ANY($1) RETURNING *", pq.Int64Array(idQuestions))
	if err != nil {
		return nil, err
	}
	return ScanTeacherQuestions(rows)
}

// ByIdTeacher returns a map with 'IdTeacher' as keys.
func (items TeacherQuestions) ByIdTeacher() map[int64]TeacherQuestions {
	out := make(map[int64]TeacherQuestions)
	for _, target := range items {
		out[target.IdTeacher] = append(out[target.IdTeacher], target)
	}
	return out
}

// ByIdQuestion returns a map with 'IdQuestion' as keys.
func (items TeacherQuestions) ByIdQuestion() map[int64]TeacherQuestion {
	out := make(map[int64]TeacherQuestion, len(items))
	for _, target := range items {
		out[target.IdQuestion] = target
	}
	return out
}
