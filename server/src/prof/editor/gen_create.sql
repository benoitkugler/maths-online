-- DO NOT EDIT - autogenerated by structgen
CREATE OR REPLACE FUNCTION structgen_validate_json_string (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean := jsonb_typeof(data) = 'string';
BEGIN
    IF NOT is_valid THEN
        RAISE WARNING '% is not a string', data;
    END IF;
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_number (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean := jsonb_typeof(data) = 'number';
BEGIN
    IF NOT is_valid THEN
        RAISE WARNING '% is not a number', data;
    END IF;
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_exp_Variable (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Indice', 'Name'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Indice')
        AND structgen_validate_json_number (data -> 'Name');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_RandomParameter (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('expression', 'variable'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'expression')
        AND structgen_validate_json_exp_Variable (data -> 'variable');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_que_RandomParameter (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_que_RandomParameter (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_string (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_string (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_Parameters (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Variables', 'Intrinsics'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_array_que_RandomParameter (data -> 'Variables')
        AND structgen_validate_json_array_string (data -> 'Intrinsics');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE TABLE exercices (
    Id serial PRIMARY KEY,
    Title varchar NOT NULL,
    Description varchar NOT NULL,
    Parameters jsonb NOT NULL CONSTRAINT Parameters_structgen_validate_json_que_Parameters CHECK (structgen_validate_json_que_Parameters (Parameters)),
    Flow integer CHECK (Flow IN (0, 1)) NOT NULL,
    id_teacher integer NOT NULL,
    Public boolean NOT NULL
);

CREATE TABLE exercice_questions (
    id_exercice integer NOT NULL,
    id_question integer NOT NULL,
    bareme integer NOT NULL
);

CREATE OR REPLACE FUNCTION structgen_validate_json_TextKind (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean := jsonb_typeof(data) = 'number'
    AND data::int IN (2, 1, 0);
BEGIN
    IF NOT is_valid THEN
        RAISE WARNING '% is not a TextKind', data;
    END IF;
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_TextPart (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Content', 'Kind'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Content')
        AND structgen_validate_json_TextKind (data -> 'Kind');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_ComparisonLevel (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean := jsonb_typeof(data) = 'number'
    AND data::int IN (2, 1, 0);
BEGIN
    IF NOT is_valid THEN
        RAISE WARNING '% is not a ComparisonLevel', data;
    END IF;
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_ExpressionFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Expression', 'Label', 'ComparisonLevel'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Expression')
        AND structgen_validate_json_que_TextPart (data -> 'Label')
        AND structgen_validate_json_ComparisonLevel (data -> 'ComparisonLevel');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_rep_RandomCoord (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('X', 'Y'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'X')
        AND structgen_validate_json_string (data -> 'Y');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_LabelPos (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean := jsonb_typeof(data) = 'number'
    AND data::int IN (1, 7, 6, 8, 2, 3, 0, 4, 5);
BEGIN
    IF NOT is_valid THEN
        RAISE WARNING '% is not a LabelPos', data;
    END IF;
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_rep_RandomLabeledPoint (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Color', 'Coord', 'Pos'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Color')
        AND structgen_validate_json_rep_RandomCoord (data -> 'Coord')
        AND structgen_validate_json_LabelPos (data -> 'Pos');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_rep_NamedRandomLabeledPoint (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Name', 'Point'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Name')
        AND structgen_validate_json_rep_RandomLabeledPoint (data -> 'Point');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_rep_NamedRandomLabeledPoint (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_rep_NamedRandomLabeledPoint (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_SegmentKind (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean := jsonb_typeof(data) = 'number'
    AND data::int IN (2, 0, 1);
BEGIN
    IF NOT is_valid THEN
        RAISE WARNING '% is not a SegmentKind', data;
    END IF;
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_rep_Segment (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('LabelName', 'From', 'To', 'Color', 'LabelPos', 'Kind'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'LabelName')
        AND structgen_validate_json_string (data -> 'From')
        AND structgen_validate_json_string (data -> 'To')
        AND structgen_validate_json_string (data -> 'Color')
        AND structgen_validate_json_LabelPos (data -> 'LabelPos')
        AND structgen_validate_json_SegmentKind (data -> 'Kind');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_rep_Segment (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_rep_Segment (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_rep_RandomLine (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Label', 'A', 'B', 'Color'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Label')
        AND structgen_validate_json_string (data -> 'A')
        AND structgen_validate_json_string (data -> 'B')
        AND structgen_validate_json_string (data -> 'Color');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_rep_RandomLine (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_rep_RandomLine (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_rep_RandomDrawings (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Points', 'Segments', 'Lines'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_array_rep_NamedRandomLabeledPoint (data -> 'Points')
        AND structgen_validate_json_array_rep_Segment (data -> 'Segments')
        AND structgen_validate_json_array_rep_RandomLine (data -> 'Lines');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_rep_Coord (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('X', 'Y'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_number (data -> 'X')
        AND structgen_validate_json_number (data -> 'Y');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_rep_RepereBounds (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Width', 'Height', 'Origin'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_number (data -> 'Width')
        AND structgen_validate_json_number (data -> 'Height')
        AND structgen_validate_json_rep_Coord (data -> 'Origin');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_boolean (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean := jsonb_typeof(data) = 'boolean';
BEGIN
    IF NOT is_valid THEN
        RAISE WARNING '% is not a boolean', data;
    END IF;
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_FigureBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Drawings', 'Bounds', 'ShowGrid'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_rep_RandomDrawings (data -> 'Drawings')
        AND structgen_validate_json_rep_RepereBounds (data -> 'Bounds')
        AND structgen_validate_json_boolean (data -> 'ShowGrid');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_FigureAffineLineFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Label', 'A', 'B', 'Figure'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Label')
        AND structgen_validate_json_string (data -> 'A')
        AND structgen_validate_json_string (data -> 'B')
        AND structgen_validate_json_que_FigureBlock (data -> 'Figure');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_CoordExpression (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('X', 'Y'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'X')
        AND structgen_validate_json_string (data -> 'Y');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_FigurePointFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Answer', 'Figure'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_que_CoordExpression (data -> 'Answer')
        AND structgen_validate_json_que_FigureBlock (data -> 'Figure');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_FigureVectorFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Answer', 'AnswerOrigin', 'Figure', 'MustHaveOrigin'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_que_CoordExpression (data -> 'Answer')
        AND structgen_validate_json_que_CoordExpression (data -> 'AnswerOrigin')
        AND structgen_validate_json_que_FigureBlock (data -> 'Figure')
        AND structgen_validate_json_boolean (data -> 'MustHaveOrigin');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_VectorPairCriterion (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean := jsonb_typeof(data) = 'number'
    AND data::int IN (1, 0, 2);
BEGIN
    IF NOT is_valid THEN
        RAISE WARNING '% is not a VectorPairCriterion', data;
    END IF;
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_FigureVectorPairFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Figure', 'Criterion'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_que_FigureBlock (data -> 'Figure')
        AND structgen_validate_json_VectorPairCriterion (data -> 'Criterion');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_FormulaBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Parts'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Parts');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_fun_FunctionDecoration (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Label', 'Color'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Label')
        AND structgen_validate_json_string (data -> 'Color');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_FunctionDefinition (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Function', 'Decoration', 'Variable', 'From', 'To'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Function')
        AND structgen_validate_json_fun_FunctionDecoration (data -> 'Decoration')
        AND structgen_validate_json_exp_Variable (data -> 'Variable')
        AND structgen_validate_json_string (data -> 'From')
        AND structgen_validate_json_string (data -> 'To');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_que_FunctionDefinition (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_que_FunctionDefinition (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_FunctionGraphBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Functions'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_array_que_FunctionDefinition (data -> 'Functions');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_FunctionPointsFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Function', 'Label', 'Variable', 'XGrid'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Function')
        AND structgen_validate_json_string (data -> 'Label')
        AND structgen_validate_json_exp_Variable (data -> 'Variable')
        AND structgen_validate_json_array_string (data -> 'XGrid');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_FunctionVariationGraphBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Label', 'Xs', 'Fxs'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Label')
        AND structgen_validate_json_array_string (data -> 'Xs')
        AND structgen_validate_json_array_string (data -> 'Fxs');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_NumberFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Expression'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Expression');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_OrderedListFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Label', 'Answer', 'AdditionalProposals'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Label')
        AND structgen_validate_json_array_string (data -> 'Answer')
        AND structgen_validate_json_array_string (data -> 'AdditionalProposals');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_RadioFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Answer', 'Proposals', 'AsDropDown'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Answer')
        AND structgen_validate_json_array_string (data -> 'Proposals')
        AND structgen_validate_json_boolean (data -> 'AsDropDown');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_SignSymbol (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean := jsonb_typeof(data) = 'number'
    AND data::int IN (2, 0, 1);
BEGIN
    IF NOT is_valid THEN
        RAISE WARNING '% is not a SignSymbol', data;
    END IF;
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_SignSymbol (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_SignSymbol (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_boolean (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_boolean (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_SignTableBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Label', 'FxSymbols', 'Xs', 'Signs'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Label')
        AND structgen_validate_json_array_SignSymbol (data -> 'FxSymbols')
        AND structgen_validate_json_array_string (data -> 'Xs')
        AND structgen_validate_json_array_boolean (data -> 'Signs');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_que_TextPart (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_que_TextPart (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_array_que_TextPart (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_array_que_TextPart (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_TableBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('HorizontalHeaders', 'VerticalHeaders', 'Values'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_array_que_TextPart (data -> 'HorizontalHeaders')
        AND structgen_validate_json_array_que_TextPart (data -> 'VerticalHeaders')
        AND structgen_validate_json_array_array_que_TextPart (data -> 'Values');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_array_string (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_array_string (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_TableFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('HorizontalHeaders', 'VerticalHeaders', 'Answer'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_array_que_TextPart (data -> 'HorizontalHeaders')
        AND structgen_validate_json_array_que_TextPart (data -> 'VerticalHeaders')
        AND structgen_validate_json_array_array_string (data -> 'Answer');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_TextBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Parts', 'Bold', 'Italic', 'Smaller'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Parts')
        AND structgen_validate_json_boolean (data -> 'Bold')
        AND structgen_validate_json_boolean (data -> 'Italic')
        AND structgen_validate_json_boolean (data -> 'Smaller');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_que_TreeNodeAnswer (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_que_TreeNodeAnswer (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_TreeNodeAnswer (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Children', 'Probabilities', 'Value'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_array_que_TreeNodeAnswer (data -> 'Children')
        AND structgen_validate_json_array_string (data -> 'Probabilities')
        AND structgen_validate_json_number (data -> 'Value');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_TreeFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('EventsProposals', 'AnswerRoot'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_array_string (data -> 'EventsProposals')
        AND structgen_validate_json_que_TreeNodeAnswer (data -> 'AnswerRoot');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_VariationTableBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Label', 'Xs', 'Fxs'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'Label')
        AND structgen_validate_json_array_string (data -> 'Xs')
        AND structgen_validate_json_array_string (data -> 'Fxs');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_VariationTableFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Answer'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_que_VariationTableBlock (data -> 'Answer');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_VectorFieldBlock (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('Answer', 'AcceptColinear', 'DisplayColumn'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_que_CoordExpression (data -> 'Answer')
        AND structgen_validate_json_boolean (data -> 'AcceptColinear')
        AND structgen_validate_json_boolean (data -> 'DisplayColumn');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_Block (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) != 'object' OR jsonb_typeof(data -> 'Kind') != 'number' OR jsonb_typeof(data -> 'Data') = 'null' THEN
        RETURN FALSE;
    END IF;
    CASE WHEN (data -> 'Kind')::int = 0 THEN
        RETURN structgen_validate_json_que_ExpressionFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 1 THEN
        RETURN structgen_validate_json_que_FigureAffineLineFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 2 THEN
        RETURN structgen_validate_json_que_FigureBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 3 THEN
        RETURN structgen_validate_json_que_FigurePointFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 4 THEN
        RETURN structgen_validate_json_que_FigureVectorFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 5 THEN
        RETURN structgen_validate_json_que_FigureVectorPairFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 6 THEN
        RETURN structgen_validate_json_que_FormulaBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 7 THEN
        RETURN structgen_validate_json_que_FunctionGraphBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 8 THEN
        RETURN structgen_validate_json_que_FunctionPointsFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 9 THEN
        RETURN structgen_validate_json_que_FunctionVariationGraphBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 10 THEN
        RETURN structgen_validate_json_que_NumberFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 11 THEN
        RETURN structgen_validate_json_que_OrderedListFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 12 THEN
        RETURN structgen_validate_json_que_RadioFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 13 THEN
        RETURN structgen_validate_json_que_SignTableBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 14 THEN
        RETURN structgen_validate_json_que_TableBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 15 THEN
        RETURN structgen_validate_json_que_TableFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 16 THEN
        RETURN structgen_validate_json_que_TextBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 17 THEN
        RETURN structgen_validate_json_que_TreeFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 18 THEN
        RETURN structgen_validate_json_que_VariationTableBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 19 THEN
        RETURN structgen_validate_json_que_VariationTableFieldBlock (data -> 'Data');
    WHEN (data -> 'Kind')::int = 20 THEN
        RETURN structgen_validate_json_que_VectorFieldBlock (data -> 'Data');
    ELSE
        RETURN FALSE;
    END CASE;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_array_que_Block (data jsonb)
    RETURNS boolean
    AS $$
BEGIN
    IF jsonb_typeof(data) = 'null' THEN
        RETURN TRUE;
    END IF;
    IF jsonb_typeof(data) != 'array' THEN
        RETURN FALSE;
    END IF;
    IF jsonb_array_length(data) = 0 THEN
        RETURN TRUE;
    END IF;
    RETURN (
        SELECT
            bool_and(structgen_validate_json_que_Block (value))
        FROM
            jsonb_array_elements(data));
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE OR REPLACE FUNCTION structgen_validate_json_que_QuestionPage (data jsonb)
    RETURNS boolean
    AS $$
DECLARE
    is_valid boolean;
BEGIN
    IF jsonb_typeof(data) != 'object' THEN
        RETURN FALSE;
    END IF;
    is_valid := (
        SELECT
            bool_and(key IN ('title', 'enonce', 'parameters'))
        FROM
            jsonb_each(data))
        AND structgen_validate_json_string (data -> 'title')
        AND structgen_validate_json_array_que_Block (data -> 'enonce')
        AND structgen_validate_json_que_Parameters (data -> 'parameters');
    RETURN is_valid;
END;
$$
LANGUAGE 'plpgsql'
IMMUTABLE;

CREATE TABLE questions (
    id serial PRIMARY KEY,
    page jsonb NOT NULL CONSTRAINT page_structgen_validate_json_que_QuestionPage CHECK (structgen_validate_json_que_QuestionPage (page)),
    public boolean NOT NULL,
    id_teacher integer NOT NULL,
    description varchar NOT NULL,
    need_exercice boolean NOT NULL
);

CREATE TABLE question_tags (
    tag varchar NOT NULL,
    id_question integer NOT NULL
);

ALTER TABLE exercices
    ADD FOREIGN KEY (id_teacher) REFERENCES teachers;

ALTER TABLE exercice_questions
    ADD FOREIGN KEY (id_exercice) REFERENCES exercices ON DELETE CASCADE;

ALTER TABLE exercice_questions
    ADD FOREIGN KEY (id_question) REFERENCES questions;

ALTER TABLE questions
    ADD FOREIGN KEY (id_teacher) REFERENCES teachers;

ALTER TABLE question_tags
    ADD FOREIGN KEY (id_question) REFERENCES questions ON DELETE CASCADE;

ALTER TABLE question_tags
    ADD UNIQUE (id_question, tag);

