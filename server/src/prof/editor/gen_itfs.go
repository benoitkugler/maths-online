package editor

import "encoding/json"

// Code generated by structgen/interfaces. DO NOT EDIT

// LoopbackClientEventWrapper may be used as replacements for LoopbackClientEvent
// when working with JSON
type LoopbackClientEventWrapper struct {
	Data LoopbackClientEvent
}

func (out *LoopbackClientEventWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "loopbackExerciceValidIn":
		var data loopbackExerciceValidIn
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "loopbackPing":
		var data loopbackPing
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "loopbackQuestionCorrectAnswersIn":
		var data loopbackQuestionCorrectAnswersIn
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "loopbackQuestionValidIn":
		var data loopbackQuestionValidIn
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item LoopbackClientEventWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case loopbackExerciceValidIn:
		wr = wrapper{Kind: "loopbackExerciceValidIn", Data: data}
	case loopbackPing:
		wr = wrapper{Kind: "loopbackPing", Data: data}
	case loopbackQuestionCorrectAnswersIn:
		wr = wrapper{Kind: "loopbackQuestionCorrectAnswersIn", Data: data}
	case loopbackQuestionValidIn:
		wr = wrapper{Kind: "loopbackQuestionValidIn", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	loopbackExerciceValidInLoKind          = "loopbackExerciceValidIn"
	loopbackPingLoKind                     = "loopbackPing"
	loopbackQuestionCorrectAnswersInLoKind = "loopbackQuestionCorrectAnswersIn"
	loopbackQuestionValidInLoKind          = "loopbackQuestionValidIn"
)

// LoopbackServerEventWrapper may be used as replacements for LoopbackServerEvent
// when working with JSON
type LoopbackServerEventWrapper struct {
	Data LoopbackServerEvent
}

func (out *LoopbackServerEventWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "loopbackPaused":
		var data loopbackPaused
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "loopbackQuestion":
		var data loopbackQuestion
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "loopbackQuestionCorrectAnswersOut":
		var data loopbackQuestionCorrectAnswersOut
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "loopbackQuestionValidOut":
		var data loopbackQuestionValidOut
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "loopbackShowExercice":
		var data loopbackShowExercice
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item LoopbackServerEventWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case loopbackPaused:
		wr = wrapper{Kind: "loopbackPaused", Data: data}
	case loopbackQuestion:
		wr = wrapper{Kind: "loopbackQuestion", Data: data}
	case loopbackQuestionCorrectAnswersOut:
		wr = wrapper{Kind: "loopbackQuestionCorrectAnswersOut", Data: data}
	case loopbackQuestionValidOut:
		wr = wrapper{Kind: "loopbackQuestionValidOut", Data: data}
	case loopbackShowExercice:
		wr = wrapper{Kind: "loopbackShowExercice", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	loopbackPausedLoKind                    = "loopbackPaused"
	loopbackQuestionLoKind                  = "loopbackQuestion"
	loopbackQuestionCorrectAnswersOutLoKind = "loopbackQuestionCorrectAnswersOut"
	loopbackQuestionValidOutLoKind          = "loopbackQuestionValidOut"
	loopbackShowExerciceLoKind              = "loopbackShowExercice"
)
