package questions

import "encoding/json"

// Code generated by gomacro/generator/gounions. DO NOT EDIT

// BlockWrapper may be used as replacements for Block
// when working with JSON
type BlockWrapper struct {
	Data Block
}

func (out *BlockWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "ExpressionFieldBlock":
		var data ExpressionFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigureAffineLineFieldBlock":
		var data FigureAffineLineFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigureBlock":
		var data FigureBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigurePointFieldBlock":
		var data FigurePointFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigureVectorFieldBlock":
		var data FigureVectorFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigureVectorPairFieldBlock":
		var data FigureVectorPairFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FormulaBlock":
		var data FormulaBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FunctionPointsFieldBlock":
		var data FunctionPointsFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FunctionsGraphBlock":
		var data FunctionsGraphBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "NumberFieldBlock":
		var data NumberFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "OrderedListFieldBlock":
		var data OrderedListFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ProofFieldBlock":
		var data ProofFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "RadioFieldBlock":
		var data RadioFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "SignTableBlock":
		var data SignTableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "SignTableFieldBlock":
		var data SignTableFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TableBlock":
		var data TableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TableFieldBlock":
		var data TableFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TextBlock":
		var data TextBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TreeBlock":
		var data TreeBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TreeFieldBlock":
		var data TreeFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VariationTableBlock":
		var data VariationTableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VariationTableFieldBlock":
		var data VariationTableFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VectorFieldBlock":
		var data VectorFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item BlockWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case ExpressionFieldBlock:
		wr = wrapper{Kind: "ExpressionFieldBlock", Data: data}
	case FigureAffineLineFieldBlock:
		wr = wrapper{Kind: "FigureAffineLineFieldBlock", Data: data}
	case FigureBlock:
		wr = wrapper{Kind: "FigureBlock", Data: data}
	case FigurePointFieldBlock:
		wr = wrapper{Kind: "FigurePointFieldBlock", Data: data}
	case FigureVectorFieldBlock:
		wr = wrapper{Kind: "FigureVectorFieldBlock", Data: data}
	case FigureVectorPairFieldBlock:
		wr = wrapper{Kind: "FigureVectorPairFieldBlock", Data: data}
	case FormulaBlock:
		wr = wrapper{Kind: "FormulaBlock", Data: data}
	case FunctionPointsFieldBlock:
		wr = wrapper{Kind: "FunctionPointsFieldBlock", Data: data}
	case FunctionsGraphBlock:
		wr = wrapper{Kind: "FunctionsGraphBlock", Data: data}
	case NumberFieldBlock:
		wr = wrapper{Kind: "NumberFieldBlock", Data: data}
	case OrderedListFieldBlock:
		wr = wrapper{Kind: "OrderedListFieldBlock", Data: data}
	case ProofFieldBlock:
		wr = wrapper{Kind: "ProofFieldBlock", Data: data}
	case RadioFieldBlock:
		wr = wrapper{Kind: "RadioFieldBlock", Data: data}
	case SignTableBlock:
		wr = wrapper{Kind: "SignTableBlock", Data: data}
	case SignTableFieldBlock:
		wr = wrapper{Kind: "SignTableFieldBlock", Data: data}
	case TableBlock:
		wr = wrapper{Kind: "TableBlock", Data: data}
	case TableFieldBlock:
		wr = wrapper{Kind: "TableFieldBlock", Data: data}
	case TextBlock:
		wr = wrapper{Kind: "TextBlock", Data: data}
	case TreeBlock:
		wr = wrapper{Kind: "TreeBlock", Data: data}
	case TreeFieldBlock:
		wr = wrapper{Kind: "TreeFieldBlock", Data: data}
	case VariationTableBlock:
		wr = wrapper{Kind: "VariationTableBlock", Data: data}
	case VariationTableFieldBlock:
		wr = wrapper{Kind: "VariationTableFieldBlock", Data: data}
	case VectorFieldBlock:
		wr = wrapper{Kind: "VectorFieldBlock", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	ExpressionFieldBlockBlKind       = "ExpressionFieldBlock"
	FigureAffineLineFieldBlockBlKind = "FigureAffineLineFieldBlock"
	FigureBlockBlKind                = "FigureBlock"
	FigurePointFieldBlockBlKind      = "FigurePointFieldBlock"
	FigureVectorFieldBlockBlKind     = "FigureVectorFieldBlock"
	FigureVectorPairFieldBlockBlKind = "FigureVectorPairFieldBlock"
	FormulaBlockBlKind               = "FormulaBlock"
	FunctionPointsFieldBlockBlKind   = "FunctionPointsFieldBlock"
	FunctionsGraphBlockBlKind        = "FunctionsGraphBlock"
	NumberFieldBlockBlKind           = "NumberFieldBlock"
	OrderedListFieldBlockBlKind      = "OrderedListFieldBlock"
	ProofFieldBlockBlKind            = "ProofFieldBlock"
	RadioFieldBlockBlKind            = "RadioFieldBlock"
	SignTableBlockBlKind             = "SignTableBlock"
	SignTableFieldBlockBlKind        = "SignTableFieldBlock"
	TableBlockBlKind                 = "TableBlock"
	TableFieldBlockBlKind            = "TableFieldBlock"
	TextBlockBlKind                  = "TextBlock"
	TreeBlockBlKind                  = "TreeBlock"
	TreeFieldBlockBlKind             = "TreeFieldBlock"
	VariationTableBlockBlKind        = "VariationTableBlock"
	VariationTableFieldBlockBlKind   = "VariationTableFieldBlock"
	VectorFieldBlockBlKind           = "VectorFieldBlock"
)

func (list Enonce) MarshalJSON() ([]byte, error) {
	tmp := make([]BlockWrapper, len(list))
	for i, v := range list {
		tmp[i].Data = v
	}
	return json.Marshal(tmp)
}

func (list *Enonce) UnmarshalJSON(data []byte) error {
	var tmp []BlockWrapper
	err := json.Unmarshal(data, &tmp)
	*list = make(Enonce, len(tmp))
	for i, v := range tmp {
		(*list)[i] = v.Data
	}
	return err
}

// ParameterEntryWrapper may be used as replacements for ParameterEntry
// when working with JSON
type ParameterEntryWrapper struct {
	Data ParameterEntry
}

func (out *ParameterEntryWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "Co":
		var data Co
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "In":
		var data In
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Rp":
		var data Rp
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item ParameterEntryWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case Co:
		wr = wrapper{Kind: "Co", Data: data}
	case In:
		wr = wrapper{Kind: "In", Data: data}
	case Rp:
		wr = wrapper{Kind: "Rp", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	CoPaKind = "Co"
	InPaKind = "In"
	RpPaKind = "Rp"
)

func (list Parameters) MarshalJSON() ([]byte, error) {
	tmp := make([]ParameterEntryWrapper, len(list))
	for i, v := range list {
		tmp[i].Data = v
	}
	return json.Marshal(tmp)
}

func (list *Parameters) UnmarshalJSON(data []byte) error {
	var tmp []ParameterEntryWrapper
	err := json.Unmarshal(data, &tmp)
	*list = make(Parameters, len(tmp))
	for i, v := range tmp {
		(*list)[i] = v.Data
	}
	return err
}
