package questions

import "encoding/json"

// Code generated by gomacro/generator/gounions. DO NOT EDIT

// BlockWrapper may be used as replacements for Block
// when working with JSON
type BlockWrapper struct {
	Data Block
}

func (out *BlockWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "ExpressionFieldBlock":
		var data ExpressionFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigureBlock":
		var data FigureBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FormulaBlock":
		var data FormulaBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FunctionPointsFieldBlock":
		var data FunctionPointsFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FunctionsGraphBlock":
		var data FunctionsGraphBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "GeometricConstructionFieldBlock":
		var data GeometricConstructionFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "NumberFieldBlock":
		var data NumberFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "OrderedListFieldBlock":
		var data OrderedListFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ProofFieldBlock":
		var data ProofFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "RadioFieldBlock":
		var data RadioFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "SignTableBlock":
		var data SignTableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "SignTableFieldBlock":
		var data SignTableFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TableBlock":
		var data TableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TableFieldBlock":
		var data TableFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TextBlock":
		var data TextBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TreeBlock":
		var data TreeBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TreeFieldBlock":
		var data TreeFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VariationTableBlock":
		var data VariationTableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VariationTableFieldBlock":
		var data VariationTableFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VectorFieldBlock":
		var data VectorFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item BlockWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case ExpressionFieldBlock:
		wr = wrapper{Kind: "ExpressionFieldBlock", Data: data}
	case FigureBlock:
		wr = wrapper{Kind: "FigureBlock", Data: data}
	case FormulaBlock:
		wr = wrapper{Kind: "FormulaBlock", Data: data}
	case FunctionPointsFieldBlock:
		wr = wrapper{Kind: "FunctionPointsFieldBlock", Data: data}
	case FunctionsGraphBlock:
		wr = wrapper{Kind: "FunctionsGraphBlock", Data: data}
	case GeometricConstructionFieldBlock:
		wr = wrapper{Kind: "GeometricConstructionFieldBlock", Data: data}
	case NumberFieldBlock:
		wr = wrapper{Kind: "NumberFieldBlock", Data: data}
	case OrderedListFieldBlock:
		wr = wrapper{Kind: "OrderedListFieldBlock", Data: data}
	case ProofFieldBlock:
		wr = wrapper{Kind: "ProofFieldBlock", Data: data}
	case RadioFieldBlock:
		wr = wrapper{Kind: "RadioFieldBlock", Data: data}
	case SignTableBlock:
		wr = wrapper{Kind: "SignTableBlock", Data: data}
	case SignTableFieldBlock:
		wr = wrapper{Kind: "SignTableFieldBlock", Data: data}
	case TableBlock:
		wr = wrapper{Kind: "TableBlock", Data: data}
	case TableFieldBlock:
		wr = wrapper{Kind: "TableFieldBlock", Data: data}
	case TextBlock:
		wr = wrapper{Kind: "TextBlock", Data: data}
	case TreeBlock:
		wr = wrapper{Kind: "TreeBlock", Data: data}
	case TreeFieldBlock:
		wr = wrapper{Kind: "TreeFieldBlock", Data: data}
	case VariationTableBlock:
		wr = wrapper{Kind: "VariationTableBlock", Data: data}
	case VariationTableFieldBlock:
		wr = wrapper{Kind: "VariationTableFieldBlock", Data: data}
	case VectorFieldBlock:
		wr = wrapper{Kind: "VectorFieldBlock", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	ExpressionFieldBlockBlKind            = "ExpressionFieldBlock"
	FigureBlockBlKind                     = "FigureBlock"
	FormulaBlockBlKind                    = "FormulaBlock"
	FunctionPointsFieldBlockBlKind        = "FunctionPointsFieldBlock"
	FunctionsGraphBlockBlKind             = "FunctionsGraphBlock"
	GeometricConstructionFieldBlockBlKind = "GeometricConstructionFieldBlock"
	NumberFieldBlockBlKind                = "NumberFieldBlock"
	OrderedListFieldBlockBlKind           = "OrderedListFieldBlock"
	ProofFieldBlockBlKind                 = "ProofFieldBlock"
	RadioFieldBlockBlKind                 = "RadioFieldBlock"
	SignTableBlockBlKind                  = "SignTableBlock"
	SignTableFieldBlockBlKind             = "SignTableFieldBlock"
	TableBlockBlKind                      = "TableBlock"
	TableFieldBlockBlKind                 = "TableFieldBlock"
	TextBlockBlKind                       = "TextBlock"
	TreeBlockBlKind                       = "TreeBlock"
	TreeFieldBlockBlKind                  = "TreeFieldBlock"
	VariationTableBlockBlKind             = "VariationTableBlock"
	VariationTableFieldBlockBlKind        = "VariationTableFieldBlock"
	VectorFieldBlockBlKind                = "VectorFieldBlock"
)

func (list Enonce) MarshalJSON() ([]byte, error) {
	tmp := make([]BlockWrapper, len(list))
	for i, v := range list {
		tmp[i].Data = v
	}
	return json.Marshal(tmp)
}

func (list *Enonce) UnmarshalJSON(data []byte) error {
	var tmp []BlockWrapper
	err := json.Unmarshal(data, &tmp)
	*list = make(Enonce, len(tmp))
	for i, v := range tmp {
		(*list)[i] = v.Data
	}
	return err
}

// FiguresOrGraphsWrapper may be used as replacements for FiguresOrGraphs
// when working with JSON
type FiguresOrGraphsWrapper struct {
	Data FiguresOrGraphs
}

func (out *FiguresOrGraphsWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "FigureBlock":
		var data FigureBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FunctionsGraphBlock":
		var data FunctionsGraphBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item FiguresOrGraphsWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case FigureBlock:
		wr = wrapper{Kind: "FigureBlock", Data: data}
	case FunctionsGraphBlock:
		wr = wrapper{Kind: "FunctionsGraphBlock", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	FigureBlockFiKind         = "FigureBlock"
	FunctionsGraphBlockFiKind = "FunctionsGraphBlock"
)

// GeoFieldWrapper may be used as replacements for GeoField
// when working with JSON
type GeoFieldWrapper struct {
	Data GeoField
}

func (out *GeoFieldWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "GFAffineLine":
		var data GFAffineLine
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "GFPoint":
		var data GFPoint
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "GFVector":
		var data GFVector
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "GFVectorPair":
		var data GFVectorPair
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item GeoFieldWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case GFAffineLine:
		wr = wrapper{Kind: "GFAffineLine", Data: data}
	case GFPoint:
		wr = wrapper{Kind: "GFPoint", Data: data}
	case GFVector:
		wr = wrapper{Kind: "GFVector", Data: data}
	case GFVectorPair:
		wr = wrapper{Kind: "GFVectorPair", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	GFAffineLineGeKind = "GFAffineLine"
	GFPointGeKind      = "GFPoint"
	GFVectorGeKind     = "GFVector"
	GFVectorPairGeKind = "GFVectorPair"
)

func (item GeometricConstructionFieldBlock) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Field      GeoFieldWrapper
		Background FiguresOrGraphsWrapper
	}
	wr := wrapper{
		Field:      GeoFieldWrapper{item.Field},
		Background: FiguresOrGraphsWrapper{item.Background},
	}
	return json.Marshal(wr)
}

func (item *GeometricConstructionFieldBlock) UnmarshalJSON(src []byte) error {
	type wrapper struct {
		Field      GeoFieldWrapper
		Background FiguresOrGraphsWrapper
	}
	var wr wrapper
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	item.Field = wr.Field.Data
	item.Background = wr.Background.Data
	return nil
}

// ParameterEntryWrapper may be used as replacements for ParameterEntry
// when working with JSON
type ParameterEntryWrapper struct {
	Data ParameterEntry
}

func (out *ParameterEntryWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "Co":
		var data Co
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "In":
		var data In
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Rp":
		var data Rp
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item ParameterEntryWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case Co:
		wr = wrapper{Kind: "Co", Data: data}
	case In:
		wr = wrapper{Kind: "In", Data: data}
	case Rp:
		wr = wrapper{Kind: "Rp", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	CoPaKind = "Co"
	InPaKind = "In"
	RpPaKind = "Rp"
)

func (list Parameters) MarshalJSON() ([]byte, error) {
	tmp := make([]ParameterEntryWrapper, len(list))
	for i, v := range list {
		tmp[i].Data = v
	}
	return json.Marshal(tmp)
}

func (list *Parameters) UnmarshalJSON(data []byte) error {
	var tmp []ParameterEntryWrapper
	err := json.Unmarshal(data, &tmp)
	*list = make(Parameters, len(tmp))
	for i, v := range tmp {
		(*list)[i] = v.Data
	}
	return err
}
