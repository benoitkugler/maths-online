package questions

import (
	"encoding/json"

	"github.com/benoitkugler/maths-online/maths/questions/client"
)

// Code generated by structgen/interfaces. DO NOT EDIT

// ProofAssertionWrapper may be used as replacements for ProofAssertion
// when working with JSON
type ProofAssertionWrapper struct {
	Data ProofAssertion
}

func (out *ProofAssertionWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "ProofEquality":
		var data ProofEquality
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ProofInvalid":
		var data ProofInvalid
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ProofNode":
		var data ProofNode
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ProofSequence":
		var data ProofSequence
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ProofStatement":
		var data ProofStatement
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item ProofAssertionWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case ProofEquality:
		wr = wrapper{Kind: "ProofEquality", Data: data}
	case ProofInvalid:
		wr = wrapper{Kind: "ProofInvalid", Data: data}
	case ProofNode:
		wr = wrapper{Kind: "ProofNode", Data: data}
	case ProofSequence:
		wr = wrapper{Kind: "ProofSequence", Data: data}
	case ProofStatement:
		wr = wrapper{Kind: "ProofStatement", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	ProofEqualityPrKind  = "ProofEquality"
	ProofInvalidPrKind   = "ProofInvalid"
	ProofNodePrKind      = "ProofNode"
	ProofSequencePrKind  = "ProofSequence"
	ProofStatementPrKind = "ProofStatement"
)

func (ct ProofAssertions) MarshalJSON() ([]byte, error) {
	tmp := make([]ProofAssertionWrapper, len(ct))
	for i, v := range ct {
		tmp[i].Data = v
	}
	return json.Marshal(tmp)
}

func (ct *ProofAssertions) UnmarshalJSON(data []byte) error {
	var tmp []ProofAssertionWrapper
	err := json.Unmarshal(data, &tmp)
	*ct = make(ProofAssertions, len(tmp))
	for i, v := range tmp {
		(*ct)[i] = v.Data
	}
	return err
}

func (item ProofNode) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Left  ProofAssertionWrapper
		Right ProofAssertionWrapper
		Op    client.Binary
	}
	wr := wrapper{
		Left:  ProofAssertionWrapper{item.Left},
		Right: ProofAssertionWrapper{item.Right},
		Op:    item.Op,
	}
	return json.Marshal(wr)
}

func (item *ProofNode) UnmarshalJSON(src []byte) error {
	type wrapper struct {
		Left  ProofAssertionWrapper
		Right ProofAssertionWrapper
		Op    client.Binary
	}
	var wr wrapper
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	item.Left = wr.Left.Data
	item.Right = wr.Right.Data
	item.Op = wr.Op
	return nil
}
