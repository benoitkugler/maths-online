package client

import "encoding/json"

// Code generated by structgen/interfaces. DO NOT EDIT

// AnswerWrapper may be used as replacements for Answer
// when working with JSON
type AnswerWrapper struct {
	Data Answer
}

func (out *AnswerWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "DoublePointAnswer":
		var data DoublePointAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "DoublePointPairAnswer":
		var data DoublePointPairAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ExpressionAnswer":
		var data ExpressionAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FunctionPointsAnswer":
		var data FunctionPointsAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "NumberAnswer":
		var data NumberAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "OrderedListAnswer":
		var data OrderedListAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "PointAnswer":
		var data PointAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "RadioAnswer":
		var data RadioAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TableAnswer":
		var data TableAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TreeAnswer":
		var data TreeAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VariationTableAnswer":
		var data VariationTableAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VectorNumberAnswer":
		var data VectorNumberAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item AnswerWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case DoublePointAnswer:
		wr = wrapper{Kind: "DoublePointAnswer", Data: data}
	case DoublePointPairAnswer:
		wr = wrapper{Kind: "DoublePointPairAnswer", Data: data}
	case ExpressionAnswer:
		wr = wrapper{Kind: "ExpressionAnswer", Data: data}
	case FunctionPointsAnswer:
		wr = wrapper{Kind: "FunctionPointsAnswer", Data: data}
	case NumberAnswer:
		wr = wrapper{Kind: "NumberAnswer", Data: data}
	case OrderedListAnswer:
		wr = wrapper{Kind: "OrderedListAnswer", Data: data}
	case PointAnswer:
		wr = wrapper{Kind: "PointAnswer", Data: data}
	case RadioAnswer:
		wr = wrapper{Kind: "RadioAnswer", Data: data}
	case TableAnswer:
		wr = wrapper{Kind: "TableAnswer", Data: data}
	case TreeAnswer:
		wr = wrapper{Kind: "TreeAnswer", Data: data}
	case VariationTableAnswer:
		wr = wrapper{Kind: "VariationTableAnswer", Data: data}
	case VectorNumberAnswer:
		wr = wrapper{Kind: "VectorNumberAnswer", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	DoublePointAnswerAnKind     = "DoublePointAnswer"
	DoublePointPairAnswerAnKind = "DoublePointPairAnswer"
	ExpressionAnswerAnKind      = "ExpressionAnswer"
	FunctionPointsAnswerAnKind  = "FunctionPointsAnswer"
	NumberAnswerAnKind          = "NumberAnswer"
	OrderedListAnswerAnKind     = "OrderedListAnswer"
	PointAnswerAnKind           = "PointAnswer"
	RadioAnswerAnKind           = "RadioAnswer"
	TableAnswerAnKind           = "TableAnswer"
	TreeAnswerAnKind            = "TreeAnswer"
	VariationTableAnswerAnKind  = "VariationTableAnswer"
	VectorNumberAnswerAnKind    = "VectorNumberAnswer"
)

// BlockWrapper may be used as replacements for Block
// when working with JSON
type BlockWrapper struct {
	Data Block
}

func (out *BlockWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "DropDownFieldBlock":
		var data DropDownFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ExpressionFieldBlock":
		var data ExpressionFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigureBlock":
		var data FigureBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigurePointFieldBlock":
		var data FigurePointFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigureVectorFieldBlock":
		var data FigureVectorFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigureVectorPairFieldBlock":
		var data FigureVectorPairFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FormulaBlock":
		var data FormulaBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FunctionPointsFieldBlock":
		var data FunctionPointsFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FunctionsGraphBlock":
		var data FunctionsGraphBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "NumberFieldBlock":
		var data NumberFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "OrderedListFieldBlock":
		var data OrderedListFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "RadioFieldBlock":
		var data RadioFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "SignTableBlock":
		var data SignTableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TableBlock":
		var data TableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TableFieldBlock":
		var data TableFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TextBlock":
		var data TextBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TreeFieldBlock":
		var data TreeFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VariationTableBlock":
		var data VariationTableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VariationTableFieldBlock":
		var data VariationTableFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VectorFieldBlock":
		var data VectorFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item BlockWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case DropDownFieldBlock:
		wr = wrapper{Kind: "DropDownFieldBlock", Data: data}
	case ExpressionFieldBlock:
		wr = wrapper{Kind: "ExpressionFieldBlock", Data: data}
	case FigureBlock:
		wr = wrapper{Kind: "FigureBlock", Data: data}
	case FigurePointFieldBlock:
		wr = wrapper{Kind: "FigurePointFieldBlock", Data: data}
	case FigureVectorFieldBlock:
		wr = wrapper{Kind: "FigureVectorFieldBlock", Data: data}
	case FigureVectorPairFieldBlock:
		wr = wrapper{Kind: "FigureVectorPairFieldBlock", Data: data}
	case FormulaBlock:
		wr = wrapper{Kind: "FormulaBlock", Data: data}
	case FunctionPointsFieldBlock:
		wr = wrapper{Kind: "FunctionPointsFieldBlock", Data: data}
	case FunctionsGraphBlock:
		wr = wrapper{Kind: "FunctionsGraphBlock", Data: data}
	case NumberFieldBlock:
		wr = wrapper{Kind: "NumberFieldBlock", Data: data}
	case OrderedListFieldBlock:
		wr = wrapper{Kind: "OrderedListFieldBlock", Data: data}
	case RadioFieldBlock:
		wr = wrapper{Kind: "RadioFieldBlock", Data: data}
	case SignTableBlock:
		wr = wrapper{Kind: "SignTableBlock", Data: data}
	case TableBlock:
		wr = wrapper{Kind: "TableBlock", Data: data}
	case TableFieldBlock:
		wr = wrapper{Kind: "TableFieldBlock", Data: data}
	case TextBlock:
		wr = wrapper{Kind: "TextBlock", Data: data}
	case TreeFieldBlock:
		wr = wrapper{Kind: "TreeFieldBlock", Data: data}
	case VariationTableBlock:
		wr = wrapper{Kind: "VariationTableBlock", Data: data}
	case VariationTableFieldBlock:
		wr = wrapper{Kind: "VariationTableFieldBlock", Data: data}
	case VectorFieldBlock:
		wr = wrapper{Kind: "VectorFieldBlock", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	DropDownFieldBlockBlKind         = "DropDownFieldBlock"
	ExpressionFieldBlockBlKind       = "ExpressionFieldBlock"
	FigureBlockBlKind                = "FigureBlock"
	FigurePointFieldBlockBlKind      = "FigurePointFieldBlock"
	FigureVectorFieldBlockBlKind     = "FigureVectorFieldBlock"
	FigureVectorPairFieldBlockBlKind = "FigureVectorPairFieldBlock"
	FormulaBlockBlKind               = "FormulaBlock"
	FunctionPointsFieldBlockBlKind   = "FunctionPointsFieldBlock"
	FunctionsGraphBlockBlKind        = "FunctionsGraphBlock"
	NumberFieldBlockBlKind           = "NumberFieldBlock"
	OrderedListFieldBlockBlKind      = "OrderedListFieldBlock"
	RadioFieldBlockBlKind            = "RadioFieldBlock"
	SignTableBlockBlKind             = "SignTableBlock"
	TableBlockBlKind                 = "TableBlock"
	TableFieldBlockBlKind            = "TableFieldBlock"
	TextBlockBlKind                  = "TextBlock"
	TreeFieldBlockBlKind             = "TreeFieldBlock"
	VariationTableBlockBlKind        = "VariationTableBlock"
	VariationTableFieldBlockBlKind   = "VariationTableFieldBlock"
	VectorFieldBlockBlKind           = "VectorFieldBlock"
)

func (ct Enonce) MarshalJSON() ([]byte, error) {
	tmp := make([]BlockWrapper, len(ct))
	for i, v := range ct {
		tmp[i].Data = v
	}
	return json.Marshal(tmp)
}

func (ct *Enonce) UnmarshalJSON(data []byte) error {
	var tmp []BlockWrapper
	err := json.Unmarshal(data, &tmp)
	*ct = make(Enonce, len(tmp))
	for i, v := range tmp {
		(*ct)[i] = v.Data
	}
	return err
}
