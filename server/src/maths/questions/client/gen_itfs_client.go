package client

import "encoding/json"

// Code generated by gomacro/generator/gounions. DO NOT EDIT

// AnswerWrapper may be used as replacements for Answer
// when working with JSON
type AnswerWrapper struct {
	Data Answer
}

func (out *AnswerWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "DoublePointAnswer":
		var data DoublePointAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "DoublePointPairAnswer":
		var data DoublePointPairAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ExpressionAnswer":
		var data ExpressionAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FunctionPointsAnswer":
		var data FunctionPointsAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "NumberAnswer":
		var data NumberAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "OrderedListAnswer":
		var data OrderedListAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "PointAnswer":
		var data PointAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ProofAnswer":
		var data ProofAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "RadioAnswer":
		var data RadioAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "SignTableAnswer":
		var data SignTableAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TableAnswer":
		var data TableAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TreeAnswer":
		var data TreeAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VariationTableAnswer":
		var data VariationTableAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VectorNumberAnswer":
		var data VectorNumberAnswer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item AnswerWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case DoublePointAnswer:
		wr = wrapper{Kind: "DoublePointAnswer", Data: data}
	case DoublePointPairAnswer:
		wr = wrapper{Kind: "DoublePointPairAnswer", Data: data}
	case ExpressionAnswer:
		wr = wrapper{Kind: "ExpressionAnswer", Data: data}
	case FunctionPointsAnswer:
		wr = wrapper{Kind: "FunctionPointsAnswer", Data: data}
	case NumberAnswer:
		wr = wrapper{Kind: "NumberAnswer", Data: data}
	case OrderedListAnswer:
		wr = wrapper{Kind: "OrderedListAnswer", Data: data}
	case PointAnswer:
		wr = wrapper{Kind: "PointAnswer", Data: data}
	case ProofAnswer:
		wr = wrapper{Kind: "ProofAnswer", Data: data}
	case RadioAnswer:
		wr = wrapper{Kind: "RadioAnswer", Data: data}
	case SignTableAnswer:
		wr = wrapper{Kind: "SignTableAnswer", Data: data}
	case TableAnswer:
		wr = wrapper{Kind: "TableAnswer", Data: data}
	case TreeAnswer:
		wr = wrapper{Kind: "TreeAnswer", Data: data}
	case VariationTableAnswer:
		wr = wrapper{Kind: "VariationTableAnswer", Data: data}
	case VectorNumberAnswer:
		wr = wrapper{Kind: "VectorNumberAnswer", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	DoublePointAnswerAnKind     = "DoublePointAnswer"
	DoublePointPairAnswerAnKind = "DoublePointPairAnswer"
	ExpressionAnswerAnKind      = "ExpressionAnswer"
	FunctionPointsAnswerAnKind  = "FunctionPointsAnswer"
	NumberAnswerAnKind          = "NumberAnswer"
	OrderedListAnswerAnKind     = "OrderedListAnswer"
	PointAnswerAnKind           = "PointAnswer"
	ProofAnswerAnKind           = "ProofAnswer"
	RadioAnswerAnKind           = "RadioAnswer"
	SignTableAnswerAnKind       = "SignTableAnswer"
	TableAnswerAnKind           = "TableAnswer"
	TreeAnswerAnKind            = "TreeAnswer"
	VariationTableAnswerAnKind  = "VariationTableAnswer"
	VectorNumberAnswerAnKind    = "VectorNumberAnswer"
)

func (dict Answers) MarshalJSON() ([]byte, error) {
	tmp := make(map[int]AnswerWrapper)
	for k, v := range dict {
		tmp[k] = AnswerWrapper{v}
	}
	return json.Marshal(tmp)
}

func (dict *Answers) UnmarshalJSON(src []byte) error {
	var wr map[int]AnswerWrapper
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}

	*dict = make(Answers)
	for i, v := range wr {
		(*dict)[i] = v.Data
	}
	return nil
}

// AssertionWrapper may be used as replacements for Assertion
// when working with JSON
type AssertionWrapper struct {
	Data Assertion
}

func (out *AssertionWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "Equality":
		var data Equality
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Node":
		var data Node
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Sequence":
		var data Sequence
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Statement":
		var data Statement
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item AssertionWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case Equality:
		wr = wrapper{Kind: "Equality", Data: data}
	case Node:
		wr = wrapper{Kind: "Node", Data: data}
	case Sequence:
		wr = wrapper{Kind: "Sequence", Data: data}
	case Statement:
		wr = wrapper{Kind: "Statement", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	EqualityAsKind  = "Equality"
	NodeAsKind      = "Node"
	SequenceAsKind  = "Sequence"
	StatementAsKind = "Statement"
)

func (list Assertions) MarshalJSON() ([]byte, error) {
	tmp := make([]AssertionWrapper, len(list))
	for i, v := range list {
		tmp[i].Data = v
	}
	return json.Marshal(tmp)
}

func (list *Assertions) UnmarshalJSON(data []byte) error {
	var tmp []AssertionWrapper
	err := json.Unmarshal(data, &tmp)
	*list = make(Assertions, len(tmp))
	for i, v := range tmp {
		(*list)[i] = v.Data
	}
	return err
}

// BlockWrapper may be used as replacements for Block
// when working with JSON
type BlockWrapper struct {
	Data Block
}

func (out *BlockWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "DropDownFieldBlock":
		var data DropDownFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ExpressionFieldBlock":
		var data ExpressionFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigureBlock":
		var data FigureBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigurePointFieldBlock":
		var data FigurePointFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigureVectorFieldBlock":
		var data FigureVectorFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FigureVectorPairFieldBlock":
		var data FigureVectorPairFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FormulaBlock":
		var data FormulaBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FunctionPointsFieldBlock":
		var data FunctionPointsFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "FunctionsGraphBlock":
		var data FunctionsGraphBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "NumberFieldBlock":
		var data NumberFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "OrderedListFieldBlock":
		var data OrderedListFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ProofFieldBlock":
		var data ProofFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "RadioFieldBlock":
		var data RadioFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "SignTableBlock":
		var data SignTableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "SignTableFieldBlock":
		var data SignTableFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TableBlock":
		var data TableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TableFieldBlock":
		var data TableFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TextBlock":
		var data TextBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TreeBlock":
		var data TreeBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "TreeFieldBlock":
		var data TreeFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VariationTableBlock":
		var data VariationTableBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VariationTableFieldBlock":
		var data VariationTableFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "VectorFieldBlock":
		var data VectorFieldBlock
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item BlockWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case DropDownFieldBlock:
		wr = wrapper{Kind: "DropDownFieldBlock", Data: data}
	case ExpressionFieldBlock:
		wr = wrapper{Kind: "ExpressionFieldBlock", Data: data}
	case FigureBlock:
		wr = wrapper{Kind: "FigureBlock", Data: data}
	case FigurePointFieldBlock:
		wr = wrapper{Kind: "FigurePointFieldBlock", Data: data}
	case FigureVectorFieldBlock:
		wr = wrapper{Kind: "FigureVectorFieldBlock", Data: data}
	case FigureVectorPairFieldBlock:
		wr = wrapper{Kind: "FigureVectorPairFieldBlock", Data: data}
	case FormulaBlock:
		wr = wrapper{Kind: "FormulaBlock", Data: data}
	case FunctionPointsFieldBlock:
		wr = wrapper{Kind: "FunctionPointsFieldBlock", Data: data}
	case FunctionsGraphBlock:
		wr = wrapper{Kind: "FunctionsGraphBlock", Data: data}
	case NumberFieldBlock:
		wr = wrapper{Kind: "NumberFieldBlock", Data: data}
	case OrderedListFieldBlock:
		wr = wrapper{Kind: "OrderedListFieldBlock", Data: data}
	case ProofFieldBlock:
		wr = wrapper{Kind: "ProofFieldBlock", Data: data}
	case RadioFieldBlock:
		wr = wrapper{Kind: "RadioFieldBlock", Data: data}
	case SignTableBlock:
		wr = wrapper{Kind: "SignTableBlock", Data: data}
	case SignTableFieldBlock:
		wr = wrapper{Kind: "SignTableFieldBlock", Data: data}
	case TableBlock:
		wr = wrapper{Kind: "TableBlock", Data: data}
	case TableFieldBlock:
		wr = wrapper{Kind: "TableFieldBlock", Data: data}
	case TextBlock:
		wr = wrapper{Kind: "TextBlock", Data: data}
	case TreeBlock:
		wr = wrapper{Kind: "TreeBlock", Data: data}
	case TreeFieldBlock:
		wr = wrapper{Kind: "TreeFieldBlock", Data: data}
	case VariationTableBlock:
		wr = wrapper{Kind: "VariationTableBlock", Data: data}
	case VariationTableFieldBlock:
		wr = wrapper{Kind: "VariationTableFieldBlock", Data: data}
	case VectorFieldBlock:
		wr = wrapper{Kind: "VectorFieldBlock", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	DropDownFieldBlockBlKind         = "DropDownFieldBlock"
	ExpressionFieldBlockBlKind       = "ExpressionFieldBlock"
	FigureBlockBlKind                = "FigureBlock"
	FigurePointFieldBlockBlKind      = "FigurePointFieldBlock"
	FigureVectorFieldBlockBlKind     = "FigureVectorFieldBlock"
	FigureVectorPairFieldBlockBlKind = "FigureVectorPairFieldBlock"
	FormulaBlockBlKind               = "FormulaBlock"
	FunctionPointsFieldBlockBlKind   = "FunctionPointsFieldBlock"
	FunctionsGraphBlockBlKind        = "FunctionsGraphBlock"
	NumberFieldBlockBlKind           = "NumberFieldBlock"
	OrderedListFieldBlockBlKind      = "OrderedListFieldBlock"
	ProofFieldBlockBlKind            = "ProofFieldBlock"
	RadioFieldBlockBlKind            = "RadioFieldBlock"
	SignTableBlockBlKind             = "SignTableBlock"
	SignTableFieldBlockBlKind        = "SignTableFieldBlock"
	TableBlockBlKind                 = "TableBlock"
	TableFieldBlockBlKind            = "TableFieldBlock"
	TextBlockBlKind                  = "TextBlock"
	TreeBlockBlKind                  = "TreeBlock"
	TreeFieldBlockBlKind             = "TreeFieldBlock"
	VariationTableBlockBlKind        = "VariationTableBlock"
	VariationTableFieldBlockBlKind   = "VariationTableFieldBlock"
	VectorFieldBlockBlKind           = "VectorFieldBlock"
)

func (list Enonce) MarshalJSON() ([]byte, error) {
	tmp := make([]BlockWrapper, len(list))
	for i, v := range list {
		tmp[i].Data = v
	}
	return json.Marshal(tmp)
}

func (list *Enonce) UnmarshalJSON(data []byte) error {
	var tmp []BlockWrapper
	err := json.Unmarshal(data, &tmp)
	*list = make(Enonce, len(tmp))
	for i, v := range tmp {
		(*list)[i] = v.Data
	}
	return err
}

func (item Node) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Left  AssertionWrapper
		Right AssertionWrapper
		Op    Binary
	}
	wr := wrapper{
		Left:  AssertionWrapper{item.Left},
		Right: AssertionWrapper{item.Right},
		Op:    item.Op,
	}
	return json.Marshal(wr)
}

func (item *Node) UnmarshalJSON(src []byte) error {
	type wrapper struct {
		Left  AssertionWrapper
		Right AssertionWrapper
		Op    Binary
	}
	var wr wrapper
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	item.Left = wr.Left.Data
	item.Right = wr.Right.Data
	item.Op = wr.Op
	return nil
}

func (item QuestionSyntaxCheckIn) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Answer AnswerWrapper
		ID     int
	}
	wr := wrapper{
		Answer: AnswerWrapper{item.Answer},
		ID:     item.ID,
	}
	return json.Marshal(wr)
}

func (item *QuestionSyntaxCheckIn) UnmarshalJSON(src []byte) error {
	type wrapper struct {
		Answer AnswerWrapper
		ID     int
	}
	var wr wrapper
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	item.Answer = wr.Answer.Data
	item.ID = wr.ID
	return nil
}
