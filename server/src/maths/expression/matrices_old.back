func (e *Expr) isNumber() (Number, bool) {
	if n, ok := e.atom.(Number); ok {
		return n, true
	}
	if e.atom == minus {
		if n, ok := e.right.atom.(Number); ok {
			return -n, true
		}
	}
	return 0, false
}

func add(a, b *Expr) *Expr { return &Expr{atom: plus, left: a, right: b} }

func prod(a, b *Expr) *Expr { return &Expr{atom: mult, left: a, right: b} }


// assume A and B are compatible and out has the correct size
func (A matrix) prodTo(B matrix, out matrix) {
	for i, row := range out {
		for j := range row {
			s := Number(0)
			var sExpr *Expr
			for k := range A[i] {
				Aik := A[i][k]
				Bkj := B[k][j]
				if sExpr == nil {
					a, ok := Aik.isNumber()
					b, ok2 := Bkj.isNumber()
					if ok && ok2 {
						s += a * b
					} else {
						// switch to expr mode
						sExpr = &Expr{atom: s}
						e := prod(Aik, Bkj)
						sExpr = add(sExpr, e)
					}
				} else {
					// use expr mode
					e := prod(Aik, Bkj)
					sExpr = add(sExpr, e)
				}
			}
			if sExpr == nil {
				row[j] = &Expr{atom: s}
			} else {
				row[j] = sExpr
			}
		}
	}
}



// A * B
func (A matrix) prod(B matrix) (matrix, error) {
	mA, nA := A.dims()
	mB, nB := B.dims()
	if nA != mB {
		return nil, fmt.Errorf("matrices de dimensions incompatibles (%d != %d)", nA, mB)
	}

	out := newEmpty(mA, nB)
	A.prodTo(B, out)

	return out, nil
}

// fow now, only handle positive values
func (A matrix) pow(nf float64) (matrix, error) {
	kmax, ok := IsInt(nf)
	if !ok || kmax < 0 {
		return nil, fmt.Errorf("puissance de matrice %f non entière positive", nf)
	}

	m, n := A.dims()
	if m != n {
		return nil, fmt.Errorf("puissance d'une matrice non carrée (%d, %d)", m, n)
	}

	// identity
	out := newEmpty(n, n)
	for i := range out {
		for j := range out {
			if i == j {
				out[i][j] = newNb(1)
			} else {
				out[i][j] = newNb(0)
			}
		}
	}

	if kmax == 0 {
		return out, nil
	} else if kmax == 1 {
		return A, nil
	} else if kmax == 2 {
		out, _ = A.prod(A) // prod is safe here
		return out, nil
	} else {
		// only allocate two buffers
		tmp := newEmpty(n, n)
		for k := 0; k < kmax; k++ {
			out.prodTo(A, tmp)
			out, tmp = tmp, out // switch buffers
		}
	}

	return out, nil
}


func (A matrix) determinant() (*Expr, error) {
	m, n := A.dims()
	if m != n {
		return nil, fmt.Errorf("déterminant d'une matrice non carrée (%d, %d)", m, n)
	}

	if m == 0 {
		return newNb(0), nil
	} else if m == 1 {
		return A[0][0], nil
	} else if m == 2 {
		return &Expr{atom: minus, left: prod(A[0][0], A[1][1]), right: prod(A[1][0], A[0][1])}, nil
	} else { // last row dev
		det := newNb(0)
		for j := range A {
			minor := A.minor(m-1, j)
			coeff := A[m-1][j]
			det = add(det, prod(coeff, minor))
		}
		return det, nil
	}
}

// assume A is squared
func (A matrix) minor(i, j int) *Expr {
	minor, _ := A.submatrix(i, j).determinant() // determinant is safe here
	if (i+j)%2 != 0 {                           // i and j is shifted by one, compensating
		minor = &Expr{atom: minus, left: nil, right: minor}
	}
	return minor
}

// return 1/detA * transpose(comatrice(A))
func (A matrix) invert() (matrix, error) {
	det, err := A.determinant()
	if err != nil {
		return nil, err
	}
	comTransp := make(matrix, len(A))
	for i := range A {
		row := make([]*Expr, len(A))
		for j := range row {
			row[j] = A.minor(j, i)
		}
		comTransp[i] = row
	}
	return comTransp.scale(&Expr{atom: div, left: newNb(1), right: det}), nil
}

// remove the row i and column j
// assume A is squared, with dims >= 1
// the coefficient expressions are not deep copied
func (A matrix) submatrix(i, j int) matrix {
	out := make(matrix, 0, len(A)-1)
	for i2, row := range A {
		if i2 == i { // remove row i
			continue
		}
		newRow := make([]*Expr, len(A)-1)
		copy(newRow, row[:j])
		copy(newRow[j:], row[j+1:])
		out = append(out, newRow)
	}
	return out
}
