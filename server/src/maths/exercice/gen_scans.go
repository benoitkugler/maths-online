package exercice

// Code generated by structgen. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"

	"github.com/lib/pq"
)

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

// Set is a set of IDs.
type Set map[int64]bool

func NewSet() Set {
	return map[int64]bool{}
}

// NewSetFromSlice returns a set of unique IDs
func NewSetFromSlice(keys []int64) Set {
	out := make(Set, len(keys))
	for _, key := range keys {
		out[key] = true
	}
	return out
}

// Keys return the IDs contained in the set, as a slice.
func (s Set) Keys() []int64 {
	out := make([]int64, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s Set) Has(key int64) bool {
	_, has := s[key]
	return has
}

func (s Set) Add(key int64) {
	s[key] = true
}

type IDs []int64

func (ids IDs) AsSQL() pq.Int64Array {
	return pq.Int64Array(ids)
}

func (ids IDs) AsSet() Set {
	return NewSetFromSlice(ids)
}

// ScanIDs scans the result of a query returning a
// list of IDs.
func ScanIDs(rs *sql.Rows) (IDs, error) {
	defer rs.Close()
	ints := make(IDs, 0, 16)
	var err error
	for rs.Next() {
		var s int64
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneExercice(row scanner) (Exercice, error) {
	var s Exercice
	err := row.Scan(
		&s.Id,
		&s.Title,
		&s.Description,
	)
	return s, err
}

func ScanExercice(row *sql.Row) (Exercice, error) {
	return scanOneExercice(row)
}

func SelectAllExercices(tx DB) (Exercices, error) {
	rows, err := tx.Query("SELECT * FROM exercices")
	if err != nil {
		return nil, err
	}
	return ScanExercices(rows)
}

// SelectExercice returns the entry matching id.
func SelectExercice(tx DB, id int64) (Exercice, error) {
	row := tx.QueryRow("SELECT * FROM exercices WHERE id = $1", id)
	return ScanExercice(row)
}

// SelectExercices returns the entry matching the given ids.
func SelectExercices(tx DB, ids ...int64) (Exercices, error) {
	rows, err := tx.Query("SELECT * FROM exercices WHERE id = ANY($1)", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanExercices(rows)
}

type Exercices map[int64]Exercice

func (m Exercices) IDs() IDs {
	out := make(IDs, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanExercices(rs *sql.Rows) (Exercices, error) {
	var (
		s   Exercice
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Exercices, 16)
	for rs.Next() {
		s, err = scanOneExercice(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Exercice in the database and returns the item with id filled.
func (item Exercice) Insert(tx DB) (out Exercice, err error) {
	row := tx.QueryRow(`INSERT INTO exercices (
		title,description
		) VALUES (
		$1,$2
		) RETURNING 
		id,title,description;
		`, item.Title, item.Description)
	return ScanExercice(row)
}

// Update Exercice in the database and returns the new version.
func (item Exercice) Update(tx DB) (out Exercice, err error) {
	row := tx.QueryRow(`UPDATE exercices SET (
		title,description
		) = (
		$2,$3
		) WHERE id = $1 RETURNING 
		id,title,description;
		`, item.Id, item.Title, item.Description)
	return ScanExercice(row)
}

// Deletes the Exercice and returns the item
func DeleteExerciceById(tx DB, id int64) (Exercice, error) {
	row := tx.QueryRow("DELETE FROM exercices WHERE id = $1 RETURNING *;", id)
	return ScanExercice(row)
}

// Deletes the Exercice in the database and returns the ids.
func DeleteExercicesByIDs(tx DB, ids ...int64) (IDs, error) {
	rows, err := tx.Query("DELETE FROM exercices WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIDs(rows)
}

func scanOneFormula(row scanner) (Formula, error) {
	var s Formula
	err := row.Scan(
		&s.Latex,
		&s.IsInline,
	)
	return s, err
}

func ScanFormula(row *sql.Row) (Formula, error) {
	return scanOneFormula(row)
}

func SelectAllFormulas(tx DB) (Formulas, error) {
	rows, err := tx.Query("SELECT * FROM formulas")
	if err != nil {
		return nil, err
	}
	return ScanFormulas(rows)
}

type Formulas []Formula

func ScanFormulas(rs *sql.Rows) (Formulas, error) {
	var (
		s   Formula
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Formulas, 0, 16)
	for rs.Next() {
		s, err = scanOneFormula(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links Formula in the database.
func InsertManyFormulas(tx *sql.Tx, items ...Formula) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("formulas",
		"Latex", "IsInline",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.Latex, item.IsInline)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Formula in the database.
// Only the fields are used.
func (item Formula) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM formulas WHERE 
	;`)
	return err
}

func scanOneFormulaField(row scanner) (FormulaField, error) {
	var s FormulaField
	err := row.Scan(
		&s.Content,
	)
	return s, err
}

func ScanFormulaField(row *sql.Row) (FormulaField, error) {
	return scanOneFormulaField(row)
}

func SelectAllFormulaFields(tx DB) (FormulaFields, error) {
	rows, err := tx.Query("SELECT * FROM formula_fields")
	if err != nil {
		return nil, err
	}
	return ScanFormulaFields(rows)
}

type FormulaFields []FormulaField

func ScanFormulaFields(rs *sql.Rows) (FormulaFields, error) {
	var (
		s   FormulaField
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(FormulaFields, 0, 16)
	for rs.Next() {
		s, err = scanOneFormulaField(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links FormulaField in the database.
func InsertManyFormulaFields(tx *sql.Tx, items ...FormulaField) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("formula_fields",
		"Content",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.Content)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link FormulaField in the database.
// Only the fields are used.
func (item FormulaField) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM formula_fields WHERE 
	;`)
	return err
}

func scanOneListField(row scanner) (ListField, error) {
	var s ListField
	err := row.Scan(
		&s.Choices,
	)
	return s, err
}

func ScanListField(row *sql.Row) (ListField, error) {
	return scanOneListField(row)
}

func SelectAllListFields(tx DB) (ListFields, error) {
	rows, err := tx.Query("SELECT * FROM list_fields")
	if err != nil {
		return nil, err
	}
	return ScanListFields(rows)
}

type ListFields []ListField

func ScanListFields(rs *sql.Rows) (ListFields, error) {
	var (
		s   ListField
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ListFields, 0, 16)
	for rs.Next() {
		s, err = scanOneListField(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links ListField in the database.
func InsertManyListFields(tx *sql.Tx, items ...ListField) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("list_fields",
		"Choices",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.Choices)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ListField in the database.
// Only the fields are used.
func (item ListField) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM list_fields WHERE 
	;`)
	return err
}

func scanOneQuestion(row scanner) (Question, error) {
	var s Question
	err := row.Scan(
		&s.IdExercice,
		&s.Content,
	)
	return s, err
}

func ScanQuestion(row *sql.Row) (Question, error) {
	return scanOneQuestion(row)
}

func SelectAllQuestions(tx DB) (Questions, error) {
	rows, err := tx.Query("SELECT * FROM questions")
	if err != nil {
		return nil, err
	}
	return ScanQuestions(rows)
}

type Questions []Question

func ScanQuestions(rs *sql.Rows) (Questions, error) {
	var (
		s   Question
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Questions, 0, 16)
	for rs.Next() {
		s, err = scanOneQuestion(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links Question in the database.
func InsertManyQuestions(tx *sql.Tx, items ...Question) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("questions",
		"id_exercice", "content",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdExercice, item.Content)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Question in the database.
// Only the 'IdExercice' fields are used.
func (item Question) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM questions WHERE 
	id_exercice = $1;`, item.IdExercice)
	return err
}

func (s *Content) Scan(src interface{}) error  { return loadJSON(s, src) }
func (s Content) Value() (driver.Value, error) { return dumpJSON(s) }

func scanOneTextBlock(row scanner) (TextBlock, error) {
	var s TextBlock
	err := row.Scan(
		&s.Text,
	)
	return s, err
}

func ScanTextBlock(row *sql.Row) (TextBlock, error) {
	return scanOneTextBlock(row)
}

func SelectAllTextBlocks(tx DB) (TextBlocks, error) {
	rows, err := tx.Query("SELECT * FROM text_blocks")
	if err != nil {
		return nil, err
	}
	return ScanTextBlocks(rows)
}

type TextBlocks []TextBlock

func ScanTextBlocks(rs *sql.Rows) (TextBlocks, error) {
	var (
		s   TextBlock
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(TextBlocks, 0, 16)
	for rs.Next() {
		s, err = scanOneTextBlock(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links TextBlock in the database.
func InsertManyTextBlocks(tx *sql.Tx, items ...TextBlock) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("text_blocks",
		"Text",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.Text)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link TextBlock in the database.
// Only the fields are used.
func (item TextBlock) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM text_blocks WHERE 
	;`)
	return err
}

func SelectQuestionsByIdExercices(tx DB, idExercices ...int64) (Questions, error) {
	rows, err := tx.Query("SELECT * FROM questions WHERE id_exercice = ANY($1)", pq.Int64Array(idExercices))
	if err != nil {
		return nil, err
	}
	return ScanQuestions(rows)
}

func DeleteQuestionsByIdExercices(tx DB, idExercices ...int64) (Questions, error) {
	rows, err := tx.Query("DELETE FROM questions WHERE id_exercice = ANY($1) RETURNING *", pq.Int64Array(idExercices))
	if err != nil {
		return nil, err
	}
	return ScanQuestions(rows)
}

// ByIdExercice returns a map with 'IdExercice' as keys.
func (items Questions) ByIdExercice() map[int64]Questions {
	out := make(map[int64]Questions)
	for _, target := range items {
		out[target.IdExercice] = append(out[target.IdExercice], target)
	}
	return out
}
