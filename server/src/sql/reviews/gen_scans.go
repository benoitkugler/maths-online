package reviews

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"

	"github.com/benoitkugler/maths-online/server/src/sql/editor"
	"github.com/benoitkugler/maths-online/server/src/sql/homework"
	"github.com/benoitkugler/maths-online/server/src/sql/teacher"
	"github.com/benoitkugler/maths-online/server/src/sql/trivial"
	"github.com/lib/pq"
)

type scanner interface {
	Scan(...any) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...any) (sql.Result, error)
	Query(query string, args ...any) (*sql.Rows, error)
	QueryRow(query string, args ...any) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneReview(row scanner) (Review, error) {
	var item Review
	err := row.Scan(
		&item.Id,
		&item.Kind,
	)
	return item, err
}

func ScanReview(row *sql.Row) (Review, error) { return scanOneReview(row) }

// SelectAll returns all the items in the reviews table.
func SelectAllReviews(db DB) (Reviews, error) {
	rows, err := db.Query("SELECT id, kind FROM reviews")
	if err != nil {
		return nil, err
	}
	return ScanReviews(rows)
}

// SelectReview returns the entry matching 'id'.
func SelectReview(tx DB, id IdReview) (Review, error) {
	row := tx.QueryRow("SELECT id, kind FROM reviews WHERE id = $1", id)
	return ScanReview(row)
}

// SelectReviews returns the entry matching the given 'ids'.
func SelectReviews(tx DB, ids ...IdReview) (Reviews, error) {
	rows, err := tx.Query("SELECT id, kind FROM reviews WHERE id = ANY($1)", IdReviewArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanReviews(rows)
}

type Reviews map[IdReview]Review

func (m Reviews) IDs() []IdReview {
	out := make([]IdReview, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanReviews(rs *sql.Rows) (Reviews, error) {
	var (
		s   Review
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Reviews, 16)
	for rs.Next() {
		s, err = scanOneReview(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Review in the database and returns the item with id filled.
func (item Review) Insert(tx DB) (out Review, err error) {
	row := tx.QueryRow(`INSERT INTO reviews (
		kind
		) VALUES (
		$1
		) RETURNING id, kind;
		`, item.Kind)
	return ScanReview(row)
}

// Update Review in the database and returns the new version.
func (item Review) Update(tx DB) (out Review, err error) {
	row := tx.QueryRow(`UPDATE reviews SET (
		kind
		) = (
		$1
		) WHERE id = $2 RETURNING id, kind;
		`, item.Kind, item.Id)
	return ScanReview(row)
}

// Deletes the Review and returns the item
func DeleteReviewById(tx DB, id IdReview) (Review, error) {
	row := tx.QueryRow("DELETE FROM reviews WHERE id = $1 RETURNING id, kind;", id)
	return ScanReview(row)
}

// Deletes the Review in the database and returns the ids.
func DeleteReviewsByIDs(tx DB, ids ...IdReview) ([]IdReview, error) {
	rows, err := tx.Query("DELETE FROM reviews WHERE id = ANY($1) RETURNING id", IdReviewArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdReviewArray(rows)
}

func scanOneReviewExercice(row scanner) (ReviewExercice, error) {
	var item ReviewExercice
	err := row.Scan(
		&item.IdReview,
		&item.IdExercice,
		&item.Kind,
	)
	return item, err
}

func ScanReviewExercice(row *sql.Row) (ReviewExercice, error) { return scanOneReviewExercice(row) }

// SelectAll returns all the items in the review_exercices table.
func SelectAllReviewExercices(db DB) (ReviewExercices, error) {
	rows, err := db.Query("SELECT idreview, idexercice, kind FROM review_exercices")
	if err != nil {
		return nil, err
	}
	return ScanReviewExercices(rows)
}

type ReviewExercices []ReviewExercice

func ScanReviewExercices(rs *sql.Rows) (ReviewExercices, error) {
	var (
		item ReviewExercice
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ReviewExercices, 0, 16)
	for rs.Next() {
		item, err = scanOneReviewExercice(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item ReviewExercice) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO review_exercices (
			idreview, idexercice, kind
			) VALUES (
			$1, $2, $3
			);
			`, item.IdReview, item.IdExercice, item.Kind)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links ReviewExercice in the database.
// It is a no-op if 'items' is empty.
func InsertManyReviewExercices(tx *sql.Tx, items ...ReviewExercice) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("review_exercices",
		"idreview",
		"idexercice",
		"kind",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdReview, item.IdExercice, item.Kind)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ReviewExercice from the database.
// Only the foreign keys IdReview, IdExercice fields are used in 'item'.
func (item ReviewExercice) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM review_exercices WHERE IdReview = $1 AND IdExercice = $2;`, item.IdReview, item.IdExercice)
	return err
}

// ByIdReview returns a map with 'IdReview' as keys.
func (items ReviewExercices) ByIdReview() map[IdReview]ReviewExercice {
	out := make(map[IdReview]ReviewExercice, len(items))
	for _, target := range items {
		out[target.IdReview] = target
	}
	return out
}

// IdReviews returns the list of ids of IdReview
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReviewExercices) IdReviews() []IdReview {
	out := make([]IdReview, len(items))
	for index, target := range items {
		out[index] = target.IdReview
	}
	return out
}

// SelectReviewExerciceByIdReview return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReviewExerciceByIdReview(tx DB, idReview IdReview) (item ReviewExercice, found bool, err error) {
	row := tx.QueryRow("SELECT idreview, idexercice, kind FROM review_exercices WHERE idreview = $1", idReview)
	item, err = ScanReviewExercice(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectReviewExercicesByIdReviews(tx DB, idReviews_ ...IdReview) (ReviewExercices, error) {
	rows, err := tx.Query("SELECT idreview, idexercice, kind FROM review_exercices WHERE idreview = ANY($1)", IdReviewArrayToPQ(idReviews_))
	if err != nil {
		return nil, err
	}
	return ScanReviewExercices(rows)
}

func DeleteReviewExercicesByIdReviews(tx DB, idReviews_ ...IdReview) (ReviewExercices, error) {
	rows, err := tx.Query("DELETE FROM review_exercices WHERE idreview = ANY($1) RETURNING idreview, idexercice, kind", IdReviewArrayToPQ(idReviews_))
	if err != nil {
		return nil, err
	}
	return ScanReviewExercices(rows)
}

// ByIdExercice returns a map with 'IdExercice' as keys.
func (items ReviewExercices) ByIdExercice() map[editor.IdExercicegroup]ReviewExercice {
	out := make(map[editor.IdExercicegroup]ReviewExercice, len(items))
	for _, target := range items {
		out[target.IdExercice] = target
	}
	return out
}

// IdExercices returns the list of ids of IdExercice
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReviewExercices) IdExercices() []editor.IdExercicegroup {
	out := make([]editor.IdExercicegroup, len(items))
	for index, target := range items {
		out[index] = target.IdExercice
	}
	return out
}

// SelectReviewExerciceByIdExercice return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReviewExerciceByIdExercice(tx DB, idExercice editor.IdExercicegroup) (item ReviewExercice, found bool, err error) {
	row := tx.QueryRow("SELECT idreview, idexercice, kind FROM review_exercices WHERE idexercice = $1", idExercice)
	item, err = ScanReviewExercice(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectReviewExercicesByIdExercices(tx DB, idExercices_ ...editor.IdExercicegroup) (ReviewExercices, error) {
	rows, err := tx.Query("SELECT idreview, idexercice, kind FROM review_exercices WHERE idexercice = ANY($1)", editor.IdExercicegroupArrayToPQ(idExercices_))
	if err != nil {
		return nil, err
	}
	return ScanReviewExercices(rows)
}

func DeleteReviewExercicesByIdExercices(tx DB, idExercices_ ...editor.IdExercicegroup) (ReviewExercices, error) {
	rows, err := tx.Query("DELETE FROM review_exercices WHERE idexercice = ANY($1) RETURNING idreview, idexercice, kind", editor.IdExercicegroupArrayToPQ(idExercices_))
	if err != nil {
		return nil, err
	}
	return ScanReviewExercices(rows)
}

func scanOneReviewParticipation(row scanner) (ReviewParticipation, error) {
	var item ReviewParticipation
	err := row.Scan(
		&item.IdReview,
		&item.IdTeacher,
		&item.Approval,
		&item.Comments,
	)
	return item, err
}

func ScanReviewParticipation(row *sql.Row) (ReviewParticipation, error) {
	return scanOneReviewParticipation(row)
}

// SelectAll returns all the items in the review_participations table.
func SelectAllReviewParticipations(db DB) (ReviewParticipations, error) {
	rows, err := db.Query("SELECT idreview, idteacher, approval, comments FROM review_participations")
	if err != nil {
		return nil, err
	}
	return ScanReviewParticipations(rows)
}

type ReviewParticipations []ReviewParticipation

func ScanReviewParticipations(rs *sql.Rows) (ReviewParticipations, error) {
	var (
		item ReviewParticipation
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ReviewParticipations, 0, 16)
	for rs.Next() {
		item, err = scanOneReviewParticipation(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item ReviewParticipation) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO review_participations (
			idreview, idteacher, approval, comments
			) VALUES (
			$1, $2, $3, $4
			);
			`, item.IdReview, item.IdTeacher, item.Approval, item.Comments)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links ReviewParticipation in the database.
// It is a no-op if 'items' is empty.
func InsertManyReviewParticipations(tx *sql.Tx, items ...ReviewParticipation) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("review_participations",
		"idreview",
		"idteacher",
		"approval",
		"comments",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdReview, item.IdTeacher, item.Approval, item.Comments)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ReviewParticipation from the database.
// Only the foreign keys IdReview, IdTeacher fields are used in 'item'.
func (item ReviewParticipation) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM review_participations WHERE IdReview = $1 AND IdTeacher = $2;`, item.IdReview, item.IdTeacher)
	return err
}

// ByIdReview returns a map with 'IdReview' as keys.
func (items ReviewParticipations) ByIdReview() map[IdReview]ReviewParticipations {
	out := make(map[IdReview]ReviewParticipations)
	for _, target := range items {
		out[target.IdReview] = append(out[target.IdReview], target)
	}
	return out
}

// IdReviews returns the list of ids of IdReview
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReviewParticipations) IdReviews() []IdReview {
	out := make([]IdReview, len(items))
	for index, target := range items {
		out[index] = target.IdReview
	}
	return out
}

func SelectReviewParticipationsByIdReviews(tx DB, idReviews_ ...IdReview) (ReviewParticipations, error) {
	rows, err := tx.Query("SELECT idreview, idteacher, approval, comments FROM review_participations WHERE idreview = ANY($1)", IdReviewArrayToPQ(idReviews_))
	if err != nil {
		return nil, err
	}
	return ScanReviewParticipations(rows)
}

func DeleteReviewParticipationsByIdReviews(tx DB, idReviews_ ...IdReview) (ReviewParticipations, error) {
	rows, err := tx.Query("DELETE FROM review_participations WHERE idreview = ANY($1) RETURNING idreview, idteacher, approval, comments", IdReviewArrayToPQ(idReviews_))
	if err != nil {
		return nil, err
	}
	return ScanReviewParticipations(rows)
}

// ByIdTeacher returns a map with 'IdTeacher' as keys.
func (items ReviewParticipations) ByIdTeacher() map[teacher.IdTeacher]ReviewParticipations {
	out := make(map[teacher.IdTeacher]ReviewParticipations)
	for _, target := range items {
		out[target.IdTeacher] = append(out[target.IdTeacher], target)
	}
	return out
}

// IdTeachers returns the list of ids of IdTeacher
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReviewParticipations) IdTeachers() []teacher.IdTeacher {
	out := make([]teacher.IdTeacher, len(items))
	for index, target := range items {
		out[index] = target.IdTeacher
	}
	return out
}

func SelectReviewParticipationsByIdTeachers(tx DB, idTeachers_ ...teacher.IdTeacher) (ReviewParticipations, error) {
	rows, err := tx.Query("SELECT idreview, idteacher, approval, comments FROM review_participations WHERE idteacher = ANY($1)", teacher.IdTeacherArrayToPQ(idTeachers_))
	if err != nil {
		return nil, err
	}
	return ScanReviewParticipations(rows)
}

func DeleteReviewParticipationsByIdTeachers(tx DB, idTeachers_ ...teacher.IdTeacher) (ReviewParticipations, error) {
	rows, err := tx.Query("DELETE FROM review_participations WHERE idteacher = ANY($1) RETURNING idreview, idteacher, approval, comments", teacher.IdTeacherArrayToPQ(idTeachers_))
	if err != nil {
		return nil, err
	}
	return ScanReviewParticipations(rows)
}

// SelectReviewParticipationByIdReviewAndIdTeacher return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReviewParticipationByIdReviewAndIdTeacher(tx DB, idReview IdReview, idTeacher teacher.IdTeacher) (item ReviewParticipation, found bool, err error) {
	row := tx.QueryRow("SELECT idreview, idteacher, approval, comments FROM review_participations WHERE IdReview = $1 AND IdTeacher = $2", idReview, idTeacher)
	item, err = ScanReviewParticipation(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneReviewQuestion(row scanner) (ReviewQuestion, error) {
	var item ReviewQuestion
	err := row.Scan(
		&item.IdReview,
		&item.IdQuestion,
		&item.Kind,
	)
	return item, err
}

func ScanReviewQuestion(row *sql.Row) (ReviewQuestion, error) { return scanOneReviewQuestion(row) }

// SelectAll returns all the items in the review_questions table.
func SelectAllReviewQuestions(db DB) (ReviewQuestions, error) {
	rows, err := db.Query("SELECT idreview, idquestion, kind FROM review_questions")
	if err != nil {
		return nil, err
	}
	return ScanReviewQuestions(rows)
}

type ReviewQuestions []ReviewQuestion

func ScanReviewQuestions(rs *sql.Rows) (ReviewQuestions, error) {
	var (
		item ReviewQuestion
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ReviewQuestions, 0, 16)
	for rs.Next() {
		item, err = scanOneReviewQuestion(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item ReviewQuestion) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO review_questions (
			idreview, idquestion, kind
			) VALUES (
			$1, $2, $3
			);
			`, item.IdReview, item.IdQuestion, item.Kind)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links ReviewQuestion in the database.
// It is a no-op if 'items' is empty.
func InsertManyReviewQuestions(tx *sql.Tx, items ...ReviewQuestion) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("review_questions",
		"idreview",
		"idquestion",
		"kind",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdReview, item.IdQuestion, item.Kind)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ReviewQuestion from the database.
// Only the foreign keys IdReview, IdQuestion fields are used in 'item'.
func (item ReviewQuestion) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM review_questions WHERE IdReview = $1 AND IdQuestion = $2;`, item.IdReview, item.IdQuestion)
	return err
}

// ByIdReview returns a map with 'IdReview' as keys.
func (items ReviewQuestions) ByIdReview() map[IdReview]ReviewQuestion {
	out := make(map[IdReview]ReviewQuestion, len(items))
	for _, target := range items {
		out[target.IdReview] = target
	}
	return out
}

// IdReviews returns the list of ids of IdReview
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReviewQuestions) IdReviews() []IdReview {
	out := make([]IdReview, len(items))
	for index, target := range items {
		out[index] = target.IdReview
	}
	return out
}

// SelectReviewQuestionByIdReview return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReviewQuestionByIdReview(tx DB, idReview IdReview) (item ReviewQuestion, found bool, err error) {
	row := tx.QueryRow("SELECT idreview, idquestion, kind FROM review_questions WHERE idreview = $1", idReview)
	item, err = ScanReviewQuestion(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectReviewQuestionsByIdReviews(tx DB, idReviews_ ...IdReview) (ReviewQuestions, error) {
	rows, err := tx.Query("SELECT idreview, idquestion, kind FROM review_questions WHERE idreview = ANY($1)", IdReviewArrayToPQ(idReviews_))
	if err != nil {
		return nil, err
	}
	return ScanReviewQuestions(rows)
}

func DeleteReviewQuestionsByIdReviews(tx DB, idReviews_ ...IdReview) (ReviewQuestions, error) {
	rows, err := tx.Query("DELETE FROM review_questions WHERE idreview = ANY($1) RETURNING idreview, idquestion, kind", IdReviewArrayToPQ(idReviews_))
	if err != nil {
		return nil, err
	}
	return ScanReviewQuestions(rows)
}

// ByIdQuestion returns a map with 'IdQuestion' as keys.
func (items ReviewQuestions) ByIdQuestion() map[editor.IdQuestiongroup]ReviewQuestion {
	out := make(map[editor.IdQuestiongroup]ReviewQuestion, len(items))
	for _, target := range items {
		out[target.IdQuestion] = target
	}
	return out
}

// IdQuestions returns the list of ids of IdQuestion
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReviewQuestions) IdQuestions() []editor.IdQuestiongroup {
	out := make([]editor.IdQuestiongroup, len(items))
	for index, target := range items {
		out[index] = target.IdQuestion
	}
	return out
}

// SelectReviewQuestionByIdQuestion return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReviewQuestionByIdQuestion(tx DB, idQuestion editor.IdQuestiongroup) (item ReviewQuestion, found bool, err error) {
	row := tx.QueryRow("SELECT idreview, idquestion, kind FROM review_questions WHERE idquestion = $1", idQuestion)
	item, err = ScanReviewQuestion(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectReviewQuestionsByIdQuestions(tx DB, idQuestions_ ...editor.IdQuestiongroup) (ReviewQuestions, error) {
	rows, err := tx.Query("SELECT idreview, idquestion, kind FROM review_questions WHERE idquestion = ANY($1)", editor.IdQuestiongroupArrayToPQ(idQuestions_))
	if err != nil {
		return nil, err
	}
	return ScanReviewQuestions(rows)
}

func DeleteReviewQuestionsByIdQuestions(tx DB, idQuestions_ ...editor.IdQuestiongroup) (ReviewQuestions, error) {
	rows, err := tx.Query("DELETE FROM review_questions WHERE idquestion = ANY($1) RETURNING idreview, idquestion, kind", editor.IdQuestiongroupArrayToPQ(idQuestions_))
	if err != nil {
		return nil, err
	}
	return ScanReviewQuestions(rows)
}

func scanOneReviewSheet(row scanner) (ReviewSheet, error) {
	var item ReviewSheet
	err := row.Scan(
		&item.IdReview,
		&item.IdSheet,
		&item.Kind,
	)
	return item, err
}

func ScanReviewSheet(row *sql.Row) (ReviewSheet, error) { return scanOneReviewSheet(row) }

// SelectAll returns all the items in the review_sheets table.
func SelectAllReviewSheets(db DB) (ReviewSheets, error) {
	rows, err := db.Query("SELECT idreview, idsheet, kind FROM review_sheets")
	if err != nil {
		return nil, err
	}
	return ScanReviewSheets(rows)
}

type ReviewSheets []ReviewSheet

func ScanReviewSheets(rs *sql.Rows) (ReviewSheets, error) {
	var (
		item ReviewSheet
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ReviewSheets, 0, 16)
	for rs.Next() {
		item, err = scanOneReviewSheet(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item ReviewSheet) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO review_sheets (
			idreview, idsheet, kind
			) VALUES (
			$1, $2, $3
			);
			`, item.IdReview, item.IdSheet, item.Kind)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links ReviewSheet in the database.
// It is a no-op if 'items' is empty.
func InsertManyReviewSheets(tx *sql.Tx, items ...ReviewSheet) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("review_sheets",
		"idreview",
		"idsheet",
		"kind",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdReview, item.IdSheet, item.Kind)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ReviewSheet from the database.
// Only the foreign keys IdReview, IdSheet fields are used in 'item'.
func (item ReviewSheet) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM review_sheets WHERE IdReview = $1 AND IdSheet = $2;`, item.IdReview, item.IdSheet)
	return err
}

// ByIdReview returns a map with 'IdReview' as keys.
func (items ReviewSheets) ByIdReview() map[IdReview]ReviewSheet {
	out := make(map[IdReview]ReviewSheet, len(items))
	for _, target := range items {
		out[target.IdReview] = target
	}
	return out
}

// IdReviews returns the list of ids of IdReview
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReviewSheets) IdReviews() []IdReview {
	out := make([]IdReview, len(items))
	for index, target := range items {
		out[index] = target.IdReview
	}
	return out
}

// SelectReviewSheetByIdReview return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReviewSheetByIdReview(tx DB, idReview IdReview) (item ReviewSheet, found bool, err error) {
	row := tx.QueryRow("SELECT idreview, idsheet, kind FROM review_sheets WHERE idreview = $1", idReview)
	item, err = ScanReviewSheet(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectReviewSheetsByIdReviews(tx DB, idReviews_ ...IdReview) (ReviewSheets, error) {
	rows, err := tx.Query("SELECT idreview, idsheet, kind FROM review_sheets WHERE idreview = ANY($1)", IdReviewArrayToPQ(idReviews_))
	if err != nil {
		return nil, err
	}
	return ScanReviewSheets(rows)
}

func DeleteReviewSheetsByIdReviews(tx DB, idReviews_ ...IdReview) (ReviewSheets, error) {
	rows, err := tx.Query("DELETE FROM review_sheets WHERE idreview = ANY($1) RETURNING idreview, idsheet, kind", IdReviewArrayToPQ(idReviews_))
	if err != nil {
		return nil, err
	}
	return ScanReviewSheets(rows)
}

// ByIdSheet returns a map with 'IdSheet' as keys.
func (items ReviewSheets) ByIdSheet() map[homework.IdSheet]ReviewSheet {
	out := make(map[homework.IdSheet]ReviewSheet, len(items))
	for _, target := range items {
		out[target.IdSheet] = target
	}
	return out
}

// IdSheets returns the list of ids of IdSheet
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReviewSheets) IdSheets() []homework.IdSheet {
	out := make([]homework.IdSheet, len(items))
	for index, target := range items {
		out[index] = target.IdSheet
	}
	return out
}

// SelectReviewSheetByIdSheet return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReviewSheetByIdSheet(tx DB, idSheet homework.IdSheet) (item ReviewSheet, found bool, err error) {
	row := tx.QueryRow("SELECT idreview, idsheet, kind FROM review_sheets WHERE idsheet = $1", idSheet)
	item, err = ScanReviewSheet(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectReviewSheetsByIdSheets(tx DB, idSheets_ ...homework.IdSheet) (ReviewSheets, error) {
	rows, err := tx.Query("SELECT idreview, idsheet, kind FROM review_sheets WHERE idsheet = ANY($1)", homework.IdSheetArrayToPQ(idSheets_))
	if err != nil {
		return nil, err
	}
	return ScanReviewSheets(rows)
}

func DeleteReviewSheetsByIdSheets(tx DB, idSheets_ ...homework.IdSheet) (ReviewSheets, error) {
	rows, err := tx.Query("DELETE FROM review_sheets WHERE idsheet = ANY($1) RETURNING idreview, idsheet, kind", homework.IdSheetArrayToPQ(idSheets_))
	if err != nil {
		return nil, err
	}
	return ScanReviewSheets(rows)
}

func scanOneReviewTrivial(row scanner) (ReviewTrivial, error) {
	var item ReviewTrivial
	err := row.Scan(
		&item.IdReview,
		&item.IdTrivial,
		&item.Kind,
	)
	return item, err
}

func ScanReviewTrivial(row *sql.Row) (ReviewTrivial, error) { return scanOneReviewTrivial(row) }

// SelectAll returns all the items in the review_trivials table.
func SelectAllReviewTrivials(db DB) (ReviewTrivials, error) {
	rows, err := db.Query("SELECT idreview, idtrivial, kind FROM review_trivials")
	if err != nil {
		return nil, err
	}
	return ScanReviewTrivials(rows)
}

type ReviewTrivials []ReviewTrivial

func ScanReviewTrivials(rs *sql.Rows) (ReviewTrivials, error) {
	var (
		item ReviewTrivial
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ReviewTrivials, 0, 16)
	for rs.Next() {
		item, err = scanOneReviewTrivial(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item ReviewTrivial) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO review_trivials (
			idreview, idtrivial, kind
			) VALUES (
			$1, $2, $3
			);
			`, item.IdReview, item.IdTrivial, item.Kind)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links ReviewTrivial in the database.
// It is a no-op if 'items' is empty.
func InsertManyReviewTrivials(tx *sql.Tx, items ...ReviewTrivial) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("review_trivials",
		"idreview",
		"idtrivial",
		"kind",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdReview, item.IdTrivial, item.Kind)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ReviewTrivial from the database.
// Only the foreign keys IdReview, IdTrivial fields are used in 'item'.
func (item ReviewTrivial) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM review_trivials WHERE IdReview = $1 AND IdTrivial = $2;`, item.IdReview, item.IdTrivial)
	return err
}

// ByIdReview returns a map with 'IdReview' as keys.
func (items ReviewTrivials) ByIdReview() map[IdReview]ReviewTrivial {
	out := make(map[IdReview]ReviewTrivial, len(items))
	for _, target := range items {
		out[target.IdReview] = target
	}
	return out
}

// IdReviews returns the list of ids of IdReview
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReviewTrivials) IdReviews() []IdReview {
	out := make([]IdReview, len(items))
	for index, target := range items {
		out[index] = target.IdReview
	}
	return out
}

// SelectReviewTrivialByIdReview return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReviewTrivialByIdReview(tx DB, idReview IdReview) (item ReviewTrivial, found bool, err error) {
	row := tx.QueryRow("SELECT idreview, idtrivial, kind FROM review_trivials WHERE idreview = $1", idReview)
	item, err = ScanReviewTrivial(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectReviewTrivialsByIdReviews(tx DB, idReviews_ ...IdReview) (ReviewTrivials, error) {
	rows, err := tx.Query("SELECT idreview, idtrivial, kind FROM review_trivials WHERE idreview = ANY($1)", IdReviewArrayToPQ(idReviews_))
	if err != nil {
		return nil, err
	}
	return ScanReviewTrivials(rows)
}

func DeleteReviewTrivialsByIdReviews(tx DB, idReviews_ ...IdReview) (ReviewTrivials, error) {
	rows, err := tx.Query("DELETE FROM review_trivials WHERE idreview = ANY($1) RETURNING idreview, idtrivial, kind", IdReviewArrayToPQ(idReviews_))
	if err != nil {
		return nil, err
	}
	return ScanReviewTrivials(rows)
}

// ByIdTrivial returns a map with 'IdTrivial' as keys.
func (items ReviewTrivials) ByIdTrivial() map[trivial.IdTrivial]ReviewTrivial {
	out := make(map[trivial.IdTrivial]ReviewTrivial, len(items))
	for _, target := range items {
		out[target.IdTrivial] = target
	}
	return out
}

// IdTrivials returns the list of ids of IdTrivial
// contained in this link table.
// They are not garanteed to be distinct.
func (items ReviewTrivials) IdTrivials() []trivial.IdTrivial {
	out := make([]trivial.IdTrivial, len(items))
	for index, target := range items {
		out[index] = target.IdTrivial
	}
	return out
}

// SelectReviewTrivialByIdTrivial return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReviewTrivialByIdTrivial(tx DB, idTrivial trivial.IdTrivial) (item ReviewTrivial, found bool, err error) {
	row := tx.QueryRow("SELECT idreview, idtrivial, kind FROM review_trivials WHERE idtrivial = $1", idTrivial)
	item, err = ScanReviewTrivial(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectReviewTrivialsByIdTrivials(tx DB, idTrivials_ ...trivial.IdTrivial) (ReviewTrivials, error) {
	rows, err := tx.Query("SELECT idreview, idtrivial, kind FROM review_trivials WHERE idtrivial = ANY($1)", trivial.IdTrivialArrayToPQ(idTrivials_))
	if err != nil {
		return nil, err
	}
	return ScanReviewTrivials(rows)
}

func DeleteReviewTrivialsByIdTrivials(tx DB, idTrivials_ ...trivial.IdTrivial) (ReviewTrivials, error) {
	rows, err := tx.Query("DELETE FROM review_trivials WHERE idtrivial = ANY($1) RETURNING idreview, idtrivial, kind", trivial.IdTrivialArrayToPQ(idTrivials_))
	if err != nil {
		return nil, err
	}
	return ScanReviewTrivials(rows)
}

// SelectReviewByIdAndKind return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectReviewByIdAndKind(tx DB, id IdReview, kind ReviewKind) (item Review, found bool, err error) {
	row := tx.QueryRow("SELECT id, kind FROM reviews WHERE Id = $1 AND Kind = $2", id, kind)
	item, err = ScanReview(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out any, src any) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s any) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func IdReviewArrayToPQ(ids []IdReview) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdReviewArray scans the result of a query returning a
// list of ID's.
func ScanIdReviewArray(rs *sql.Rows) ([]IdReview, error) {
	defer rs.Close()
	ints := make([]IdReview, 0, 16)
	var err error
	for rs.Next() {
		var s IdReview
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func (s *Comments) Scan(src any) error          { return loadJSON(s, src) }
func (s Comments) Value() (driver.Value, error) { return dumpJSON(s) }
