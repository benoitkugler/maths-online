package teacher

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"time"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...any) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...any) (sql.Result, error)
	Query(query string, args ...any) (*sql.Rows, error)
	QueryRow(query string, args ...any) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneClassroom(row scanner) (Classroom, error) {
	var item Classroom
	err := row.Scan(
		&item.Id,
		&item.IdTeacher,
		&item.Name,
		&item.MaxRankThreshold,
	)
	return item, err
}

func ScanClassroom(row *sql.Row) (Classroom, error) { return scanOneClassroom(row) }

// SelectAll returns all the items in the classrooms table.
func SelectAllClassrooms(db DB) (Classrooms, error) {
	rows, err := db.Query("SELECT id, idteacher, name, maxrankthreshold FROM classrooms")
	if err != nil {
		return nil, err
	}
	return ScanClassrooms(rows)
}

// SelectClassroom returns the entry matching 'id'.
func SelectClassroom(tx DB, id IdClassroom) (Classroom, error) {
	row := tx.QueryRow("SELECT id, idteacher, name, maxrankthreshold FROM classrooms WHERE id = $1", id)
	return ScanClassroom(row)
}

// SelectClassrooms returns the entry matching the given 'ids'.
func SelectClassrooms(tx DB, ids ...IdClassroom) (Classrooms, error) {
	rows, err := tx.Query("SELECT id, idteacher, name, maxrankthreshold FROM classrooms WHERE id = ANY($1)", IdClassroomArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanClassrooms(rows)
}

type Classrooms map[IdClassroom]Classroom

func (m Classrooms) IDs() []IdClassroom {
	out := make([]IdClassroom, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanClassrooms(rs *sql.Rows) (Classrooms, error) {
	var (
		s   Classroom
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Classrooms, 16)
	for rs.Next() {
		s, err = scanOneClassroom(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Classroom in the database and returns the item with id filled.
func (item Classroom) Insert(tx DB) (out Classroom, err error) {
	row := tx.QueryRow(`INSERT INTO classrooms (
		idteacher, name, maxrankthreshold
		) VALUES (
		$1, $2, $3
		) RETURNING id, idteacher, name, maxrankthreshold;
		`, item.IdTeacher, item.Name, item.MaxRankThreshold)
	return ScanClassroom(row)
}

// Update Classroom in the database and returns the new version.
func (item Classroom) Update(tx DB) (out Classroom, err error) {
	row := tx.QueryRow(`UPDATE classrooms SET (
		idteacher, name, maxrankthreshold
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING id, idteacher, name, maxrankthreshold;
		`, item.IdTeacher, item.Name, item.MaxRankThreshold, item.Id)
	return ScanClassroom(row)
}

// Deletes the Classroom and returns the item
func DeleteClassroomById(tx DB, id IdClassroom) (Classroom, error) {
	row := tx.QueryRow("DELETE FROM classrooms WHERE id = $1 RETURNING id, idteacher, name, maxrankthreshold;", id)
	return ScanClassroom(row)
}

// Deletes the Classroom in the database and returns the ids.
func DeleteClassroomsByIDs(tx DB, ids ...IdClassroom) ([]IdClassroom, error) {
	rows, err := tx.Query("DELETE FROM classrooms WHERE id = ANY($1) RETURNING id", IdClassroomArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdClassroomArray(rows)
}

// ByIdTeacher returns a map with 'IdTeacher' as keys.
func (items Classrooms) ByIdTeacher() map[IdTeacher]Classrooms {
	out := make(map[IdTeacher]Classrooms)
	for _, target := range items {
		dict := out[target.IdTeacher]
		if dict == nil {
			dict = make(Classrooms)
		}
		dict[target.Id] = target
		out[target.IdTeacher] = dict
	}
	return out
}

// IdTeachers returns the list of ids of IdTeacher
// contained in this table.
// They are not garanteed to be distinct.
func (items Classrooms) IdTeachers() []IdTeacher {
	out := make([]IdTeacher, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdTeacher)
	}
	return out
}

func SelectClassroomsByIdTeachers(tx DB, idTeachers_ ...IdTeacher) (Classrooms, error) {
	rows, err := tx.Query("SELECT id, idteacher, name, maxrankthreshold FROM classrooms WHERE idteacher = ANY($1)", IdTeacherArrayToPQ(idTeachers_))
	if err != nil {
		return nil, err
	}
	return ScanClassrooms(rows)
}

func DeleteClassroomsByIdTeachers(tx DB, idTeachers_ ...IdTeacher) ([]IdClassroom, error) {
	rows, err := tx.Query("DELETE FROM classrooms WHERE idteacher = ANY($1) RETURNING id", IdTeacherArrayToPQ(idTeachers_))
	if err != nil {
		return nil, err
	}
	return ScanIdClassroomArray(rows)
}

func scanOneClassroomCode(row scanner) (ClassroomCode, error) {
	var item ClassroomCode
	err := row.Scan(
		&item.IdClassroom,
		&item.Code,
		&item.ExpiresAt,
	)
	return item, err
}

func ScanClassroomCode(row *sql.Row) (ClassroomCode, error) { return scanOneClassroomCode(row) }

// SelectAll returns all the items in the classroom_codes table.
func SelectAllClassroomCodes(db DB) (ClassroomCodes, error) {
	rows, err := db.Query("SELECT idclassroom, code, expiresat FROM classroom_codes")
	if err != nil {
		return nil, err
	}
	return ScanClassroomCodes(rows)
}

type ClassroomCodes []ClassroomCode

func ScanClassroomCodes(rs *sql.Rows) (ClassroomCodes, error) {
	var (
		item ClassroomCode
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ClassroomCodes, 0, 16)
	for rs.Next() {
		item, err = scanOneClassroomCode(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item ClassroomCode) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO classroom_codes (
			idclassroom, code, expiresat
			) VALUES (
			$1, $2, $3
			);
			`, item.IdClassroom, item.Code, item.ExpiresAt)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links ClassroomCode in the database.
// It is a no-op if 'items' is empty.
func InsertManyClassroomCodes(tx *sql.Tx, items ...ClassroomCode) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("classroom_codes",
		"idclassroom",
		"code",
		"expiresat",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdClassroom, item.Code, item.ExpiresAt)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ClassroomCode from the database.
// Only the foreign keys IdClassroom fields are used in 'item'.
func (item ClassroomCode) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM classroom_codes WHERE IdClassroom = $1;`, item.IdClassroom)
	return err
}

// ByIdClassroom returns a map with 'IdClassroom' as keys.
func (items ClassroomCodes) ByIdClassroom() map[IdClassroom]ClassroomCodes {
	out := make(map[IdClassroom]ClassroomCodes)
	for _, target := range items {
		out[target.IdClassroom] = append(out[target.IdClassroom], target)
	}
	return out
}

// IdClassrooms returns the list of ids of IdClassroom
// contained in this link table.
// They are not garanteed to be distinct.
func (items ClassroomCodes) IdClassrooms() []IdClassroom {
	out := make([]IdClassroom, len(items))
	for index, target := range items {
		out[index] = target.IdClassroom
	}
	return out
}

func SelectClassroomCodesByIdClassrooms(tx DB, idClassrooms_ ...IdClassroom) (ClassroomCodes, error) {
	rows, err := tx.Query("SELECT idclassroom, code, expiresat FROM classroom_codes WHERE idclassroom = ANY($1)", IdClassroomArrayToPQ(idClassrooms_))
	if err != nil {
		return nil, err
	}
	return ScanClassroomCodes(rows)
}

func DeleteClassroomCodesByIdClassrooms(tx DB, idClassrooms_ ...IdClassroom) (ClassroomCodes, error) {
	rows, err := tx.Query("DELETE FROM classroom_codes WHERE idclassroom = ANY($1) RETURNING idclassroom, code, expiresat", IdClassroomArrayToPQ(idClassrooms_))
	if err != nil {
		return nil, err
	}
	return ScanClassroomCodes(rows)
}

// SelectClassroomCodeByCode return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectClassroomCodeByCode(tx DB, code string) (item ClassroomCode, found bool, err error) {
	row := tx.QueryRow("SELECT idclassroom, code, expiresat FROM classroom_codes WHERE Code = $1", code)
	item, err = ScanClassroomCode(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

// SelectClassroomByIdAndIdTeacher return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectClassroomByIdAndIdTeacher(tx DB, id IdClassroom, idTeacher IdTeacher) (item Classroom, found bool, err error) {
	row := tx.QueryRow("SELECT id, idteacher, name, maxrankthreshold FROM classrooms WHERE Id = $1 AND IdTeacher = $2", id, idTeacher)
	item, err = ScanClassroom(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneStudent(row scanner) (Student, error) {
	var item Student
	err := row.Scan(
		&item.Id,
		&item.Name,
		&item.Surname,
		&item.Birthday,
		&item.IdClassroom,
		&item.Clients,
	)
	return item, err
}

func ScanStudent(row *sql.Row) (Student, error) { return scanOneStudent(row) }

// SelectAll returns all the items in the students table.
func SelectAllStudents(db DB) (Students, error) {
	rows, err := db.Query("SELECT id, name, surname, birthday, idclassroom, clients FROM students")
	if err != nil {
		return nil, err
	}
	return ScanStudents(rows)
}

// SelectStudent returns the entry matching 'id'.
func SelectStudent(tx DB, id IdStudent) (Student, error) {
	row := tx.QueryRow("SELECT id, name, surname, birthday, idclassroom, clients FROM students WHERE id = $1", id)
	return ScanStudent(row)
}

// SelectStudents returns the entry matching the given 'ids'.
func SelectStudents(tx DB, ids ...IdStudent) (Students, error) {
	rows, err := tx.Query("SELECT id, name, surname, birthday, idclassroom, clients FROM students WHERE id = ANY($1)", IdStudentArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanStudents(rows)
}

type Students map[IdStudent]Student

func (m Students) IDs() []IdStudent {
	out := make([]IdStudent, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanStudents(rs *sql.Rows) (Students, error) {
	var (
		s   Student
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Students, 16)
	for rs.Next() {
		s, err = scanOneStudent(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Student in the database and returns the item with id filled.
func (item Student) Insert(tx DB) (out Student, err error) {
	row := tx.QueryRow(`INSERT INTO students (
		name, surname, birthday, idclassroom, clients
		) VALUES (
		$1, $2, $3, $4, $5
		) RETURNING id, name, surname, birthday, idclassroom, clients;
		`, item.Name, item.Surname, item.Birthday, item.IdClassroom, item.Clients)
	return ScanStudent(row)
}

// Update Student in the database and returns the new version.
func (item Student) Update(tx DB) (out Student, err error) {
	row := tx.QueryRow(`UPDATE students SET (
		name, surname, birthday, idclassroom, clients
		) = (
		$1, $2, $3, $4, $5
		) WHERE id = $6 RETURNING id, name, surname, birthday, idclassroom, clients;
		`, item.Name, item.Surname, item.Birthday, item.IdClassroom, item.Clients, item.Id)
	return ScanStudent(row)
}

// Deletes the Student and returns the item
func DeleteStudentById(tx DB, id IdStudent) (Student, error) {
	row := tx.QueryRow("DELETE FROM students WHERE id = $1 RETURNING id, name, surname, birthday, idclassroom, clients;", id)
	return ScanStudent(row)
}

// Deletes the Student in the database and returns the ids.
func DeleteStudentsByIDs(tx DB, ids ...IdStudent) ([]IdStudent, error) {
	rows, err := tx.Query("DELETE FROM students WHERE id = ANY($1) RETURNING id", IdStudentArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdStudentArray(rows)
}

// ByIdClassroom returns a map with 'IdClassroom' as keys.
func (items Students) ByIdClassroom() map[IdClassroom]Students {
	out := make(map[IdClassroom]Students)
	for _, target := range items {
		dict := out[target.IdClassroom]
		if dict == nil {
			dict = make(Students)
		}
		dict[target.Id] = target
		out[target.IdClassroom] = dict
	}
	return out
}

// IdClassrooms returns the list of ids of IdClassroom
// contained in this table.
// They are not garanteed to be distinct.
func (items Students) IdClassrooms() []IdClassroom {
	out := make([]IdClassroom, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdClassroom)
	}
	return out
}

func SelectStudentsByIdClassrooms(tx DB, idClassrooms_ ...IdClassroom) (Students, error) {
	rows, err := tx.Query("SELECT id, name, surname, birthday, idclassroom, clients FROM students WHERE idclassroom = ANY($1)", IdClassroomArrayToPQ(idClassrooms_))
	if err != nil {
		return nil, err
	}
	return ScanStudents(rows)
}

func DeleteStudentsByIdClassrooms(tx DB, idClassrooms_ ...IdClassroom) ([]IdStudent, error) {
	rows, err := tx.Query("DELETE FROM students WHERE idclassroom = ANY($1) RETURNING id", IdClassroomArrayToPQ(idClassrooms_))
	if err != nil {
		return nil, err
	}
	return ScanIdStudentArray(rows)
}

func scanOneTeacher(row scanner) (Teacher, error) {
	var item Teacher
	err := row.Scan(
		&item.Id,
		&item.Mail,
		&item.PasswordCrypted,
		&item.IsAdmin,
		&item.HasSimplifiedEditor,
		&item.Contact,
		&item.FavoriteMatiere,
	)
	return item, err
}

func ScanTeacher(row *sql.Row) (Teacher, error) { return scanOneTeacher(row) }

// SelectAll returns all the items in the teachers table.
func SelectAllTeachers(db DB) (Teachers, error) {
	rows, err := db.Query("SELECT id, mail, passwordcrypted, isadmin, hassimplifiededitor, contact, favoritematiere FROM teachers")
	if err != nil {
		return nil, err
	}
	return ScanTeachers(rows)
}

// SelectTeacher returns the entry matching 'id'.
func SelectTeacher(tx DB, id IdTeacher) (Teacher, error) {
	row := tx.QueryRow("SELECT id, mail, passwordcrypted, isadmin, hassimplifiededitor, contact, favoritematiere FROM teachers WHERE id = $1", id)
	return ScanTeacher(row)
}

// SelectTeachers returns the entry matching the given 'ids'.
func SelectTeachers(tx DB, ids ...IdTeacher) (Teachers, error) {
	rows, err := tx.Query("SELECT id, mail, passwordcrypted, isadmin, hassimplifiededitor, contact, favoritematiere FROM teachers WHERE id = ANY($1)", IdTeacherArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanTeachers(rows)
}

type Teachers map[IdTeacher]Teacher

func (m Teachers) IDs() []IdTeacher {
	out := make([]IdTeacher, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanTeachers(rs *sql.Rows) (Teachers, error) {
	var (
		s   Teacher
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Teachers, 16)
	for rs.Next() {
		s, err = scanOneTeacher(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Teacher in the database and returns the item with id filled.
func (item Teacher) Insert(tx DB) (out Teacher, err error) {
	row := tx.QueryRow(`INSERT INTO teachers (
		mail, passwordcrypted, isadmin, hassimplifiededitor, contact, favoritematiere
		) VALUES (
		$1, $2, $3, $4, $5, $6
		) RETURNING id, mail, passwordcrypted, isadmin, hassimplifiededitor, contact, favoritematiere;
		`, item.Mail, item.PasswordCrypted, item.IsAdmin, item.HasSimplifiedEditor, item.Contact, item.FavoriteMatiere)
	return ScanTeacher(row)
}

// Update Teacher in the database and returns the new version.
func (item Teacher) Update(tx DB) (out Teacher, err error) {
	row := tx.QueryRow(`UPDATE teachers SET (
		mail, passwordcrypted, isadmin, hassimplifiededitor, contact, favoritematiere
		) = (
		$1, $2, $3, $4, $5, $6
		) WHERE id = $7 RETURNING id, mail, passwordcrypted, isadmin, hassimplifiededitor, contact, favoritematiere;
		`, item.Mail, item.PasswordCrypted, item.IsAdmin, item.HasSimplifiedEditor, item.Contact, item.FavoriteMatiere, item.Id)
	return ScanTeacher(row)
}

// Deletes the Teacher and returns the item
func DeleteTeacherById(tx DB, id IdTeacher) (Teacher, error) {
	row := tx.QueryRow("DELETE FROM teachers WHERE id = $1 RETURNING id, mail, passwordcrypted, isadmin, hassimplifiededitor, contact, favoritematiere;", id)
	return ScanTeacher(row)
}

// Deletes the Teacher in the database and returns the ids.
func DeleteTeachersByIDs(tx DB, ids ...IdTeacher) ([]IdTeacher, error) {
	rows, err := tx.Query("DELETE FROM teachers WHERE id = ANY($1) RETURNING id", IdTeacherArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdTeacherArray(rows)
}

// SelectTeacherByMail return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectTeacherByMail(tx DB, mail string) (item Teacher, found bool, err error) {
	row := tx.QueryRow("SELECT id, mail, passwordcrypted, isadmin, hassimplifiededitor, contact, favoritematiere FROM teachers WHERE Mail = $1", mail)
	item, err = ScanTeacher(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out any, src any) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s any) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func (s *Date) Scan(src any) error {
	var tmp pq.NullTime
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = NewDateFrom(tmp.Time)
	return nil
}

func (s Date) Value() (driver.Value, error) {
	return pq.NullTime{Time: s.Time(), Valid: true}.Value()
}

func (s *Time) Scan(src any) error {
	var tmp pq.NullTime
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = Time(tmp.Time)
	return nil
}

func (s Time) Value() (driver.Value, error) {
	return pq.NullTime{Time: time.Time(s), Valid: true}.Value()
}

func IdClassroomArrayToPQ(ids []IdClassroom) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdClassroomArray scans the result of a query returning a
// list of ID's.
func ScanIdClassroomArray(rs *sql.Rows) ([]IdClassroom, error) {
	defer rs.Close()
	ints := make([]IdClassroom, 0, 16)
	var err error
	for rs.Next() {
		var s IdClassroom
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func IdStudentArrayToPQ(ids []IdStudent) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdStudentArray scans the result of a query returning a
// list of ID's.
func ScanIdStudentArray(rs *sql.Rows) ([]IdStudent, error) {
	defer rs.Close()
	ints := make([]IdStudent, 0, 16)
	var err error
	for rs.Next() {
		var s IdStudent
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func IdTeacherArrayToPQ(ids []IdTeacher) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdTeacherArray scans the result of a query returning a
// list of ID's.
func ScanIdTeacherArray(rs *sql.Rows) ([]IdTeacher, error) {
	defer rs.Close()
	ints := make([]IdTeacher, 0, 16)
	var err error
	for rs.Next() {
		var s IdTeacher
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

func (s *Clients) Scan(src any) error          { return loadJSON(s, src) }
func (s Clients) Value() (driver.Value, error) { return dumpJSON(s) }

func (s *Contact) Scan(src any) error          { return loadJSON(s, src) }
func (s Contact) Value() (driver.Value, error) { return dumpJSON(s) }
