package homework

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"time"

	"github.com/benoitkugler/maths-online/server/src/sql/tasks"
	"github.com/benoitkugler/maths-online/server/src/sql/teacher"
	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneSheet(row scanner) (Sheet, error) {
	var item Sheet
	err := row.Scan(
		&item.Id,
		&item.Title,
		&item.IdTeacher,
		&item.Level,
		&item.Anonymous,
		&item.Public,
	)
	return item, err
}

func ScanSheet(row *sql.Row) (Sheet, error) { return scanOneSheet(row) }

// SelectAll returns all the items in the sheets table.
func SelectAllSheets(db DB) (Sheets, error) {
	rows, err := db.Query("SELECT * FROM sheets")
	if err != nil {
		return nil, err
	}
	return ScanSheets(rows)
}

// SelectSheet returns the entry matching 'id'.
func SelectSheet(tx DB, id IdSheet) (Sheet, error) {
	row := tx.QueryRow("SELECT * FROM sheets WHERE id = $1", id)
	return ScanSheet(row)
}

// SelectSheets returns the entry matching the given 'ids'.
func SelectSheets(tx DB, ids ...IdSheet) (Sheets, error) {
	rows, err := tx.Query("SELECT * FROM sheets WHERE id = ANY($1)", IdSheetArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanSheets(rows)
}

type Sheets map[IdSheet]Sheet

func (m Sheets) IDs() []IdSheet {
	out := make([]IdSheet, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanSheets(rs *sql.Rows) (Sheets, error) {
	var (
		s   Sheet
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Sheets, 16)
	for rs.Next() {
		s, err = scanOneSheet(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Sheet in the database and returns the item with id filled.
func (item Sheet) Insert(tx DB) (out Sheet, err error) {
	row := tx.QueryRow(`INSERT INTO sheets (
		title, idteacher, level, anonymous, public
		) VALUES (
		$1, $2, $3, $4, $5
		) RETURNING *;
		`, item.Title, item.IdTeacher, item.Level, item.Anonymous, item.Public)
	return ScanSheet(row)
}

// Update Sheet in the database and returns the new version.
func (item Sheet) Update(tx DB) (out Sheet, err error) {
	row := tx.QueryRow(`UPDATE sheets SET (
		title, idteacher, level, anonymous, public
		) = (
		$1, $2, $3, $4, $5
		) WHERE id = $6 RETURNING *;
		`, item.Title, item.IdTeacher, item.Level, item.Anonymous, item.Public, item.Id)
	return ScanSheet(row)
}

// Deletes the Sheet and returns the item
func DeleteSheetById(tx DB, id IdSheet) (Sheet, error) {
	row := tx.QueryRow("DELETE FROM sheets WHERE id = $1 RETURNING *;", id)
	return ScanSheet(row)
}

// Deletes the Sheet in the database and returns the ids.
func DeleteSheetsByIDs(tx DB, ids ...IdSheet) ([]IdSheet, error) {
	rows, err := tx.Query("DELETE FROM sheets WHERE id = ANY($1) RETURNING id", IdSheetArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdSheetArray(rows)
}

// ByIdTeacher returns a map with 'IdTeacher' as keys.
func (items Sheets) ByIdTeacher() map[teacher.IdTeacher]Sheets {
	out := make(map[teacher.IdTeacher]Sheets)
	for _, target := range items {
		dict := out[target.IdTeacher]
		if dict == nil {
			dict = make(Sheets)
		}
		dict[target.Id] = target
		out[target.IdTeacher] = dict
	}
	return out
}

// IdTeachers returns the list of ids of IdTeacher
// contained in this table.
// They are not garanteed to be distinct.
func (items Sheets) IdTeachers() []teacher.IdTeacher {
	out := make([]teacher.IdTeacher, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdTeacher)
	}
	return out
}

func SelectSheetsByIdTeachers(tx DB, idTeachers_ ...teacher.IdTeacher) (Sheets, error) {
	rows, err := tx.Query("SELECT * FROM sheets WHERE idteacher = ANY($1)", teacher.IdTeacherArrayToPQ(idTeachers_))
	if err != nil {
		return nil, err
	}
	return ScanSheets(rows)
}

func DeleteSheetsByIdTeachers(tx DB, idTeachers_ ...teacher.IdTeacher) ([]IdSheet, error) {
	rows, err := tx.Query("DELETE FROM sheets WHERE idteacher = ANY($1) RETURNING id", teacher.IdTeacherArrayToPQ(idTeachers_))
	if err != nil {
		return nil, err
	}
	return ScanIdSheetArray(rows)
}

func SelectSheetsByAnonymouss(tx DB, anonymouss_ ...IdTravail) (Sheets, error) {
	rows, err := tx.Query("SELECT * FROM sheets WHERE anonymous = ANY($1)", IdTravailArrayToPQ(anonymouss_))
	if err != nil {
		return nil, err
	}
	return ScanSheets(rows)
}

func DeleteSheetsByAnonymouss(tx DB, anonymouss_ ...IdTravail) ([]IdSheet, error) {
	rows, err := tx.Query("DELETE FROM sheets WHERE anonymous = ANY($1) RETURNING id", IdTravailArrayToPQ(anonymouss_))
	if err != nil {
		return nil, err
	}
	return ScanIdSheetArray(rows)
}

func scanOneSheetTask(row scanner) (SheetTask, error) {
	var item SheetTask
	err := row.Scan(
		&item.IdSheet,
		&item.Index,
		&item.IdTask,
	)
	return item, err
}

func ScanSheetTask(row *sql.Row) (SheetTask, error) { return scanOneSheetTask(row) }

// SelectAll returns all the items in the sheet_tasks table.
func SelectAllSheetTasks(db DB) (SheetTasks, error) {
	rows, err := db.Query("SELECT * FROM sheet_tasks")
	if err != nil {
		return nil, err
	}
	return ScanSheetTasks(rows)
}

type SheetTasks []SheetTask

func ScanSheetTasks(rs *sql.Rows) (SheetTasks, error) {
	var (
		item SheetTask
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(SheetTasks, 0, 16)
	for rs.Next() {
		item, err = scanOneSheetTask(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links SheetTask in the database.
// It is a no-op if 'items' is empty.
func InsertManySheetTasks(tx *sql.Tx, items ...SheetTask) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("sheet_tasks",
		"idsheet",
		"index",
		"idtask",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdSheet, item.Index, item.IdTask)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link SheetTask from the database.
// Only the foreign keys IdSheet, IdTask fields are used in 'item'.
func (item SheetTask) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM sheet_tasks WHERE IdSheet = $1 AND IdTask = $2;`, item.IdSheet, item.IdTask)
	return err
}

// ByIdSheet returns a map with 'IdSheet' as keys.
func (items SheetTasks) ByIdSheet() map[IdSheet]SheetTasks {
	out := make(map[IdSheet]SheetTasks)
	for _, target := range items {
		out[target.IdSheet] = append(out[target.IdSheet], target)
	}
	return out
}

// IdSheets returns the list of ids of IdSheet
// contained in this link table.
// They are not garanteed to be distinct.
func (items SheetTasks) IdSheets() []IdSheet {
	out := make([]IdSheet, len(items))
	for index, target := range items {
		out[index] = target.IdSheet
	}
	return out
}

func SelectSheetTasksByIdSheets(tx DB, idSheets_ ...IdSheet) (SheetTasks, error) {
	rows, err := tx.Query("SELECT * FROM sheet_tasks WHERE idsheet = ANY($1)", IdSheetArrayToPQ(idSheets_))
	if err != nil {
		return nil, err
	}
	return ScanSheetTasks(rows)
}

func DeleteSheetTasksByIdSheets(tx DB, idSheets_ ...IdSheet) (SheetTasks, error) {
	rows, err := tx.Query("DELETE FROM sheet_tasks WHERE idsheet = ANY($1) RETURNING *", IdSheetArrayToPQ(idSheets_))
	if err != nil {
		return nil, err
	}
	return ScanSheetTasks(rows)
}

// ByIdTask returns a map with 'IdTask' as keys.
func (items SheetTasks) ByIdTask() map[tasks.IdTask]SheetTask {
	out := make(map[tasks.IdTask]SheetTask, len(items))
	for _, target := range items {
		out[target.IdTask] = target
	}
	return out
}

// IdTasks returns the list of ids of IdTask
// contained in this link table.
// They are not garanteed to be distinct.
func (items SheetTasks) IdTasks() []tasks.IdTask {
	out := make([]tasks.IdTask, len(items))
	for index, target := range items {
		out[index] = target.IdTask
	}
	return out
}

// SelectSheetTaskByIdTask return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectSheetTaskByIdTask(tx DB, idTask tasks.IdTask) (item SheetTask, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM sheet_tasks WHERE idtask = $1", idTask)
	item, err = ScanSheetTask(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func SelectSheetTasksByIdTasks(tx DB, idTasks_ ...tasks.IdTask) (SheetTasks, error) {
	rows, err := tx.Query("SELECT * FROM sheet_tasks WHERE idtask = ANY($1)", tasks.IdTaskArrayToPQ(idTasks_))
	if err != nil {
		return nil, err
	}
	return ScanSheetTasks(rows)
}

func DeleteSheetTasksByIdTasks(tx DB, idTasks_ ...tasks.IdTask) (SheetTasks, error) {
	rows, err := tx.Query("DELETE FROM sheet_tasks WHERE idtask = ANY($1) RETURNING *", tasks.IdTaskArrayToPQ(idTasks_))
	if err != nil {
		return nil, err
	}
	return ScanSheetTasks(rows)
}

// SelectSheetTaskByIdSheetAndIndex return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectSheetTaskByIdSheetAndIndex(tx DB, idSheet IdSheet, index int) (item SheetTask, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM sheet_tasks WHERE IdSheet = $1 AND Index = $2", idSheet, index)
	item, err = ScanSheetTask(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneTravail(row scanner) (Travail, error) {
	var item Travail
	err := row.Scan(
		&item.Id,
		&item.IdClassroom,
		&item.IdSheet,
		&item.Noted,
		&item.Deadline,
	)
	return item, err
}

func ScanTravail(row *sql.Row) (Travail, error) { return scanOneTravail(row) }

// SelectAll returns all the items in the travails table.
func SelectAllTravails(db DB) (Travails, error) {
	rows, err := db.Query("SELECT * FROM travails")
	if err != nil {
		return nil, err
	}
	return ScanTravails(rows)
}

// SelectTravail returns the entry matching 'id'.
func SelectTravail(tx DB, id IdTravail) (Travail, error) {
	row := tx.QueryRow("SELECT * FROM travails WHERE id = $1", id)
	return ScanTravail(row)
}

// SelectTravails returns the entry matching the given 'ids'.
func SelectTravails(tx DB, ids ...IdTravail) (Travails, error) {
	rows, err := tx.Query("SELECT * FROM travails WHERE id = ANY($1)", IdTravailArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanTravails(rows)
}

type Travails map[IdTravail]Travail

func (m Travails) IDs() []IdTravail {
	out := make([]IdTravail, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanTravails(rs *sql.Rows) (Travails, error) {
	var (
		s   Travail
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Travails, 16)
	for rs.Next() {
		s, err = scanOneTravail(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Travail in the database and returns the item with id filled.
func (item Travail) Insert(tx DB) (out Travail, err error) {
	row := tx.QueryRow(`INSERT INTO travails (
		idclassroom, idsheet, noted, deadline
		) VALUES (
		$1, $2, $3, $4
		) RETURNING *;
		`, item.IdClassroom, item.IdSheet, item.Noted, item.Deadline)
	return ScanTravail(row)
}

// Update Travail in the database and returns the new version.
func (item Travail) Update(tx DB) (out Travail, err error) {
	row := tx.QueryRow(`UPDATE travails SET (
		idclassroom, idsheet, noted, deadline
		) = (
		$1, $2, $3, $4
		) WHERE id = $5 RETURNING *;
		`, item.IdClassroom, item.IdSheet, item.Noted, item.Deadline, item.Id)
	return ScanTravail(row)
}

// Deletes the Travail and returns the item
func DeleteTravailById(tx DB, id IdTravail) (Travail, error) {
	row := tx.QueryRow("DELETE FROM travails WHERE id = $1 RETURNING *;", id)
	return ScanTravail(row)
}

// Deletes the Travail in the database and returns the ids.
func DeleteTravailsByIDs(tx DB, ids ...IdTravail) ([]IdTravail, error) {
	rows, err := tx.Query("DELETE FROM travails WHERE id = ANY($1) RETURNING id", IdTravailArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdTravailArray(rows)
}

// ByIdClassroom returns a map with 'IdClassroom' as keys.
func (items Travails) ByIdClassroom() map[teacher.IdClassroom]Travails {
	out := make(map[teacher.IdClassroom]Travails)
	for _, target := range items {
		dict := out[target.IdClassroom]
		if dict == nil {
			dict = make(Travails)
		}
		dict[target.Id] = target
		out[target.IdClassroom] = dict
	}
	return out
}

// IdClassrooms returns the list of ids of IdClassroom
// contained in this table.
// They are not garanteed to be distinct.
func (items Travails) IdClassrooms() []teacher.IdClassroom {
	out := make([]teacher.IdClassroom, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdClassroom)
	}
	return out
}

func SelectTravailsByIdClassrooms(tx DB, idClassrooms_ ...teacher.IdClassroom) (Travails, error) {
	rows, err := tx.Query("SELECT * FROM travails WHERE idclassroom = ANY($1)", teacher.IdClassroomArrayToPQ(idClassrooms_))
	if err != nil {
		return nil, err
	}
	return ScanTravails(rows)
}

func DeleteTravailsByIdClassrooms(tx DB, idClassrooms_ ...teacher.IdClassroom) ([]IdTravail, error) {
	rows, err := tx.Query("DELETE FROM travails WHERE idclassroom = ANY($1) RETURNING id", teacher.IdClassroomArrayToPQ(idClassrooms_))
	if err != nil {
		return nil, err
	}
	return ScanIdTravailArray(rows)
}

// ByIdSheet returns a map with 'IdSheet' as keys.
func (items Travails) ByIdSheet() map[IdSheet]Travails {
	out := make(map[IdSheet]Travails)
	for _, target := range items {
		dict := out[target.IdSheet]
		if dict == nil {
			dict = make(Travails)
		}
		dict[target.Id] = target
		out[target.IdSheet] = dict
	}
	return out
}

// IdSheets returns the list of ids of IdSheet
// contained in this table.
// They are not garanteed to be distinct.
func (items Travails) IdSheets() []IdSheet {
	out := make([]IdSheet, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdSheet)
	}
	return out
}

func SelectTravailsByIdSheets(tx DB, idSheets_ ...IdSheet) (Travails, error) {
	rows, err := tx.Query("SELECT * FROM travails WHERE idsheet = ANY($1)", IdSheetArrayToPQ(idSheets_))
	if err != nil {
		return nil, err
	}
	return ScanTravails(rows)
}

func DeleteTravailsByIdSheets(tx DB, idSheets_ ...IdSheet) ([]IdTravail, error) {
	rows, err := tx.Query("DELETE FROM travails WHERE idsheet = ANY($1) RETURNING id", IdSheetArrayToPQ(idSheets_))
	if err != nil {
		return nil, err
	}
	return ScanIdTravailArray(rows)
}

// SelectTravailByIdAndIdSheet return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectTravailByIdAndIdSheet(tx DB, id IdTravail, idSheet IdSheet) (item Travail, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM travails WHERE Id = $1 AND IdSheet = $2", id, idSheet)
	item, err = ScanTravail(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func (s *Time) Scan(src interface{}) error {
	var tmp pq.NullTime
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = Time(tmp.Time)
	return nil
}

func (s Time) Value() (driver.Value, error) {
	return pq.NullTime{Time: time.Time(s), Valid: true}.Value()
}

func IdSheetArrayToPQ(ids []IdSheet) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdSheetArray scans the result of a query returning a
// list of ID's.
func ScanIdSheetArray(rs *sql.Rows) ([]IdSheet, error) {
	defer rs.Close()
	ints := make([]IdSheet, 0, 16)
	var err error
	for rs.Next() {
		var s IdSheet
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdSheetSet map[IdSheet]bool

func NewIdSheetSetFrom(ids []IdSheet) IdSheetSet {
	out := make(IdSheetSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdSheetSet) Add(id IdSheet) { s[id] = true }

func (s IdSheetSet) Has(id IdSheet) bool { return s[id] }

func (s IdSheetSet) Keys() []IdSheet {
	out := make([]IdSheet, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdTravailArrayToPQ(ids []IdTravail) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdTravailArray scans the result of a query returning a
// list of ID's.
func ScanIdTravailArray(rs *sql.Rows) ([]IdTravail, error) {
	defer rs.Close()
	ints := make([]IdTravail, 0, 16)
	var err error
	for rs.Next() {
		var s IdTravail
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdTravailSet map[IdTravail]bool

func NewIdTravailSetFrom(ids []IdTravail) IdTravailSet {
	out := make(IdTravailSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdTravailSet) Add(id IdTravail) { s[id] = true }

func (s IdTravailSet) Has(id IdTravail) bool { return s[id] }

func (s IdTravailSet) Keys() []IdTravail {
	out := make([]IdTravail, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s *OptionalIdTravail) Scan(src interface{}) error {
	var tmp sql.NullInt64
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = OptionalIdTravail{
		Valid: tmp.Valid,
		ID:    IdTravail(tmp.Int64),
	}
	return nil
}

func (s OptionalIdTravail) Value() (driver.Value, error) {
	return sql.NullInt64{
		Int64: int64(s.ID),
		Valid: s.Valid}.Value()
}
