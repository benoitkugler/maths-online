package trivial

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"

	"github.com/benoitkugler/maths-online/server/src/sql/teacher"
	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneSelfaccessTrivial(row scanner) (SelfaccessTrivial, error) {
	var item SelfaccessTrivial
	err := row.Scan(
		&item.IdClassroom,
		&item.IdTrivial,
		&item.IdTeacher,
	)
	return item, err
}

func ScanSelfaccessTrivial(row *sql.Row) (SelfaccessTrivial, error) {
	return scanOneSelfaccessTrivial(row)
}

// SelectAll returns all the items in the selfaccess_trivials table.
func SelectAllSelfaccessTrivials(db DB) (SelfaccessTrivials, error) {
	rows, err := db.Query("SELECT * FROM selfaccess_trivials")
	if err != nil {
		return nil, err
	}
	return ScanSelfaccessTrivials(rows)
}

type SelfaccessTrivials []SelfaccessTrivial

func ScanSelfaccessTrivials(rs *sql.Rows) (SelfaccessTrivials, error) {
	var (
		item SelfaccessTrivial
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(SelfaccessTrivials, 0, 16)
	for rs.Next() {
		item, err = scanOneSelfaccessTrivial(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links SelfaccessTrivial in the database.
// It is a no-op if 'items' is empty.
func InsertManySelfaccessTrivials(tx *sql.Tx, items ...SelfaccessTrivial) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("selfaccess_trivials",
		"idclassroom",
		"idtrivial",
		"idteacher",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdClassroom, item.IdTrivial, item.IdTeacher)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link SelfaccessTrivial from the database.
// Only the foreign keys IdClassroom, IdTrivial, IdTeacher fields are used in 'item'.
func (item SelfaccessTrivial) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM selfaccess_trivials WHERE IdClassroom = $1 AND IdTrivial = $2 AND IdTeacher = $3;`, item.IdClassroom, item.IdTrivial, item.IdTeacher)
	return err
}

// ByIdClassroom returns a map with 'IdClassroom' as keys.
func (items SelfaccessTrivials) ByIdClassroom() map[teacher.IdClassroom]SelfaccessTrivials {
	out := make(map[teacher.IdClassroom]SelfaccessTrivials)
	for _, target := range items {
		out[target.IdClassroom] = append(out[target.IdClassroom], target)
	}
	return out
}

// IdClassrooms returns the list of ids of IdClassroom
// contained in this link table.
// They are not garanteed to be distinct.
func (items SelfaccessTrivials) IdClassrooms() []teacher.IdClassroom {
	out := make([]teacher.IdClassroom, len(items))
	for index, target := range items {
		out[index] = target.IdClassroom
	}
	return out
}

func SelectSelfaccessTrivialsByIdClassrooms(tx DB, idClassrooms ...teacher.IdClassroom) (SelfaccessTrivials, error) {
	rows, err := tx.Query("SELECT * FROM selfaccess_trivials WHERE idclassroom = ANY($1)", teacher.IdClassroomArrayToPQ(idClassrooms))
	if err != nil {
		return nil, err
	}
	return ScanSelfaccessTrivials(rows)
}

func DeleteSelfaccessTrivialsByIdClassrooms(tx DB, idClassrooms ...teacher.IdClassroom) (SelfaccessTrivials, error) {
	rows, err := tx.Query("DELETE FROM selfaccess_trivials WHERE idclassroom = ANY($1) RETURNING *", teacher.IdClassroomArrayToPQ(idClassrooms))
	if err != nil {
		return nil, err
	}
	return ScanSelfaccessTrivials(rows)
}

// ByIdTrivial returns a map with 'IdTrivial' as keys.
func (items SelfaccessTrivials) ByIdTrivial() map[IdTrivial]SelfaccessTrivials {
	out := make(map[IdTrivial]SelfaccessTrivials)
	for _, target := range items {
		out[target.IdTrivial] = append(out[target.IdTrivial], target)
	}
	return out
}

// IdTrivials returns the list of ids of IdTrivial
// contained in this link table.
// They are not garanteed to be distinct.
func (items SelfaccessTrivials) IdTrivials() []IdTrivial {
	out := make([]IdTrivial, len(items))
	for index, target := range items {
		out[index] = target.IdTrivial
	}
	return out
}

func SelectSelfaccessTrivialsByIdTrivials(tx DB, idTrivials ...IdTrivial) (SelfaccessTrivials, error) {
	rows, err := tx.Query("SELECT * FROM selfaccess_trivials WHERE idtrivial = ANY($1)", IdTrivialArrayToPQ(idTrivials))
	if err != nil {
		return nil, err
	}
	return ScanSelfaccessTrivials(rows)
}

func DeleteSelfaccessTrivialsByIdTrivials(tx DB, idTrivials ...IdTrivial) (SelfaccessTrivials, error) {
	rows, err := tx.Query("DELETE FROM selfaccess_trivials WHERE idtrivial = ANY($1) RETURNING *", IdTrivialArrayToPQ(idTrivials))
	if err != nil {
		return nil, err
	}
	return ScanSelfaccessTrivials(rows)
}

// ByIdTeacher returns a map with 'IdTeacher' as keys.
func (items SelfaccessTrivials) ByIdTeacher() map[teacher.IdTeacher]SelfaccessTrivials {
	out := make(map[teacher.IdTeacher]SelfaccessTrivials)
	for _, target := range items {
		out[target.IdTeacher] = append(out[target.IdTeacher], target)
	}
	return out
}

// IdTeachers returns the list of ids of IdTeacher
// contained in this link table.
// They are not garanteed to be distinct.
func (items SelfaccessTrivials) IdTeachers() []teacher.IdTeacher {
	out := make([]teacher.IdTeacher, len(items))
	for index, target := range items {
		out[index] = target.IdTeacher
	}
	return out
}

func SelectSelfaccessTrivialsByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) (SelfaccessTrivials, error) {
	rows, err := tx.Query("SELECT * FROM selfaccess_trivials WHERE idteacher = ANY($1)", teacher.IdTeacherArrayToPQ(idTeachers))
	if err != nil {
		return nil, err
	}
	return ScanSelfaccessTrivials(rows)
}

func DeleteSelfaccessTrivialsByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) (SelfaccessTrivials, error) {
	rows, err := tx.Query("DELETE FROM selfaccess_trivials WHERE idteacher = ANY($1) RETURNING *", teacher.IdTeacherArrayToPQ(idTeachers))
	if err != nil {
		return nil, err
	}
	return ScanSelfaccessTrivials(rows)
}

// SelectSelfaccessTrivialsByIdTrivialAndIdTeacher selects the items matching the given fields.
func SelectSelfaccessTrivialsByIdTrivialAndIdTeacher(tx DB, idTrivial IdTrivial, idTeacher teacher.IdTeacher) (item []SelfaccessTrivial, err error) {
	rows, err := tx.Query("SELECT * FROM selfaccess_trivials WHERE IdTrivial = $1 AND IdTeacher = $2", idTrivial, idTeacher)
	if err != nil {
		return nil, err
	}
	return ScanSelfaccessTrivials(rows)
}

// DeleteSelfaccessTrivialsByIdTrivialAndIdTeacher deletes the item matching the given fields, returning
// the deleted items.
func DeleteSelfaccessTrivialsByIdTrivialAndIdTeacher(tx DB, idTrivial IdTrivial, idTeacher teacher.IdTeacher) (item []SelfaccessTrivial, err error) {
	rows, err := tx.Query("DELETE FROM selfaccess_trivials WHERE IdTrivial = $1 AND IdTeacher = $2 RETURNING *", idTrivial, idTeacher)
	if err != nil {
		return nil, err
	}
	return ScanSelfaccessTrivials(rows)
}

func scanOneTrivial(row scanner) (Trivial, error) {
	var item Trivial
	err := row.Scan(
		&item.Id,
		&item.Questions,
		&item.QuestionTimeout,
		&item.ShowDecrassage,
		&item.Public,
		&item.IdTeacher,
		&item.Name,
	)
	return item, err
}

func ScanTrivial(row *sql.Row) (Trivial, error) { return scanOneTrivial(row) }

// SelectAll returns all the items in the trivials table.
func SelectAllTrivials(db DB) (Trivials, error) {
	rows, err := db.Query("SELECT * FROM trivials")
	if err != nil {
		return nil, err
	}
	return ScanTrivials(rows)
}

// SelectTrivial returns the entry matching 'id'.
func SelectTrivial(tx DB, id IdTrivial) (Trivial, error) {
	row := tx.QueryRow("SELECT * FROM trivials WHERE id = $1", id)
	return ScanTrivial(row)
}

// SelectTrivials returns the entry matching the given 'ids'.
func SelectTrivials(tx DB, ids ...IdTrivial) (Trivials, error) {
	rows, err := tx.Query("SELECT * FROM trivials WHERE id = ANY($1)", IdTrivialArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanTrivials(rows)
}

type Trivials map[IdTrivial]Trivial

func (m Trivials) IDs() []IdTrivial {
	out := make([]IdTrivial, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanTrivials(rs *sql.Rows) (Trivials, error) {
	var (
		s   Trivial
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Trivials, 16)
	for rs.Next() {
		s, err = scanOneTrivial(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Trivial in the database and returns the item with id filled.
func (item Trivial) Insert(tx DB) (out Trivial, err error) {
	row := tx.QueryRow(`INSERT INTO trivials (
		questions, questiontimeout, showdecrassage, public, idteacher, name
		) VALUES (
		$1, $2, $3, $4, $5, $6
		) RETURNING *;
		`, item.Questions, item.QuestionTimeout, item.ShowDecrassage, item.Public, item.IdTeacher, item.Name)
	return ScanTrivial(row)
}

// Update Trivial in the database and returns the new version.
func (item Trivial) Update(tx DB) (out Trivial, err error) {
	row := tx.QueryRow(`UPDATE trivials SET (
		questions, questiontimeout, showdecrassage, public, idteacher, name
		) = (
		$1, $2, $3, $4, $5, $6
		) WHERE id = $7 RETURNING *;
		`, item.Questions, item.QuestionTimeout, item.ShowDecrassage, item.Public, item.IdTeacher, item.Name, item.Id)
	return ScanTrivial(row)
}

// Deletes the Trivial and returns the item
func DeleteTrivialById(tx DB, id IdTrivial) (Trivial, error) {
	row := tx.QueryRow("DELETE FROM trivials WHERE id = $1 RETURNING *;", id)
	return ScanTrivial(row)
}

// Deletes the Trivial in the database and returns the ids.
func DeleteTrivialsByIDs(tx DB, ids ...IdTrivial) ([]IdTrivial, error) {
	rows, err := tx.Query("DELETE FROM trivials WHERE id = ANY($1) RETURNING id", IdTrivialArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdTrivialArray(rows)
}

// ByIdTeacher returns a map with 'IdTeacher' as keys.
func (items Trivials) ByIdTeacher() map[teacher.IdTeacher]Trivials {
	out := make(map[teacher.IdTeacher]Trivials)
	for _, target := range items {
		dict := out[target.IdTeacher]
		if dict == nil {
			dict = make(Trivials)
		}
		dict[target.Id] = target
		out[target.IdTeacher] = dict
	}
	return out
}

// IdTeachers returns the list of ids of IdTeacher
// contained in this table.
// They are not garanteed to be distinct.
func (items Trivials) IdTeachers() []teacher.IdTeacher {
	out := make([]teacher.IdTeacher, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdTeacher)
	}
	return out
}

func SelectTrivialsByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) (Trivials, error) {
	rows, err := tx.Query("SELECT * FROM trivials WHERE idteacher = ANY($1)", teacher.IdTeacherArrayToPQ(idTeachers))
	if err != nil {
		return nil, err
	}
	return ScanTrivials(rows)
}

func DeleteTrivialsByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) ([]IdTrivial, error) {
	rows, err := tx.Query("DELETE FROM trivials WHERE idteacher = ANY($1) RETURNING id", teacher.IdTeacherArrayToPQ(idTeachers))
	if err != nil {
		return nil, err
	}
	return ScanIdTrivialArray(rows)
}

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func IdTrivialArrayToPQ(ids []IdTrivial) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdTrivialArray scans the result of a query returning a
// list of ID's.
func ScanIdTrivialArray(rs *sql.Rows) ([]IdTrivial, error) {
	defer rs.Close()
	ints := make([]IdTrivial, 0, 16)
	var err error
	for rs.Next() {
		var s IdTrivial
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdTrivialSet map[IdTrivial]bool

func NewIdTrivialSetFrom(ids []IdTrivial) IdTrivialSet {
	out := make(IdTrivialSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdTrivialSet) Add(id IdTrivial) { s[id] = true }

func (s IdTrivialSet) Has(id IdTrivial) bool { return s[id] }

func (s IdTrivialSet) Keys() []IdTrivial {
	out := make([]IdTrivial, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s *CategoriesQuestions) Scan(src interface{}) error  { return loadJSON(s, src) }
func (s CategoriesQuestions) Value() (driver.Value, error) { return dumpJSON(s) }
