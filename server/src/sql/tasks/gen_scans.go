package tasks

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"

	"github.com/benoitkugler/maths-online/server/src/sql/editor"
	"github.com/benoitkugler/maths-online/server/src/sql/teacher"
	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneMonoquestion(row scanner) (Monoquestion, error) {
	var item Monoquestion
	err := row.Scan(
		&item.Id,
		&item.IdQuestion,
		&item.NbRepeat,
		&item.Bareme,
	)
	return item, err
}

func ScanMonoquestion(row *sql.Row) (Monoquestion, error) { return scanOneMonoquestion(row) }

// SelectAll returns all the items in the monoquestions table.
func SelectAllMonoquestions(db DB) (Monoquestions, error) {
	rows, err := db.Query("SELECT * FROM monoquestions")
	if err != nil {
		return nil, err
	}
	return ScanMonoquestions(rows)
}

// SelectMonoquestion returns the entry matching 'id'.
func SelectMonoquestion(tx DB, id IdMonoquestion) (Monoquestion, error) {
	row := tx.QueryRow("SELECT * FROM monoquestions WHERE id = $1", id)
	return ScanMonoquestion(row)
}

// SelectMonoquestions returns the entry matching the given 'ids'.
func SelectMonoquestions(tx DB, ids ...IdMonoquestion) (Monoquestions, error) {
	rows, err := tx.Query("SELECT * FROM monoquestions WHERE id = ANY($1)", IdMonoquestionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanMonoquestions(rows)
}

type Monoquestions map[IdMonoquestion]Monoquestion

func (m Monoquestions) IDs() []IdMonoquestion {
	out := make([]IdMonoquestion, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanMonoquestions(rs *sql.Rows) (Monoquestions, error) {
	var (
		s   Monoquestion
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Monoquestions, 16)
	for rs.Next() {
		s, err = scanOneMonoquestion(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Monoquestion in the database and returns the item with id filled.
func (item Monoquestion) Insert(tx DB) (out Monoquestion, err error) {
	row := tx.QueryRow(`INSERT INTO monoquestions (
		idquestion, nbrepeat, bareme
		) VALUES (
		$1, $2, $3
		) RETURNING *;
		`, item.IdQuestion, item.NbRepeat, item.Bareme)
	return ScanMonoquestion(row)
}

// Update Monoquestion in the database and returns the new version.
func (item Monoquestion) Update(tx DB) (out Monoquestion, err error) {
	row := tx.QueryRow(`UPDATE monoquestions SET (
		idquestion, nbrepeat, bareme
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING *;
		`, item.IdQuestion, item.NbRepeat, item.Bareme, item.Id)
	return ScanMonoquestion(row)
}

// Deletes the Monoquestion and returns the item
func DeleteMonoquestionById(tx DB, id IdMonoquestion) (Monoquestion, error) {
	row := tx.QueryRow("DELETE FROM monoquestions WHERE id = $1 RETURNING *;", id)
	return ScanMonoquestion(row)
}

// Deletes the Monoquestion in the database and returns the ids.
func DeleteMonoquestionsByIDs(tx DB, ids ...IdMonoquestion) ([]IdMonoquestion, error) {
	rows, err := tx.Query("DELETE FROM monoquestions WHERE id = ANY($1) RETURNING id", IdMonoquestionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdMonoquestionArray(rows)
}

// ByIdQuestion returns a map with 'IdQuestion' as keys.
func (items Monoquestions) ByIdQuestion() map[editor.IdQuestion]Monoquestions {
	out := make(map[editor.IdQuestion]Monoquestions)
	for _, target := range items {
		dict := out[target.IdQuestion]
		if dict == nil {
			dict = make(Monoquestions)
		}
		dict[target.Id] = target
		out[target.IdQuestion] = dict
	}
	return out
}

// IdQuestions returns the list of ids of IdQuestion
// contained in this table.
// They are not garanteed to be distinct.
func (items Monoquestions) IdQuestions() []editor.IdQuestion {
	out := make([]editor.IdQuestion, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdQuestion)
	}
	return out
}

func SelectMonoquestionsByIdQuestions(tx DB, idQuestions_ ...editor.IdQuestion) (Monoquestions, error) {
	rows, err := tx.Query("SELECT * FROM monoquestions WHERE idquestion = ANY($1)", editor.IdQuestionArrayToPQ(idQuestions_))
	if err != nil {
		return nil, err
	}
	return ScanMonoquestions(rows)
}

func DeleteMonoquestionsByIdQuestions(tx DB, idQuestions_ ...editor.IdQuestion) ([]IdMonoquestion, error) {
	rows, err := tx.Query("DELETE FROM monoquestions WHERE idquestion = ANY($1) RETURNING id", editor.IdQuestionArrayToPQ(idQuestions_))
	if err != nil {
		return nil, err
	}
	return ScanIdMonoquestionArray(rows)
}

func scanOneProgression(row scanner) (Progression, error) {
	var item Progression
	err := row.Scan(
		&item.IdStudent,
		&item.IdTask,
		&item.Index,
		&item.History,
	)
	return item, err
}

func ScanProgression(row *sql.Row) (Progression, error) { return scanOneProgression(row) }

// SelectAll returns all the items in the progressions table.
func SelectAllProgressions(db DB) (Progressions, error) {
	rows, err := db.Query("SELECT * FROM progressions")
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

type Progressions []Progression

func ScanProgressions(rs *sql.Rows) (Progressions, error) {
	var (
		item Progression
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Progressions, 0, 16)
	for rs.Next() {
		item, err = scanOneProgression(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func InsertProgression(db DB, item Progression) error {
	_, err := db.Exec(`INSERT INTO progressions (
			idstudent, idtask, index, history
			) VALUES (
			$1, $2, $3, $4
			);
			`, item.IdStudent, item.IdTask, item.Index, item.History)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links Progression in the database.
// It is a no-op if 'items' is empty.
func InsertManyProgressions(tx *sql.Tx, items ...Progression) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("progressions",
		"idstudent",
		"idtask",
		"index",
		"history",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdStudent, item.IdTask, item.Index, item.History)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Progression from the database.
// Only the foreign keys IdStudent, IdTask fields are used in 'item'.
func (item Progression) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM progressions WHERE IdStudent = $1 AND IdTask = $2;`, item.IdStudent, item.IdTask)
	return err
}

// ByIdStudent returns a map with 'IdStudent' as keys.
func (items Progressions) ByIdStudent() map[teacher.IdStudent]Progressions {
	out := make(map[teacher.IdStudent]Progressions)
	for _, target := range items {
		out[target.IdStudent] = append(out[target.IdStudent], target)
	}
	return out
}

// IdStudents returns the list of ids of IdStudent
// contained in this link table.
// They are not garanteed to be distinct.
func (items Progressions) IdStudents() []teacher.IdStudent {
	out := make([]teacher.IdStudent, len(items))
	for index, target := range items {
		out[index] = target.IdStudent
	}
	return out
}

func SelectProgressionsByIdStudents(tx DB, idStudents_ ...teacher.IdStudent) (Progressions, error) {
	rows, err := tx.Query("SELECT * FROM progressions WHERE idstudent = ANY($1)", teacher.IdStudentArrayToPQ(idStudents_))
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

func DeleteProgressionsByIdStudents(tx DB, idStudents_ ...teacher.IdStudent) (Progressions, error) {
	rows, err := tx.Query("DELETE FROM progressions WHERE idstudent = ANY($1) RETURNING *", teacher.IdStudentArrayToPQ(idStudents_))
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

// ByIdTask returns a map with 'IdTask' as keys.
func (items Progressions) ByIdTask() map[IdTask]Progressions {
	out := make(map[IdTask]Progressions)
	for _, target := range items {
		out[target.IdTask] = append(out[target.IdTask], target)
	}
	return out
}

// IdTasks returns the list of ids of IdTask
// contained in this link table.
// They are not garanteed to be distinct.
func (items Progressions) IdTasks() []IdTask {
	out := make([]IdTask, len(items))
	for index, target := range items {
		out[index] = target.IdTask
	}
	return out
}

func SelectProgressionsByIdTasks(tx DB, idTasks_ ...IdTask) (Progressions, error) {
	rows, err := tx.Query("SELECT * FROM progressions WHERE idtask = ANY($1)", IdTaskArrayToPQ(idTasks_))
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

func DeleteProgressionsByIdTasks(tx DB, idTasks_ ...IdTask) (Progressions, error) {
	rows, err := tx.Query("DELETE FROM progressions WHERE idtask = ANY($1) RETURNING *", IdTaskArrayToPQ(idTasks_))
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

// SelectProgressionsByIdStudentAndIdTask selects the items matching the given fields.
func SelectProgressionsByIdStudentAndIdTask(tx DB, idStudent teacher.IdStudent, idTask IdTask) (item Progressions, err error) {
	rows, err := tx.Query("SELECT * FROM progressions WHERE IdStudent = $1 AND IdTask = $2", idStudent, idTask)
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

// DeleteProgressionsByIdStudentAndIdTask deletes the item matching the given fields, returning
// the deleted items.
func DeleteProgressionsByIdStudentAndIdTask(tx DB, idStudent teacher.IdStudent, idTask IdTask) (item Progressions, err error) {
	rows, err := tx.Query("DELETE FROM progressions WHERE IdStudent = $1 AND IdTask = $2 RETURNING *", idStudent, idTask)
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

// SelectProgressionByIdStudentAndIdTaskAndIndex return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectProgressionByIdStudentAndIdTaskAndIndex(tx DB, idStudent teacher.IdStudent, idTask IdTask, index int16) (item Progression, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM progressions WHERE IdStudent = $1 AND IdTask = $2 AND Index = $3", idStudent, idTask, index)
	item, err = ScanProgression(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneRandomMonoquestion(row scanner) (RandomMonoquestion, error) {
	var item RandomMonoquestion
	err := row.Scan(
		&item.Id,
		&item.IdQuestiongroup,
		&item.NbRepeat,
		&item.Bareme,
		&item.Difficulty,
	)
	return item, err
}

func ScanRandomMonoquestion(row *sql.Row) (RandomMonoquestion, error) {
	return scanOneRandomMonoquestion(row)
}

// SelectAll returns all the items in the random_monoquestions table.
func SelectAllRandomMonoquestions(db DB) (RandomMonoquestions, error) {
	rows, err := db.Query("SELECT * FROM random_monoquestions")
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestions(rows)
}

// SelectRandomMonoquestion returns the entry matching 'id'.
func SelectRandomMonoquestion(tx DB, id IdRandomMonoquestion) (RandomMonoquestion, error) {
	row := tx.QueryRow("SELECT * FROM random_monoquestions WHERE id = $1", id)
	return ScanRandomMonoquestion(row)
}

// SelectRandomMonoquestions returns the entry matching the given 'ids'.
func SelectRandomMonoquestions(tx DB, ids ...IdRandomMonoquestion) (RandomMonoquestions, error) {
	rows, err := tx.Query("SELECT * FROM random_monoquestions WHERE id = ANY($1)", IdRandomMonoquestionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestions(rows)
}

type RandomMonoquestions map[IdRandomMonoquestion]RandomMonoquestion

func (m RandomMonoquestions) IDs() []IdRandomMonoquestion {
	out := make([]IdRandomMonoquestion, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanRandomMonoquestions(rs *sql.Rows) (RandomMonoquestions, error) {
	var (
		s   RandomMonoquestion
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(RandomMonoquestions, 16)
	for rs.Next() {
		s, err = scanOneRandomMonoquestion(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one RandomMonoquestion in the database and returns the item with id filled.
func (item RandomMonoquestion) Insert(tx DB) (out RandomMonoquestion, err error) {
	row := tx.QueryRow(`INSERT INTO random_monoquestions (
		idquestiongroup, nbrepeat, bareme, difficulty
		) VALUES (
		$1, $2, $3, $4
		) RETURNING *;
		`, item.IdQuestiongroup, item.NbRepeat, item.Bareme, item.Difficulty)
	return ScanRandomMonoquestion(row)
}

// Update RandomMonoquestion in the database and returns the new version.
func (item RandomMonoquestion) Update(tx DB) (out RandomMonoquestion, err error) {
	row := tx.QueryRow(`UPDATE random_monoquestions SET (
		idquestiongroup, nbrepeat, bareme, difficulty
		) = (
		$1, $2, $3, $4
		) WHERE id = $5 RETURNING *;
		`, item.IdQuestiongroup, item.NbRepeat, item.Bareme, item.Difficulty, item.Id)
	return ScanRandomMonoquestion(row)
}

// Deletes the RandomMonoquestion and returns the item
func DeleteRandomMonoquestionById(tx DB, id IdRandomMonoquestion) (RandomMonoquestion, error) {
	row := tx.QueryRow("DELETE FROM random_monoquestions WHERE id = $1 RETURNING *;", id)
	return ScanRandomMonoquestion(row)
}

// Deletes the RandomMonoquestion in the database and returns the ids.
func DeleteRandomMonoquestionsByIDs(tx DB, ids ...IdRandomMonoquestion) ([]IdRandomMonoquestion, error) {
	rows, err := tx.Query("DELETE FROM random_monoquestions WHERE id = ANY($1) RETURNING id", IdRandomMonoquestionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdRandomMonoquestionArray(rows)
}

// ByIdQuestiongroup returns a map with 'IdQuestiongroup' as keys.
func (items RandomMonoquestions) ByIdQuestiongroup() map[editor.IdQuestiongroup]RandomMonoquestions {
	out := make(map[editor.IdQuestiongroup]RandomMonoquestions)
	for _, target := range items {
		dict := out[target.IdQuestiongroup]
		if dict == nil {
			dict = make(RandomMonoquestions)
		}
		dict[target.Id] = target
		out[target.IdQuestiongroup] = dict
	}
	return out
}

// IdQuestiongroups returns the list of ids of IdQuestiongroup
// contained in this table.
// They are not garanteed to be distinct.
func (items RandomMonoquestions) IdQuestiongroups() []editor.IdQuestiongroup {
	out := make([]editor.IdQuestiongroup, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdQuestiongroup)
	}
	return out
}

func SelectRandomMonoquestionsByIdQuestiongroups(tx DB, idQuestiongroups_ ...editor.IdQuestiongroup) (RandomMonoquestions, error) {
	rows, err := tx.Query("SELECT * FROM random_monoquestions WHERE idquestiongroup = ANY($1)", editor.IdQuestiongroupArrayToPQ(idQuestiongroups_))
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestions(rows)
}

func DeleteRandomMonoquestionsByIdQuestiongroups(tx DB, idQuestiongroups_ ...editor.IdQuestiongroup) ([]IdRandomMonoquestion, error) {
	rows, err := tx.Query("DELETE FROM random_monoquestions WHERE idquestiongroup = ANY($1) RETURNING id", editor.IdQuestiongroupArrayToPQ(idQuestiongroups_))
	if err != nil {
		return nil, err
	}
	return ScanIdRandomMonoquestionArray(rows)
}

func scanOneRandomMonoquestionVariant(row scanner) (RandomMonoquestionVariant, error) {
	var item RandomMonoquestionVariant
	err := row.Scan(
		&item.IdStudent,
		&item.IdRandomMonoquestion,
		&item.Index,
		&item.IdQuestion,
	)
	return item, err
}

func ScanRandomMonoquestionVariant(row *sql.Row) (RandomMonoquestionVariant, error) {
	return scanOneRandomMonoquestionVariant(row)
}

// SelectAll returns all the items in the random_monoquestion_variants table.
func SelectAllRandomMonoquestionVariants(db DB) (RandomMonoquestionVariants, error) {
	rows, err := db.Query("SELECT * FROM random_monoquestion_variants")
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestionVariants(rows)
}

type RandomMonoquestionVariants []RandomMonoquestionVariant

func ScanRandomMonoquestionVariants(rs *sql.Rows) (RandomMonoquestionVariants, error) {
	var (
		item RandomMonoquestionVariant
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(RandomMonoquestionVariants, 0, 16)
	for rs.Next() {
		item, err = scanOneRandomMonoquestionVariant(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func InsertRandomMonoquestionVariant(db DB, item RandomMonoquestionVariant) error {
	_, err := db.Exec(`INSERT INTO random_monoquestion_variants (
			idstudent, idrandommonoquestion, index, idquestion
			) VALUES (
			$1, $2, $3, $4
			);
			`, item.IdStudent, item.IdRandomMonoquestion, item.Index, item.IdQuestion)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links RandomMonoquestionVariant in the database.
// It is a no-op if 'items' is empty.
func InsertManyRandomMonoquestionVariants(tx *sql.Tx, items ...RandomMonoquestionVariant) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("random_monoquestion_variants",
		"idstudent",
		"idrandommonoquestion",
		"index",
		"idquestion",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdStudent, item.IdRandomMonoquestion, item.Index, item.IdQuestion)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link RandomMonoquestionVariant from the database.
// Only the foreign keys IdStudent, IdRandomMonoquestion, IdQuestion fields are used in 'item'.
func (item RandomMonoquestionVariant) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM random_monoquestion_variants WHERE IdStudent = $1 AND IdRandomMonoquestion = $2 AND IdQuestion = $3;`, item.IdStudent, item.IdRandomMonoquestion, item.IdQuestion)
	return err
}

// ByIdStudent returns a map with 'IdStudent' as keys.
func (items RandomMonoquestionVariants) ByIdStudent() map[teacher.IdStudent]RandomMonoquestionVariants {
	out := make(map[teacher.IdStudent]RandomMonoquestionVariants)
	for _, target := range items {
		out[target.IdStudent] = append(out[target.IdStudent], target)
	}
	return out
}

// IdStudents returns the list of ids of IdStudent
// contained in this link table.
// They are not garanteed to be distinct.
func (items RandomMonoquestionVariants) IdStudents() []teacher.IdStudent {
	out := make([]teacher.IdStudent, len(items))
	for index, target := range items {
		out[index] = target.IdStudent
	}
	return out
}

func SelectRandomMonoquestionVariantsByIdStudents(tx DB, idStudents_ ...teacher.IdStudent) (RandomMonoquestionVariants, error) {
	rows, err := tx.Query("SELECT * FROM random_monoquestion_variants WHERE idstudent = ANY($1)", teacher.IdStudentArrayToPQ(idStudents_))
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestionVariants(rows)
}

func DeleteRandomMonoquestionVariantsByIdStudents(tx DB, idStudents_ ...teacher.IdStudent) (RandomMonoquestionVariants, error) {
	rows, err := tx.Query("DELETE FROM random_monoquestion_variants WHERE idstudent = ANY($1) RETURNING *", teacher.IdStudentArrayToPQ(idStudents_))
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestionVariants(rows)
}

// ByIdRandomMonoquestion returns a map with 'IdRandomMonoquestion' as keys.
func (items RandomMonoquestionVariants) ByIdRandomMonoquestion() map[IdRandomMonoquestion]RandomMonoquestionVariants {
	out := make(map[IdRandomMonoquestion]RandomMonoquestionVariants)
	for _, target := range items {
		out[target.IdRandomMonoquestion] = append(out[target.IdRandomMonoquestion], target)
	}
	return out
}

// IdRandomMonoquestions returns the list of ids of IdRandomMonoquestion
// contained in this link table.
// They are not garanteed to be distinct.
func (items RandomMonoquestionVariants) IdRandomMonoquestions() []IdRandomMonoquestion {
	out := make([]IdRandomMonoquestion, len(items))
	for index, target := range items {
		out[index] = target.IdRandomMonoquestion
	}
	return out
}

func SelectRandomMonoquestionVariantsByIdRandomMonoquestions(tx DB, idRandomMonoquestions_ ...IdRandomMonoquestion) (RandomMonoquestionVariants, error) {
	rows, err := tx.Query("SELECT * FROM random_monoquestion_variants WHERE idrandommonoquestion = ANY($1)", IdRandomMonoquestionArrayToPQ(idRandomMonoquestions_))
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestionVariants(rows)
}

func DeleteRandomMonoquestionVariantsByIdRandomMonoquestions(tx DB, idRandomMonoquestions_ ...IdRandomMonoquestion) (RandomMonoquestionVariants, error) {
	rows, err := tx.Query("DELETE FROM random_monoquestion_variants WHERE idrandommonoquestion = ANY($1) RETURNING *", IdRandomMonoquestionArrayToPQ(idRandomMonoquestions_))
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestionVariants(rows)
}

// ByIdQuestion returns a map with 'IdQuestion' as keys.
func (items RandomMonoquestionVariants) ByIdQuestion() map[editor.IdQuestion]RandomMonoquestionVariants {
	out := make(map[editor.IdQuestion]RandomMonoquestionVariants)
	for _, target := range items {
		out[target.IdQuestion] = append(out[target.IdQuestion], target)
	}
	return out
}

// IdQuestions returns the list of ids of IdQuestion
// contained in this link table.
// They are not garanteed to be distinct.
func (items RandomMonoquestionVariants) IdQuestions() []editor.IdQuestion {
	out := make([]editor.IdQuestion, len(items))
	for index, target := range items {
		out[index] = target.IdQuestion
	}
	return out
}

func SelectRandomMonoquestionVariantsByIdQuestions(tx DB, idQuestions_ ...editor.IdQuestion) (RandomMonoquestionVariants, error) {
	rows, err := tx.Query("SELECT * FROM random_monoquestion_variants WHERE idquestion = ANY($1)", editor.IdQuestionArrayToPQ(idQuestions_))
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestionVariants(rows)
}

func DeleteRandomMonoquestionVariantsByIdQuestions(tx DB, idQuestions_ ...editor.IdQuestion) (RandomMonoquestionVariants, error) {
	rows, err := tx.Query("DELETE FROM random_monoquestion_variants WHERE idquestion = ANY($1) RETURNING *", editor.IdQuestionArrayToPQ(idQuestions_))
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestionVariants(rows)
}

// SelectRandomMonoquestionVariantsByIdStudentAndIdRandomMonoquestion selects the items matching the given fields.
func SelectRandomMonoquestionVariantsByIdStudentAndIdRandomMonoquestion(tx DB, idStudent teacher.IdStudent, idRandomMonoquestion IdRandomMonoquestion) (item RandomMonoquestionVariants, err error) {
	rows, err := tx.Query("SELECT * FROM random_monoquestion_variants WHERE IdStudent = $1 AND IdRandomMonoquestion = $2", idStudent, idRandomMonoquestion)
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestionVariants(rows)
}

// DeleteRandomMonoquestionVariantsByIdStudentAndIdRandomMonoquestion deletes the item matching the given fields, returning
// the deleted items.
func DeleteRandomMonoquestionVariantsByIdStudentAndIdRandomMonoquestion(tx DB, idStudent teacher.IdStudent, idRandomMonoquestion IdRandomMonoquestion) (item RandomMonoquestionVariants, err error) {
	rows, err := tx.Query("DELETE FROM random_monoquestion_variants WHERE IdStudent = $1 AND IdRandomMonoquestion = $2 RETURNING *", idStudent, idRandomMonoquestion)
	if err != nil {
		return nil, err
	}
	return ScanRandomMonoquestionVariants(rows)
}

// SelectRandomMonoquestionVariantByIdStudentAndIdRandomMonoquestionAndIndex return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectRandomMonoquestionVariantByIdStudentAndIdRandomMonoquestionAndIndex(tx DB, idStudent teacher.IdStudent, idRandomMonoquestion IdRandomMonoquestion, index int16) (item RandomMonoquestionVariant, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM random_monoquestion_variants WHERE IdStudent = $1 AND IdRandomMonoquestion = $2 AND Index = $3", idStudent, idRandomMonoquestion, index)
	item, err = ScanRandomMonoquestionVariant(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneTask(row scanner) (Task, error) {
	var item Task
	err := row.Scan(
		&item.Id,
		&item.IdExercice,
		&item.IdMonoquestion,
		&item.IdRandomMonoquestion,
	)
	return item, err
}

func ScanTask(row *sql.Row) (Task, error) { return scanOneTask(row) }

// SelectAll returns all the items in the tasks table.
func SelectAllTasks(db DB) (Tasks, error) {
	rows, err := db.Query("SELECT * FROM tasks")
	if err != nil {
		return nil, err
	}
	return ScanTasks(rows)
}

// SelectTask returns the entry matching 'id'.
func SelectTask(tx DB, id IdTask) (Task, error) {
	row := tx.QueryRow("SELECT * FROM tasks WHERE id = $1", id)
	return ScanTask(row)
}

// SelectTasks returns the entry matching the given 'ids'.
func SelectTasks(tx DB, ids ...IdTask) (Tasks, error) {
	rows, err := tx.Query("SELECT * FROM tasks WHERE id = ANY($1)", IdTaskArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanTasks(rows)
}

type Tasks map[IdTask]Task

func (m Tasks) IDs() []IdTask {
	out := make([]IdTask, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanTasks(rs *sql.Rows) (Tasks, error) {
	var (
		s   Task
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Tasks, 16)
	for rs.Next() {
		s, err = scanOneTask(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Task in the database and returns the item with id filled.
func (item Task) Insert(tx DB) (out Task, err error) {
	row := tx.QueryRow(`INSERT INTO tasks (
		idexercice, idmonoquestion, idrandommonoquestion
		) VALUES (
		$1, $2, $3
		) RETURNING *;
		`, item.IdExercice, item.IdMonoquestion, item.IdRandomMonoquestion)
	return ScanTask(row)
}

// Update Task in the database and returns the new version.
func (item Task) Update(tx DB) (out Task, err error) {
	row := tx.QueryRow(`UPDATE tasks SET (
		idexercice, idmonoquestion, idrandommonoquestion
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING *;
		`, item.IdExercice, item.IdMonoquestion, item.IdRandomMonoquestion, item.Id)
	return ScanTask(row)
}

// Deletes the Task and returns the item
func DeleteTaskById(tx DB, id IdTask) (Task, error) {
	row := tx.QueryRow("DELETE FROM tasks WHERE id = $1 RETURNING *;", id)
	return ScanTask(row)
}

// Deletes the Task in the database and returns the ids.
func DeleteTasksByIDs(tx DB, ids ...IdTask) ([]IdTask, error) {
	rows, err := tx.Query("DELETE FROM tasks WHERE id = ANY($1) RETURNING id", IdTaskArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdTaskArray(rows)
}

func SelectTasksByIdExercices(tx DB, idExercices_ ...editor.IdExercice) (Tasks, error) {
	rows, err := tx.Query("SELECT * FROM tasks WHERE idexercice = ANY($1)", editor.IdExerciceArrayToPQ(idExercices_))
	if err != nil {
		return nil, err
	}
	return ScanTasks(rows)
}

func DeleteTasksByIdExercices(tx DB, idExercices_ ...editor.IdExercice) ([]IdTask, error) {
	rows, err := tx.Query("DELETE FROM tasks WHERE idexercice = ANY($1) RETURNING id", editor.IdExerciceArrayToPQ(idExercices_))
	if err != nil {
		return nil, err
	}
	return ScanIdTaskArray(rows)
}

func SelectTasksByIdMonoquestions(tx DB, idMonoquestions_ ...IdMonoquestion) (Tasks, error) {
	rows, err := tx.Query("SELECT * FROM tasks WHERE idmonoquestion = ANY($1)", IdMonoquestionArrayToPQ(idMonoquestions_))
	if err != nil {
		return nil, err
	}
	return ScanTasks(rows)
}

func DeleteTasksByIdMonoquestions(tx DB, idMonoquestions_ ...IdMonoquestion) ([]IdTask, error) {
	rows, err := tx.Query("DELETE FROM tasks WHERE idmonoquestion = ANY($1) RETURNING id", IdMonoquestionArrayToPQ(idMonoquestions_))
	if err != nil {
		return nil, err
	}
	return ScanIdTaskArray(rows)
}

func SelectTasksByIdRandomMonoquestions(tx DB, idRandomMonoquestions_ ...IdRandomMonoquestion) (Tasks, error) {
	rows, err := tx.Query("SELECT * FROM tasks WHERE idrandommonoquestion = ANY($1)", IdRandomMonoquestionArrayToPQ(idRandomMonoquestions_))
	if err != nil {
		return nil, err
	}
	return ScanTasks(rows)
}

func DeleteTasksByIdRandomMonoquestions(tx DB, idRandomMonoquestions_ ...IdRandomMonoquestion) ([]IdTask, error) {
	rows, err := tx.Query("DELETE FROM tasks WHERE idrandommonoquestion = ANY($1) RETURNING id", IdRandomMonoquestionArrayToPQ(idRandomMonoquestions_))
	if err != nil {
		return nil, err
	}
	return ScanIdTaskArray(rows)
}

// SelectTaskByIdAndIdExercice return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectTaskByIdAndIdExercice(tx DB, id IdTask, idExercice editor.OptionalIdExercice) (item Task, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM tasks WHERE Id = $1 AND IdExercice = $2", id, idExercice)
	item, err = ScanTask(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func (s *QuestionHistory) Scan(src interface{}) error {
	return (*pq.BoolArray)(s).Scan(src)
}
func (s QuestionHistory) Value() (driver.Value, error) {
	return pq.BoolArray(s).Value()
}

func IdMonoquestionArrayToPQ(ids []IdMonoquestion) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdMonoquestionArray scans the result of a query returning a
// list of ID's.
func ScanIdMonoquestionArray(rs *sql.Rows) ([]IdMonoquestion, error) {
	defer rs.Close()
	ints := make([]IdMonoquestion, 0, 16)
	var err error
	for rs.Next() {
		var s IdMonoquestion
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdMonoquestionSet map[IdMonoquestion]bool

func NewIdMonoquestionSetFrom(ids []IdMonoquestion) IdMonoquestionSet {
	out := make(IdMonoquestionSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdMonoquestionSet) Add(id IdMonoquestion) { s[id] = true }

func (s IdMonoquestionSet) Has(id IdMonoquestion) bool { return s[id] }

func (s IdMonoquestionSet) Keys() []IdMonoquestion {
	out := make([]IdMonoquestion, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdRandomMonoquestionArrayToPQ(ids []IdRandomMonoquestion) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdRandomMonoquestionArray scans the result of a query returning a
// list of ID's.
func ScanIdRandomMonoquestionArray(rs *sql.Rows) ([]IdRandomMonoquestion, error) {
	defer rs.Close()
	ints := make([]IdRandomMonoquestion, 0, 16)
	var err error
	for rs.Next() {
		var s IdRandomMonoquestion
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdRandomMonoquestionSet map[IdRandomMonoquestion]bool

func NewIdRandomMonoquestionSetFrom(ids []IdRandomMonoquestion) IdRandomMonoquestionSet {
	out := make(IdRandomMonoquestionSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdRandomMonoquestionSet) Add(id IdRandomMonoquestion) { s[id] = true }

func (s IdRandomMonoquestionSet) Has(id IdRandomMonoquestion) bool { return s[id] }

func (s IdRandomMonoquestionSet) Keys() []IdRandomMonoquestion {
	out := make([]IdRandomMonoquestion, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdTaskArrayToPQ(ids []IdTask) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdTaskArray scans the result of a query returning a
// list of ID's.
func ScanIdTaskArray(rs *sql.Rows) ([]IdTask, error) {
	defer rs.Close()
	ints := make([]IdTask, 0, 16)
	var err error
	for rs.Next() {
		var s IdTask
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdTaskSet map[IdTask]bool

func NewIdTaskSetFrom(ids []IdTask) IdTaskSet {
	out := make(IdTaskSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdTaskSet) Add(id IdTask) { s[id] = true }

func (s IdTaskSet) Has(id IdTask) bool { return s[id] }

func (s IdTaskSet) Keys() []IdTask {
	out := make([]IdTask, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s *OptionalIdMonoquestion) Scan(src interface{}) error {
	var tmp sql.NullInt64
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = OptionalIdMonoquestion{
		Valid: tmp.Valid,
		ID:    IdMonoquestion(tmp.Int64),
	}
	return nil
}

func (s OptionalIdMonoquestion) Value() (driver.Value, error) {
	return sql.NullInt64{
		Int64: int64(s.ID),
		Valid: s.Valid}.Value()
}

func (s *OptionalIdRandomMonoquestion) Scan(src interface{}) error {
	var tmp sql.NullInt64
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = OptionalIdRandomMonoquestion{
		Valid: tmp.Valid,
		ID:    IdRandomMonoquestion(tmp.Int64),
	}
	return nil
}

func (s OptionalIdRandomMonoquestion) Value() (driver.Value, error) {
	return sql.NullInt64{
		Int64: int64(s.ID),
		Valid: s.Valid}.Value()
}
