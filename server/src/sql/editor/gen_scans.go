package editor

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"

	"github.com/benoitkugler/maths-online/sql/teacher"
	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneExercice(row scanner) (Exercice, error) {
	var item Exercice
	err := row.Scan(
		&item.Id,
		&item.IdGroup,
		&item.Subtitle,
		&item.Description,
		&item.Parameters,
		&item.Flow,
	)
	return item, err
}

func ScanExercice(row *sql.Row) (Exercice, error) { return scanOneExercice(row) }

// SelectAll returns all the items in the exercices table.
func SelectAllExercices(db DB) (Exercices, error) {
	rows, err := db.Query("SELECT * FROM exercices")
	if err != nil {
		return nil, err
	}
	return ScanExercices(rows)
}

// SelectExercice returns the entry matching 'id'.
func SelectExercice(tx DB, id IdExercice) (Exercice, error) {
	row := tx.QueryRow("SELECT * FROM exercices WHERE id = $1", id)
	return ScanExercice(row)
}

// SelectExercices returns the entry matching the given 'ids'.
func SelectExercices(tx DB, ids ...IdExercice) (Exercices, error) {
	rows, err := tx.Query("SELECT * FROM exercices WHERE id = ANY($1)", IdExerciceArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanExercices(rows)
}

type Exercices map[IdExercice]Exercice

func (m Exercices) IDs() []IdExercice {
	out := make([]IdExercice, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanExercices(rs *sql.Rows) (Exercices, error) {
	var (
		s   Exercice
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Exercices, 16)
	for rs.Next() {
		s, err = scanOneExercice(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Exercice in the database and returns the item with id filled.
func (item Exercice) Insert(tx DB) (out Exercice, err error) {
	row := tx.QueryRow(`INSERT INTO exercices (
		idgroup, subtitle, description, parameters, flow
		) VALUES (
		$1, $2, $3, $4, $5
		) RETURNING *;
		`, item.IdGroup, item.Subtitle, item.Description, item.Parameters, item.Flow)
	return ScanExercice(row)
}

// Update Exercice in the database and returns the new version.
func (item Exercice) Update(tx DB) (out Exercice, err error) {
	row := tx.QueryRow(`UPDATE exercices SET (
		idgroup, subtitle, description, parameters, flow
		) = (
		$1, $2, $3, $4, $5
		) WHERE id = $6 RETURNING *;
		`, item.IdGroup, item.Subtitle, item.Description, item.Parameters, item.Flow, item.Id)
	return ScanExercice(row)
}

// Deletes the Exercice and returns the item
func DeleteExerciceById(tx DB, id IdExercice) (Exercice, error) {
	row := tx.QueryRow("DELETE FROM exercices WHERE id = $1 RETURNING *;", id)
	return ScanExercice(row)
}

// Deletes the Exercice in the database and returns the ids.
func DeleteExercicesByIDs(tx DB, ids ...IdExercice) ([]IdExercice, error) {
	rows, err := tx.Query("DELETE FROM exercices WHERE id = ANY($1) RETURNING id", IdExerciceArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdExerciceArray(rows)
}

// ByIdGroup returns a map with 'IdGroup' as keys.
func (items Exercices) ByIdGroup() map[IdExercicegroup]Exercices {
	out := make(map[IdExercicegroup]Exercices)
	for _, target := range items {
		dict := out[target.IdGroup]
		if dict == nil {
			dict = make(Exercices)
		}
		dict[target.Id] = target
		out[target.IdGroup] = dict
	}
	return out
}

// IdGroups returns the list of ids of IdGroup
// contained in this table.
// They are not garanteed to be distinct.
func (items Exercices) IdGroups() []IdExercicegroup {
	out := make([]IdExercicegroup, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdGroup)
	}
	return out
}

func SelectExercicesByIdGroups(tx DB, idGroups ...IdExercicegroup) (Exercices, error) {
	rows, err := tx.Query("SELECT * FROM exercices WHERE idgroup = ANY($1)", IdExercicegroupArrayToPQ(idGroups))
	if err != nil {
		return nil, err
	}
	return ScanExercices(rows)
}

func DeleteExercicesByIdGroups(tx DB, idGroups ...IdExercicegroup) ([]IdExercice, error) {
	rows, err := tx.Query("DELETE FROM exercices WHERE idgroup = ANY($1) RETURNING id", IdExercicegroupArrayToPQ(idGroups))
	if err != nil {
		return nil, err
	}
	return ScanIdExerciceArray(rows)
}

func scanOneExerciceQuestion(row scanner) (ExerciceQuestion, error) {
	var item ExerciceQuestion
	err := row.Scan(
		&item.IdExercice,
		&item.IdQuestion,
		&item.Bareme,
		&item.Index,
	)
	return item, err
}

func ScanExerciceQuestion(row *sql.Row) (ExerciceQuestion, error) {
	return scanOneExerciceQuestion(row)
}

// SelectAll returns all the items in the exercice_questions table.
func SelectAllExerciceQuestions(db DB) (ExerciceQuestions, error) {
	rows, err := db.Query("SELECT * FROM exercice_questions")
	if err != nil {
		return nil, err
	}
	return ScanExerciceQuestions(rows)
}

type ExerciceQuestions []ExerciceQuestion

func ScanExerciceQuestions(rs *sql.Rows) (ExerciceQuestions, error) {
	var (
		item ExerciceQuestion
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ExerciceQuestions, 0, 16)
	for rs.Next() {
		item, err = scanOneExerciceQuestion(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links ExerciceQuestion in the database.
// It is a no-op if 'items' is empty.
func InsertManyExerciceQuestions(tx *sql.Tx, items ...ExerciceQuestion) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("exercice_questions",
		"idexercice",
		"idquestion",
		"bareme",
		"index",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdExercice, item.IdQuestion, item.Bareme, item.Index)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ExerciceQuestion from the database.
// Only the foreign keys IdExercice, IdQuestion fields are used in 'item'.
func (item ExerciceQuestion) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM exercice_questions WHERE IdExercice = $1 AND IdQuestion = $2;`, item.IdExercice, item.IdQuestion)
	return err
}

// ByIdExercice returns a map with 'IdExercice' as keys.
func (items ExerciceQuestions) ByIdExercice() map[IdExercice]ExerciceQuestions {
	out := make(map[IdExercice]ExerciceQuestions)
	for _, target := range items {
		out[target.IdExercice] = append(out[target.IdExercice], target)
	}
	return out
}

// IdExercices returns the list of ids of IdExercice
// contained in this link table.
// They are not garanteed to be distinct.
func (items ExerciceQuestions) IdExercices() []IdExercice {
	out := make([]IdExercice, len(items))
	for index, target := range items {
		out[index] = target.IdExercice
	}
	return out
}

func SelectExerciceQuestionsByIdExercices(tx DB, idExercices ...IdExercice) (ExerciceQuestions, error) {
	rows, err := tx.Query("SELECT * FROM exercice_questions WHERE idexercice = ANY($1)", IdExerciceArrayToPQ(idExercices))
	if err != nil {
		return nil, err
	}
	return ScanExerciceQuestions(rows)
}

func DeleteExerciceQuestionsByIdExercices(tx DB, idExercices ...IdExercice) (ExerciceQuestions, error) {
	rows, err := tx.Query("DELETE FROM exercice_questions WHERE idexercice = ANY($1) RETURNING *", IdExerciceArrayToPQ(idExercices))
	if err != nil {
		return nil, err
	}
	return ScanExerciceQuestions(rows)
}

// ByIdQuestion returns a map with 'IdQuestion' as keys.
func (items ExerciceQuestions) ByIdQuestion() map[IdQuestion]ExerciceQuestions {
	out := make(map[IdQuestion]ExerciceQuestions)
	for _, target := range items {
		out[target.IdQuestion] = append(out[target.IdQuestion], target)
	}
	return out
}

// IdQuestions returns the list of ids of IdQuestion
// contained in this link table.
// They are not garanteed to be distinct.
func (items ExerciceQuestions) IdQuestions() []IdQuestion {
	out := make([]IdQuestion, len(items))
	for index, target := range items {
		out[index] = target.IdQuestion
	}
	return out
}

func SelectExerciceQuestionsByIdQuestions(tx DB, idQuestions ...IdQuestion) (ExerciceQuestions, error) {
	rows, err := tx.Query("SELECT * FROM exercice_questions WHERE idquestion = ANY($1)", IdQuestionArrayToPQ(idQuestions))
	if err != nil {
		return nil, err
	}
	return ScanExerciceQuestions(rows)
}

func DeleteExerciceQuestionsByIdQuestions(tx DB, idQuestions ...IdQuestion) (ExerciceQuestions, error) {
	rows, err := tx.Query("DELETE FROM exercice_questions WHERE idquestion = ANY($1) RETURNING *", IdQuestionArrayToPQ(idQuestions))
	if err != nil {
		return nil, err
	}
	return ScanExerciceQuestions(rows)
}

// SelectExerciceQuestionByIdExerciceAndIndex return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectExerciceQuestionByIdExerciceAndIndex(tx DB, idExercice IdExercice, index int) (item ExerciceQuestion, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM exercice_questions WHERE IdExercice = $1 AND Index = $2", idExercice, index)
	item, err = ScanExerciceQuestion(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneExercicegroup(row scanner) (Exercicegroup, error) {
	var item Exercicegroup
	err := row.Scan(
		&item.Id,
		&item.Title,
		&item.Public,
		&item.IdTeacher,
	)
	return item, err
}

func ScanExercicegroup(row *sql.Row) (Exercicegroup, error) { return scanOneExercicegroup(row) }

// SelectAll returns all the items in the exercicegroups table.
func SelectAllExercicegroups(db DB) (Exercicegroups, error) {
	rows, err := db.Query("SELECT * FROM exercicegroups")
	if err != nil {
		return nil, err
	}
	return ScanExercicegroups(rows)
}

// SelectExercicegroup returns the entry matching 'id'.
func SelectExercicegroup(tx DB, id IdExercicegroup) (Exercicegroup, error) {
	row := tx.QueryRow("SELECT * FROM exercicegroups WHERE id = $1", id)
	return ScanExercicegroup(row)
}

// SelectExercicegroups returns the entry matching the given 'ids'.
func SelectExercicegroups(tx DB, ids ...IdExercicegroup) (Exercicegroups, error) {
	rows, err := tx.Query("SELECT * FROM exercicegroups WHERE id = ANY($1)", IdExercicegroupArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanExercicegroups(rows)
}

type Exercicegroups map[IdExercicegroup]Exercicegroup

func (m Exercicegroups) IDs() []IdExercicegroup {
	out := make([]IdExercicegroup, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanExercicegroups(rs *sql.Rows) (Exercicegroups, error) {
	var (
		s   Exercicegroup
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Exercicegroups, 16)
	for rs.Next() {
		s, err = scanOneExercicegroup(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Exercicegroup in the database and returns the item with id filled.
func (item Exercicegroup) Insert(tx DB) (out Exercicegroup, err error) {
	row := tx.QueryRow(`INSERT INTO exercicegroups (
		title, public, idteacher
		) VALUES (
		$1, $2, $3
		) RETURNING *;
		`, item.Title, item.Public, item.IdTeacher)
	return ScanExercicegroup(row)
}

// Update Exercicegroup in the database and returns the new version.
func (item Exercicegroup) Update(tx DB) (out Exercicegroup, err error) {
	row := tx.QueryRow(`UPDATE exercicegroups SET (
		title, public, idteacher
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING *;
		`, item.Title, item.Public, item.IdTeacher, item.Id)
	return ScanExercicegroup(row)
}

// Deletes the Exercicegroup and returns the item
func DeleteExercicegroupById(tx DB, id IdExercicegroup) (Exercicegroup, error) {
	row := tx.QueryRow("DELETE FROM exercicegroups WHERE id = $1 RETURNING *;", id)
	return ScanExercicegroup(row)
}

// Deletes the Exercicegroup in the database and returns the ids.
func DeleteExercicegroupsByIDs(tx DB, ids ...IdExercicegroup) ([]IdExercicegroup, error) {
	rows, err := tx.Query("DELETE FROM exercicegroups WHERE id = ANY($1) RETURNING id", IdExercicegroupArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdExercicegroupArray(rows)
}

// ByIdTeacher returns a map with 'IdTeacher' as keys.
func (items Exercicegroups) ByIdTeacher() map[teacher.IdTeacher]Exercicegroups {
	out := make(map[teacher.IdTeacher]Exercicegroups)
	for _, target := range items {
		dict := out[target.IdTeacher]
		if dict == nil {
			dict = make(Exercicegroups)
		}
		dict[target.Id] = target
		out[target.IdTeacher] = dict
	}
	return out
}

// IdTeachers returns the list of ids of IdTeacher
// contained in this table.
// They are not garanteed to be distinct.
func (items Exercicegroups) IdTeachers() []teacher.IdTeacher {
	out := make([]teacher.IdTeacher, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdTeacher)
	}
	return out
}

func SelectExercicegroupsByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) (Exercicegroups, error) {
	rows, err := tx.Query("SELECT * FROM exercicegroups WHERE idteacher = ANY($1)", teacher.IdTeacherArrayToPQ(idTeachers))
	if err != nil {
		return nil, err
	}
	return ScanExercicegroups(rows)
}

func DeleteExercicegroupsByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) ([]IdExercicegroup, error) {
	rows, err := tx.Query("DELETE FROM exercicegroups WHERE idteacher = ANY($1) RETURNING id", teacher.IdTeacherArrayToPQ(idTeachers))
	if err != nil {
		return nil, err
	}
	return ScanIdExercicegroupArray(rows)
}

func scanOneExercicegroupTag(row scanner) (ExercicegroupTag, error) {
	var item ExercicegroupTag
	err := row.Scan(
		&item.Tag,
		&item.IdExercicegroup,
	)
	return item, err
}

func ScanExercicegroupTag(row *sql.Row) (ExercicegroupTag, error) {
	return scanOneExercicegroupTag(row)
}

// SelectAll returns all the items in the exercicegroup_tags table.
func SelectAllExercicegroupTags(db DB) (ExercicegroupTags, error) {
	rows, err := db.Query("SELECT * FROM exercicegroup_tags")
	if err != nil {
		return nil, err
	}
	return ScanExercicegroupTags(rows)
}

type ExercicegroupTags []ExercicegroupTag

func ScanExercicegroupTags(rs *sql.Rows) (ExercicegroupTags, error) {
	var (
		item ExercicegroupTag
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ExercicegroupTags, 0, 16)
	for rs.Next() {
		item, err = scanOneExercicegroupTag(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links ExercicegroupTag in the database.
// It is a no-op if 'items' is empty.
func InsertManyExercicegroupTags(tx *sql.Tx, items ...ExercicegroupTag) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("exercicegroup_tags",
		"tag",
		"idexercicegroup",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.Tag, item.IdExercicegroup)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ExercicegroupTag from the database.
// Only the foreign keys IdExercicegroup fields are used in 'item'.
func (item ExercicegroupTag) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM exercicegroup_tags WHERE IdExercicegroup = $1;`, item.IdExercicegroup)
	return err
}

// ByIdExercicegroup returns a map with 'IdExercicegroup' as keys.
func (items ExercicegroupTags) ByIdExercicegroup() map[IdExercicegroup]ExercicegroupTags {
	out := make(map[IdExercicegroup]ExercicegroupTags)
	for _, target := range items {
		out[target.IdExercicegroup] = append(out[target.IdExercicegroup], target)
	}
	return out
}

// IdExercicegroups returns the list of ids of IdExercicegroup
// contained in this link table.
// They are not garanteed to be distinct.
func (items ExercicegroupTags) IdExercicegroups() []IdExercicegroup {
	out := make([]IdExercicegroup, len(items))
	for index, target := range items {
		out[index] = target.IdExercicegroup
	}
	return out
}

func SelectExercicegroupTagsByIdExercicegroups(tx DB, idExercicegroups ...IdExercicegroup) (ExercicegroupTags, error) {
	rows, err := tx.Query("SELECT * FROM exercicegroup_tags WHERE idexercicegroup = ANY($1)", IdExercicegroupArrayToPQ(idExercicegroups))
	if err != nil {
		return nil, err
	}
	return ScanExercicegroupTags(rows)
}

func DeleteExercicegroupTagsByIdExercicegroups(tx DB, idExercicegroups ...IdExercicegroup) (ExercicegroupTags, error) {
	rows, err := tx.Query("DELETE FROM exercicegroup_tags WHERE idexercicegroup = ANY($1) RETURNING *", IdExercicegroupArrayToPQ(idExercicegroups))
	if err != nil {
		return nil, err
	}
	return ScanExercicegroupTags(rows)
}

// SelectExercicegroupTagByIdExercicegroupAndTag return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectExercicegroupTagByIdExercicegroupAndTag(tx DB, idExercicegroup IdExercicegroup, tag string) (item ExercicegroupTag, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM exercicegroup_tags WHERE IdExercicegroup = $1 AND Tag = $2", idExercicegroup, tag)
	item, err = ScanExercicegroupTag(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneQuestion(row scanner) (Question, error) {
	var item Question
	err := row.Scan(
		&item.Id,
		&item.Page,
		&item.Subtitle,
		&item.Description,
		&item.Difficulty,
		&item.NeedExercice,
		&item.IdGroup,
	)
	return item, err
}

func ScanQuestion(row *sql.Row) (Question, error) { return scanOneQuestion(row) }

// SelectAll returns all the items in the questions table.
func SelectAllQuestions(db DB) (Questions, error) {
	rows, err := db.Query("SELECT * FROM questions")
	if err != nil {
		return nil, err
	}
	return ScanQuestions(rows)
}

// SelectQuestion returns the entry matching 'id'.
func SelectQuestion(tx DB, id IdQuestion) (Question, error) {
	row := tx.QueryRow("SELECT * FROM questions WHERE id = $1", id)
	return ScanQuestion(row)
}

// SelectQuestions returns the entry matching the given 'ids'.
func SelectQuestions(tx DB, ids ...IdQuestion) (Questions, error) {
	rows, err := tx.Query("SELECT * FROM questions WHERE id = ANY($1)", IdQuestionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanQuestions(rows)
}

type Questions map[IdQuestion]Question

func (m Questions) IDs() []IdQuestion {
	out := make([]IdQuestion, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanQuestions(rs *sql.Rows) (Questions, error) {
	var (
		s   Question
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Questions, 16)
	for rs.Next() {
		s, err = scanOneQuestion(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Question in the database and returns the item with id filled.
func (item Question) Insert(tx DB) (out Question, err error) {
	row := tx.QueryRow(`INSERT INTO questions (
		page, subtitle, description, difficulty, needexercice, idgroup
		) VALUES (
		$1, $2, $3, $4, $5, $6
		) RETURNING *;
		`, item.Page, item.Subtitle, item.Description, item.Difficulty, item.NeedExercice, item.IdGroup)
	return ScanQuestion(row)
}

// Update Question in the database and returns the new version.
func (item Question) Update(tx DB) (out Question, err error) {
	row := tx.QueryRow(`UPDATE questions SET (
		page, subtitle, description, difficulty, needexercice, idgroup
		) = (
		$1, $2, $3, $4, $5, $6
		) WHERE id = $7 RETURNING *;
		`, item.Page, item.Subtitle, item.Description, item.Difficulty, item.NeedExercice, item.IdGroup, item.Id)
	return ScanQuestion(row)
}

// Deletes the Question and returns the item
func DeleteQuestionById(tx DB, id IdQuestion) (Question, error) {
	row := tx.QueryRow("DELETE FROM questions WHERE id = $1 RETURNING *;", id)
	return ScanQuestion(row)
}

// Deletes the Question in the database and returns the ids.
func DeleteQuestionsByIDs(tx DB, ids ...IdQuestion) ([]IdQuestion, error) {
	rows, err := tx.Query("DELETE FROM questions WHERE id = ANY($1) RETURNING id", IdQuestionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdQuestionArray(rows)
}

func SelectQuestionsByNeedExercices(tx DB, needExercices ...IdExercice) (Questions, error) {
	rows, err := tx.Query("SELECT * FROM questions WHERE needexercice = ANY($1)", IdExerciceArrayToPQ(needExercices))
	if err != nil {
		return nil, err
	}
	return ScanQuestions(rows)
}

func DeleteQuestionsByNeedExercices(tx DB, needExercices ...IdExercice) ([]IdQuestion, error) {
	rows, err := tx.Query("DELETE FROM questions WHERE needexercice = ANY($1) RETURNING id", IdExerciceArrayToPQ(needExercices))
	if err != nil {
		return nil, err
	}
	return ScanIdQuestionArray(rows)
}

func SelectQuestionsByIdGroups(tx DB, idGroups ...IdQuestiongroup) (Questions, error) {
	rows, err := tx.Query("SELECT * FROM questions WHERE idgroup = ANY($1)", IdQuestiongroupArrayToPQ(idGroups))
	if err != nil {
		return nil, err
	}
	return ScanQuestions(rows)
}

func DeleteQuestionsByIdGroups(tx DB, idGroups ...IdQuestiongroup) ([]IdQuestion, error) {
	rows, err := tx.Query("DELETE FROM questions WHERE idgroup = ANY($1) RETURNING id", IdQuestiongroupArrayToPQ(idGroups))
	if err != nil {
		return nil, err
	}
	return ScanIdQuestionArray(rows)
}

func scanOneQuestiongroup(row scanner) (Questiongroup, error) {
	var item Questiongroup
	err := row.Scan(
		&item.Id,
		&item.Title,
		&item.Public,
		&item.IdTeacher,
	)
	return item, err
}

func ScanQuestiongroup(row *sql.Row) (Questiongroup, error) { return scanOneQuestiongroup(row) }

// SelectAll returns all the items in the questiongroups table.
func SelectAllQuestiongroups(db DB) (Questiongroups, error) {
	rows, err := db.Query("SELECT * FROM questiongroups")
	if err != nil {
		return nil, err
	}
	return ScanQuestiongroups(rows)
}

// SelectQuestiongroup returns the entry matching 'id'.
func SelectQuestiongroup(tx DB, id IdQuestiongroup) (Questiongroup, error) {
	row := tx.QueryRow("SELECT * FROM questiongroups WHERE id = $1", id)
	return ScanQuestiongroup(row)
}

// SelectQuestiongroups returns the entry matching the given 'ids'.
func SelectQuestiongroups(tx DB, ids ...IdQuestiongroup) (Questiongroups, error) {
	rows, err := tx.Query("SELECT * FROM questiongroups WHERE id = ANY($1)", IdQuestiongroupArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanQuestiongroups(rows)
}

type Questiongroups map[IdQuestiongroup]Questiongroup

func (m Questiongroups) IDs() []IdQuestiongroup {
	out := make([]IdQuestiongroup, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanQuestiongroups(rs *sql.Rows) (Questiongroups, error) {
	var (
		s   Questiongroup
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Questiongroups, 16)
	for rs.Next() {
		s, err = scanOneQuestiongroup(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Questiongroup in the database and returns the item with id filled.
func (item Questiongroup) Insert(tx DB) (out Questiongroup, err error) {
	row := tx.QueryRow(`INSERT INTO questiongroups (
		title, public, idteacher
		) VALUES (
		$1, $2, $3
		) RETURNING *;
		`, item.Title, item.Public, item.IdTeacher)
	return ScanQuestiongroup(row)
}

// Update Questiongroup in the database and returns the new version.
func (item Questiongroup) Update(tx DB) (out Questiongroup, err error) {
	row := tx.QueryRow(`UPDATE questiongroups SET (
		title, public, idteacher
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING *;
		`, item.Title, item.Public, item.IdTeacher, item.Id)
	return ScanQuestiongroup(row)
}

// Deletes the Questiongroup and returns the item
func DeleteQuestiongroupById(tx DB, id IdQuestiongroup) (Questiongroup, error) {
	row := tx.QueryRow("DELETE FROM questiongroups WHERE id = $1 RETURNING *;", id)
	return ScanQuestiongroup(row)
}

// Deletes the Questiongroup in the database and returns the ids.
func DeleteQuestiongroupsByIDs(tx DB, ids ...IdQuestiongroup) ([]IdQuestiongroup, error) {
	rows, err := tx.Query("DELETE FROM questiongroups WHERE id = ANY($1) RETURNING id", IdQuestiongroupArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdQuestiongroupArray(rows)
}

// ByIdTeacher returns a map with 'IdTeacher' as keys.
func (items Questiongroups) ByIdTeacher() map[teacher.IdTeacher]Questiongroups {
	out := make(map[teacher.IdTeacher]Questiongroups)
	for _, target := range items {
		dict := out[target.IdTeacher]
		if dict == nil {
			dict = make(Questiongroups)
		}
		dict[target.Id] = target
		out[target.IdTeacher] = dict
	}
	return out
}

// IdTeachers returns the list of ids of IdTeacher
// contained in this table.
// They are not garanteed to be distinct.
func (items Questiongroups) IdTeachers() []teacher.IdTeacher {
	out := make([]teacher.IdTeacher, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdTeacher)
	}
	return out
}

func SelectQuestiongroupsByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) (Questiongroups, error) {
	rows, err := tx.Query("SELECT * FROM questiongroups WHERE idteacher = ANY($1)", teacher.IdTeacherArrayToPQ(idTeachers))
	if err != nil {
		return nil, err
	}
	return ScanQuestiongroups(rows)
}

func DeleteQuestiongroupsByIdTeachers(tx DB, idTeachers ...teacher.IdTeacher) ([]IdQuestiongroup, error) {
	rows, err := tx.Query("DELETE FROM questiongroups WHERE idteacher = ANY($1) RETURNING id", teacher.IdTeacherArrayToPQ(idTeachers))
	if err != nil {
		return nil, err
	}
	return ScanIdQuestiongroupArray(rows)
}

func scanOneQuestiongroupTag(row scanner) (QuestiongroupTag, error) {
	var item QuestiongroupTag
	err := row.Scan(
		&item.Tag,
		&item.IdQuestiongroup,
	)
	return item, err
}

func ScanQuestiongroupTag(row *sql.Row) (QuestiongroupTag, error) {
	return scanOneQuestiongroupTag(row)
}

// SelectAll returns all the items in the questiongroup_tags table.
func SelectAllQuestiongroupTags(db DB) (QuestiongroupTags, error) {
	rows, err := db.Query("SELECT * FROM questiongroup_tags")
	if err != nil {
		return nil, err
	}
	return ScanQuestiongroupTags(rows)
}

type QuestiongroupTags []QuestiongroupTag

func ScanQuestiongroupTags(rs *sql.Rows) (QuestiongroupTags, error) {
	var (
		item QuestiongroupTag
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(QuestiongroupTags, 0, 16)
	for rs.Next() {
		item, err = scanOneQuestiongroupTag(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links QuestiongroupTag in the database.
// It is a no-op if 'items' is empty.
func InsertManyQuestiongroupTags(tx *sql.Tx, items ...QuestiongroupTag) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("questiongroup_tags",
		"tag",
		"idquestiongroup",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.Tag, item.IdQuestiongroup)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link QuestiongroupTag from the database.
// Only the foreign keys IdQuestiongroup fields are used in 'item'.
func (item QuestiongroupTag) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM questiongroup_tags WHERE IdQuestiongroup = $1;`, item.IdQuestiongroup)
	return err
}

// ByIdQuestiongroup returns a map with 'IdQuestiongroup' as keys.
func (items QuestiongroupTags) ByIdQuestiongroup() map[IdQuestiongroup]QuestiongroupTags {
	out := make(map[IdQuestiongroup]QuestiongroupTags)
	for _, target := range items {
		out[target.IdQuestiongroup] = append(out[target.IdQuestiongroup], target)
	}
	return out
}

// IdQuestiongroups returns the list of ids of IdQuestiongroup
// contained in this link table.
// They are not garanteed to be distinct.
func (items QuestiongroupTags) IdQuestiongroups() []IdQuestiongroup {
	out := make([]IdQuestiongroup, len(items))
	for index, target := range items {
		out[index] = target.IdQuestiongroup
	}
	return out
}

func SelectQuestiongroupTagsByIdQuestiongroups(tx DB, idQuestiongroups ...IdQuestiongroup) (QuestiongroupTags, error) {
	rows, err := tx.Query("SELECT * FROM questiongroup_tags WHERE idquestiongroup = ANY($1)", IdQuestiongroupArrayToPQ(idQuestiongroups))
	if err != nil {
		return nil, err
	}
	return ScanQuestiongroupTags(rows)
}

func DeleteQuestiongroupTagsByIdQuestiongroups(tx DB, idQuestiongroups ...IdQuestiongroup) (QuestiongroupTags, error) {
	rows, err := tx.Query("DELETE FROM questiongroup_tags WHERE idquestiongroup = ANY($1) RETURNING *", IdQuestiongroupArrayToPQ(idQuestiongroups))
	if err != nil {
		return nil, err
	}
	return ScanQuestiongroupTags(rows)
}

// SelectQuestiongroupTagByIdQuestiongroupAndTag return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectQuestiongroupTagByIdQuestiongroupAndTag(tx DB, idQuestiongroup IdQuestiongroup, tag string) (item QuestiongroupTag, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM questiongroup_tags WHERE IdQuestiongroup = $1 AND Tag = $2", idQuestiongroup, tag)
	item, err = ScanQuestiongroupTag(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func loadJSON(out interface{}, src interface{}) error {
	if src == nil {
		return nil //zero value out
	}
	bs, ok := src.([]byte)
	if !ok {
		return errors.New("not a []byte")
	}
	return json.Unmarshal(bs, out)
}

func dumpJSON(s interface{}) (driver.Value, error) {
	b, err := json.Marshal(s)
	if err != nil {
		return nil, err
	}
	return driver.Value(string(b)), nil
}

func IdExerciceArrayToPQ(ids []IdExercice) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdExerciceArray scans the result of a query returning a
// list of ID's.
func ScanIdExerciceArray(rs *sql.Rows) ([]IdExercice, error) {
	defer rs.Close()
	ints := make([]IdExercice, 0, 16)
	var err error
	for rs.Next() {
		var s IdExercice
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdExerciceSet map[IdExercice]bool

func NewIdExerciceSetFrom(ids []IdExercice) IdExerciceSet {
	out := make(IdExerciceSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdExerciceSet) Add(id IdExercice) { s[id] = true }

func (s IdExerciceSet) Has(id IdExercice) bool { return s[id] }

func (s IdExerciceSet) Keys() []IdExercice {
	out := make([]IdExercice, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdExercicegroupArrayToPQ(ids []IdExercicegroup) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdExercicegroupArray scans the result of a query returning a
// list of ID's.
func ScanIdExercicegroupArray(rs *sql.Rows) ([]IdExercicegroup, error) {
	defer rs.Close()
	ints := make([]IdExercicegroup, 0, 16)
	var err error
	for rs.Next() {
		var s IdExercicegroup
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdExercicegroupSet map[IdExercicegroup]bool

func NewIdExercicegroupSetFrom(ids []IdExercicegroup) IdExercicegroupSet {
	out := make(IdExercicegroupSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdExercicegroupSet) Add(id IdExercicegroup) { s[id] = true }

func (s IdExercicegroupSet) Has(id IdExercicegroup) bool { return s[id] }

func (s IdExercicegroupSet) Keys() []IdExercicegroup {
	out := make([]IdExercicegroup, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdQuestionArrayToPQ(ids []IdQuestion) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdQuestionArray scans the result of a query returning a
// list of ID's.
func ScanIdQuestionArray(rs *sql.Rows) ([]IdQuestion, error) {
	defer rs.Close()
	ints := make([]IdQuestion, 0, 16)
	var err error
	for rs.Next() {
		var s IdQuestion
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdQuestionSet map[IdQuestion]bool

func NewIdQuestionSetFrom(ids []IdQuestion) IdQuestionSet {
	out := make(IdQuestionSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdQuestionSet) Add(id IdQuestion) { s[id] = true }

func (s IdQuestionSet) Has(id IdQuestion) bool { return s[id] }

func (s IdQuestionSet) Keys() []IdQuestion {
	out := make([]IdQuestion, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdQuestiongroupArrayToPQ(ids []IdQuestiongroup) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdQuestiongroupArray scans the result of a query returning a
// list of ID's.
func ScanIdQuestiongroupArray(rs *sql.Rows) ([]IdQuestiongroup, error) {
	defer rs.Close()
	ints := make([]IdQuestiongroup, 0, 16)
	var err error
	for rs.Next() {
		var s IdQuestiongroup
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdQuestiongroupSet map[IdQuestiongroup]bool

func NewIdQuestiongroupSetFrom(ids []IdQuestiongroup) IdQuestiongroupSet {
	out := make(IdQuestiongroupSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdQuestiongroupSet) Add(id IdQuestiongroup) { s[id] = true }

func (s IdQuestiongroupSet) Has(id IdQuestiongroup) bool { return s[id] }

func (s IdQuestiongroupSet) Keys() []IdQuestiongroup {
	out := make([]IdQuestiongroup, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func (s *OptionalIdExercice) Scan(src interface{}) error {
	var tmp sql.NullInt64
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = OptionalIdExercice{
		Valid: tmp.Valid,
		ID:    IdExercice(tmp.Int64),
	}
	return nil
}

func (s OptionalIdExercice) Value() (driver.Value, error) {
	return sql.NullInt64{
		Int64: int64(s.ID),
		Valid: s.Valid}.Value()
}

func (s *OptionalIdQuestiongroup) Scan(src interface{}) error {
	var tmp sql.NullInt64
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = OptionalIdQuestiongroup{
		Valid: tmp.Valid,
		ID:    IdQuestiongroup(tmp.Int64),
	}
	return nil
}

func (s OptionalIdQuestiongroup) Value() (driver.Value, error) {
	return sql.NullInt64{
		Int64: int64(s.ID),
		Valid: s.Valid}.Value()
}
