package events

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"

	"github.com/benoitkugler/maths-online/server/src/sql/teacher"
	"github.com/lib/pq"
)

type scanner interface {
	Scan(...any) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...any) (sql.Result, error)
	Query(query string, args ...any) (*sql.Rows, error)
	QueryRow(query string, args ...any) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneEvent(row scanner) (Event, error) {
	var item Event
	err := row.Scan(
		&item.IdStudent,
		&item.Event,
		&item.Date,
	)
	return item, err
}

func ScanEvent(row *sql.Row) (Event, error) { return scanOneEvent(row) }

// SelectAll returns all the items in the events table.
func SelectAllEvents(db DB) (Events, error) {
	rows, err := db.Query("SELECT idstudent, event, date FROM events")
	if err != nil {
		return nil, err
	}
	return ScanEvents(rows)
}

type Events []Event

func ScanEvents(rs *sql.Rows) (Events, error) {
	var (
		item Event
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Events, 0, 16)
	for rs.Next() {
		item, err = scanOneEvent(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

func (item Event) Insert(db DB) error {
	_, err := db.Exec(`INSERT INTO events (
			idstudent, event, date
			) VALUES (
			$1, $2, $3
			);
			`, item.IdStudent, item.Event, item.Date)
	if err != nil {
		return err
	}
	return nil
}

// Insert the links Event in the database.
// It is a no-op if 'items' is empty.
func InsertManyEvents(tx *sql.Tx, items ...Event) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("events",
		"idstudent",
		"event",
		"date",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdStudent, item.Event, item.Date)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link Event from the database.
// Only the foreign keys IdStudent fields are used in 'item'.
func (item Event) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM events WHERE IdStudent = $1;`, item.IdStudent)
	return err
}

// ByIdStudent returns a map with 'IdStudent' as keys.
func (items Events) ByIdStudent() map[teacher.IdStudent]Events {
	out := make(map[teacher.IdStudent]Events)
	for _, target := range items {
		out[target.IdStudent] = append(out[target.IdStudent], target)
	}
	return out
}

// IdStudents returns the list of ids of IdStudent
// contained in this table.
// They are not garanteed to be distinct.
func (items Events) IdStudents() []teacher.IdStudent {
	out := make([]teacher.IdStudent, len(items))
	for index, target := range items {
		out[index] = target.IdStudent
	}
	return out
}

func SelectEventsByIdStudents(tx DB, idStudents_ ...teacher.IdStudent) (Events, error) {
	rows, err := tx.Query("SELECT idstudent, event, date FROM events WHERE idstudent = ANY($1)", teacher.IdStudentArrayToPQ(idStudents_))
	if err != nil {
		return nil, err
	}
	return ScanEvents(rows)
}

func DeleteEventsByIdStudents(tx DB, idStudents_ ...teacher.IdStudent) (Events, error) {
	rows, err := tx.Query("DELETE FROM events WHERE idstudent = ANY($1) RETURNING idstudent, event, date", teacher.IdStudentArrayToPQ(idStudents_))
	if err != nil {
		return nil, err
	}
	return ScanEvents(rows)
}

func (s *Date) Scan(src any) error {
	var tmp pq.NullTime
	err := tmp.Scan(src)
	if err != nil {
		return err
	}
	*s = NewDateFrom(tmp.Time)
	return nil
}

func (s Date) Value() (driver.Value, error) {
	return pq.NullTime{Time: s.Time(), Valid: true}.Value()
}
