package trivial

import "encoding/json"

// Code generated by gomacro/generator/gounions. DO NOT EDIT

// ClientEventITFWrapper may be used as replacements for ClientEventITF
// when working with JSON
type ClientEventITFWrapper struct {
	Data ClientEventITF
}

func (out *ClientEventITFWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "Answer":
		var data Answer
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ClientMove":
		var data ClientMove
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "DiceClicked":
		var data DiceClicked
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Ping":
		var data Ping
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "WantNextTurn":
		var data WantNextTurn
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item ClientEventITFWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case Answer:
		wr = wrapper{Kind: "Answer", Data: data}
	case ClientMove:
		wr = wrapper{Kind: "ClientMove", Data: data}
	case DiceClicked:
		wr = wrapper{Kind: "DiceClicked", Data: data}
	case Ping:
		wr = wrapper{Kind: "Ping", Data: data}
	case WantNextTurn:
		wr = wrapper{Kind: "WantNextTurn", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	AnswerClKind       = "Answer"
	ClientMoveClKind   = "ClientMove"
	DiceClickedClKind  = "DiceClicked"
	PingClKind         = "Ping"
	WantNextTurnClKind = "WantNextTurn"
)

func (list Events) MarshalJSON() ([]byte, error) {
	tmp := make([]ServerEventWrapper, len(list))
	for i, v := range list {
		tmp[i].Data = v
	}
	return json.Marshal(tmp)
}

func (list *Events) UnmarshalJSON(data []byte) error {
	var tmp []ServerEventWrapper
	err := json.Unmarshal(data, &tmp)
	*list = make(Events, len(tmp))
	for i, v := range tmp {
		(*list)[i] = v.Data
	}
	return err
}

// ServerEventWrapper may be used as replacements for ServerEvent
// when working with JSON
type ServerEventWrapper struct {
	Data ServerEvent
}

func (out *ServerEventWrapper) UnmarshalJSON(src []byte) error {
	var wr struct {
		Kind string
		Data json.RawMessage
	}
	err := json.Unmarshal(src, &wr)
	if err != nil {
		return err
	}
	switch wr.Kind {
	case "DiceThrow":
		var data DiceThrow
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "GameEnd":
		var data GameEnd
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "GameStart":
		var data GameStart
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "GameTerminated":
		var data GameTerminated
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "LobbyUpdate":
		var data LobbyUpdate
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "Move":
		var data Move
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "PlayerAnswerResults":
		var data PlayerAnswerResults
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "PlayerJoin":
		var data PlayerJoin
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "PlayerLeft":
		var data PlayerLeft
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "PlayerReconnected":
		var data PlayerReconnected
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "PlayerTurn":
		var data PlayerTurn
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "PossibleMoves":
		var data PossibleMoves
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data
	case "ShowQuestion":
		var data ShowQuestion
		err = json.Unmarshal(wr.Data, &data)
		out.Data = data

	default:
		panic("exhaustive switch")
	}
	return err
}

func (item ServerEventWrapper) MarshalJSON() ([]byte, error) {
	type wrapper struct {
		Data interface{}
		Kind string
	}
	var wr wrapper
	switch data := item.Data.(type) {
	case DiceThrow:
		wr = wrapper{Kind: "DiceThrow", Data: data}
	case GameEnd:
		wr = wrapper{Kind: "GameEnd", Data: data}
	case GameStart:
		wr = wrapper{Kind: "GameStart", Data: data}
	case GameTerminated:
		wr = wrapper{Kind: "GameTerminated", Data: data}
	case LobbyUpdate:
		wr = wrapper{Kind: "LobbyUpdate", Data: data}
	case Move:
		wr = wrapper{Kind: "Move", Data: data}
	case PlayerAnswerResults:
		wr = wrapper{Kind: "PlayerAnswerResults", Data: data}
	case PlayerJoin:
		wr = wrapper{Kind: "PlayerJoin", Data: data}
	case PlayerLeft:
		wr = wrapper{Kind: "PlayerLeft", Data: data}
	case PlayerReconnected:
		wr = wrapper{Kind: "PlayerReconnected", Data: data}
	case PlayerTurn:
		wr = wrapper{Kind: "PlayerTurn", Data: data}
	case PossibleMoves:
		wr = wrapper{Kind: "PossibleMoves", Data: data}
	case ShowQuestion:
		wr = wrapper{Kind: "ShowQuestion", Data: data}

	default:
		panic("exhaustive switch")
	}
	return json.Marshal(wr)
}

const (
	DiceThrowSeKind           = "DiceThrow"
	GameEndSeKind             = "GameEnd"
	GameStartSeKind           = "GameStart"
	GameTerminatedSeKind      = "GameTerminated"
	LobbyUpdateSeKind         = "LobbyUpdate"
	MoveSeKind                = "Move"
	PlayerAnswerResultsSeKind = "PlayerAnswerResults"
	PlayerJoinSeKind          = "PlayerJoin"
	PlayerLeftSeKind          = "PlayerLeft"
	PlayerReconnectedSeKind   = "PlayerReconnected"
	PlayerTurnSeKind          = "PlayerTurn"
	PossibleMovesSeKind       = "PossibleMoves"
	ShowQuestionSeKind        = "ShowQuestion"
)
