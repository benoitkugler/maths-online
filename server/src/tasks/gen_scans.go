package tasks

// Code generated by gomacro/generator/go/sqlcrud. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"

	"github.com/benoitkugler/maths-online/prof/editor"
	"github.com/benoitkugler/maths-online/prof/teacher"
	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects, and
// is implemented by *sql.DB and *sql.Tx
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneProgression(row scanner) (Progression, error) {
	var item Progression
	err := row.Scan(
		&item.Id,
		&item.IdStudent,
		&item.IdTask,
		&item.IdExercice,
	)
	return item, err
}

func ScanProgression(row *sql.Row) (Progression, error) { return scanOneProgression(row) }

// SelectAll returns all the items in the progressions table.
func SelectAllProgressions(db DB) (Progressions, error) {
	rows, err := db.Query("SELECT * FROM progressions")
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

// SelectProgression returns the entry matching 'id'.
func SelectProgression(tx DB, id IdProgression) (Progression, error) {
	row := tx.QueryRow("SELECT * FROM progressions WHERE id = $1", id)
	return ScanProgression(row)
}

// SelectProgressions returns the entry matching the given 'ids'.
func SelectProgressions(tx DB, ids ...IdProgression) (Progressions, error) {
	rows, err := tx.Query("SELECT * FROM progressions WHERE id = ANY($1)", IdProgressionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

type Progressions map[IdProgression]Progression

func (m Progressions) IDs() []IdProgression {
	out := make([]IdProgression, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanProgressions(rs *sql.Rows) (Progressions, error) {
	var (
		s   Progression
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Progressions, 16)
	for rs.Next() {
		s, err = scanOneProgression(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Progression in the database and returns the item with id filled.
func (item Progression) Insert(tx DB) (out Progression, err error) {
	row := tx.QueryRow(`INSERT INTO progressions (
		idstudent, idtask, idexercice
		) VALUES (
		$1, $2, $3
		) RETURNING *;
		`, item.IdStudent, item.IdTask, item.IdExercice)
	return ScanProgression(row)
}

// Update Progression in the database and returns the new version.
func (item Progression) Update(tx DB) (out Progression, err error) {
	row := tx.QueryRow(`UPDATE progressions SET (
		idstudent, idtask, idexercice
		) = (
		$1, $2, $3
		) WHERE id = $4 RETURNING *;
		`, item.IdStudent, item.IdTask, item.IdExercice, item.Id)
	return ScanProgression(row)
}

// Deletes the Progression and returns the item
func DeleteProgressionById(tx DB, id IdProgression) (Progression, error) {
	row := tx.QueryRow("DELETE FROM progressions WHERE id = $1 RETURNING *;", id)
	return ScanProgression(row)
}

// Deletes the Progression in the database and returns the ids.
func DeleteProgressionsByIDs(tx DB, ids ...IdProgression) ([]IdProgression, error) {
	rows, err := tx.Query("DELETE FROM progressions WHERE id = ANY($1) RETURNING id", IdProgressionArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdProgressionArray(rows)
}

// ByIdStudent returns a map with 'IdStudent' as keys.
func (items Progressions) ByIdStudent() map[teacher.IdStudent]Progressions {
	out := make(map[teacher.IdStudent]Progressions)
	for _, target := range items {
		dict := out[target.IdStudent]
		if dict == nil {
			dict = make(Progressions)
		}
		dict[target.Id] = target
		out[target.IdStudent] = dict
	}
	return out
}

// IdStudents returns the list of ids of IdStudent
// contained in this table.
// They are not garanteed to be distinct.
func (items Progressions) IdStudents() []teacher.IdStudent {
	out := make([]teacher.IdStudent, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdStudent)
	}
	return out
}

func SelectProgressionsByIdStudents(tx DB, idStudents ...teacher.IdStudent) (Progressions, error) {
	rows, err := tx.Query("SELECT * FROM progressions WHERE idstudent = ANY($1)", teacher.IdStudentArrayToPQ(idStudents))
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

func DeleteProgressionsByIdStudents(tx DB, idStudents ...teacher.IdStudent) ([]IdProgression, error) {
	rows, err := tx.Query("DELETE FROM progressions WHERE idstudent = ANY($1) RETURNING id", teacher.IdStudentArrayToPQ(idStudents))
	if err != nil {
		return nil, err
	}
	return ScanIdProgressionArray(rows)
}

// ByIdTask returns a map with 'IdTask' as keys.
func (items Progressions) ByIdTask() map[IdTask]Progressions {
	out := make(map[IdTask]Progressions)
	for _, target := range items {
		dict := out[target.IdTask]
		if dict == nil {
			dict = make(Progressions)
		}
		dict[target.Id] = target
		out[target.IdTask] = dict
	}
	return out
}

// IdTasks returns the list of ids of IdTask
// contained in this table.
// They are not garanteed to be distinct.
func (items Progressions) IdTasks() []IdTask {
	out := make([]IdTask, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdTask)
	}
	return out
}

func SelectProgressionsByIdTasks(tx DB, idTasks ...IdTask) (Progressions, error) {
	rows, err := tx.Query("SELECT * FROM progressions WHERE idtask = ANY($1)", IdTaskArrayToPQ(idTasks))
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

func DeleteProgressionsByIdTasks(tx DB, idTasks ...IdTask) ([]IdProgression, error) {
	rows, err := tx.Query("DELETE FROM progressions WHERE idtask = ANY($1) RETURNING id", IdTaskArrayToPQ(idTasks))
	if err != nil {
		return nil, err
	}
	return ScanIdProgressionArray(rows)
}

// ByIdExercice returns a map with 'IdExercice' as keys.
func (items Progressions) ByIdExercice() map[editor.IdExercice]Progressions {
	out := make(map[editor.IdExercice]Progressions)
	for _, target := range items {
		dict := out[target.IdExercice]
		if dict == nil {
			dict = make(Progressions)
		}
		dict[target.Id] = target
		out[target.IdExercice] = dict
	}
	return out
}

// IdExercices returns the list of ids of IdExercice
// contained in this table.
// They are not garanteed to be distinct.
func (items Progressions) IdExercices() []editor.IdExercice {
	out := make([]editor.IdExercice, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdExercice)
	}
	return out
}

func SelectProgressionsByIdExercices(tx DB, idExercices ...editor.IdExercice) (Progressions, error) {
	rows, err := tx.Query("SELECT * FROM progressions WHERE idexercice = ANY($1)", editor.IdExerciceArrayToPQ(idExercices))
	if err != nil {
		return nil, err
	}
	return ScanProgressions(rows)
}

func DeleteProgressionsByIdExercices(tx DB, idExercices ...editor.IdExercice) ([]IdProgression, error) {
	rows, err := tx.Query("DELETE FROM progressions WHERE idexercice = ANY($1) RETURNING id", editor.IdExerciceArrayToPQ(idExercices))
	if err != nil {
		return nil, err
	}
	return ScanIdProgressionArray(rows)
}

func scanOneProgressionQuestion(row scanner) (ProgressionQuestion, error) {
	var item ProgressionQuestion
	err := row.Scan(
		&item.IdProgression,
		&item.IdExercice,
		&item.Index,
		&item.History,
	)
	return item, err
}

func ScanProgressionQuestion(row *sql.Row) (ProgressionQuestion, error) {
	return scanOneProgressionQuestion(row)
}

// SelectAll returns all the items in the progression_questions table.
func SelectAllProgressionQuestions(db DB) (ProgressionQuestions, error) {
	rows, err := db.Query("SELECT * FROM progression_questions")
	if err != nil {
		return nil, err
	}
	return ScanProgressionQuestions(rows)
}

type ProgressionQuestions []ProgressionQuestion

func ScanProgressionQuestions(rs *sql.Rows) (ProgressionQuestions, error) {
	var (
		item ProgressionQuestion
		err  error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(ProgressionQuestions, 0, 16)
	for rs.Next() {
		item, err = scanOneProgressionQuestion(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, item)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links ProgressionQuestion in the database.
// It is a no-op if 'items' is empty.
func InsertManyProgressionQuestions(tx *sql.Tx, items ...ProgressionQuestion) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("progression_questions",
		"idprogression",
		"idexercice",
		"index",
		"history",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdProgression, item.IdExercice, item.Index, item.History)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link ProgressionQuestion from the database.
// Only the foreign keys IdProgression, IdExercice fields are used in 'item'.
func (item ProgressionQuestion) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM progression_questions WHERE IdProgression = $1 AND IdExercice = $2;`, item.IdProgression, item.IdExercice)
	return err
}

// ByIdProgression returns a map with 'IdProgression' as keys.
func (items ProgressionQuestions) ByIdProgression() map[IdProgression]ProgressionQuestions {
	out := make(map[IdProgression]ProgressionQuestions)
	for _, target := range items {
		out[target.IdProgression] = append(out[target.IdProgression], target)
	}
	return out
}

// IdProgressions returns the list of ids of IdProgression
// contained in this link table.
// They are not garanteed to be distinct.
func (items ProgressionQuestions) IdProgressions() []IdProgression {
	out := make([]IdProgression, len(items))
	for index, target := range items {
		out[index] = target.IdProgression
	}
	return out
}

func SelectProgressionQuestionsByIdProgressions(tx DB, idProgressions ...IdProgression) (ProgressionQuestions, error) {
	rows, err := tx.Query("SELECT * FROM progression_questions WHERE idprogression = ANY($1)", IdProgressionArrayToPQ(idProgressions))
	if err != nil {
		return nil, err
	}
	return ScanProgressionQuestions(rows)
}

func DeleteProgressionQuestionsByIdProgressions(tx DB, idProgressions ...IdProgression) (ProgressionQuestions, error) {
	rows, err := tx.Query("DELETE FROM progression_questions WHERE idprogression = ANY($1) RETURNING *", IdProgressionArrayToPQ(idProgressions))
	if err != nil {
		return nil, err
	}
	return ScanProgressionQuestions(rows)
}

// ByIdExercice returns a map with 'IdExercice' as keys.
func (items ProgressionQuestions) ByIdExercice() map[editor.IdExercice]ProgressionQuestions {
	out := make(map[editor.IdExercice]ProgressionQuestions)
	for _, target := range items {
		out[target.IdExercice] = append(out[target.IdExercice], target)
	}
	return out
}

// IdExercices returns the list of ids of IdExercice
// contained in this link table.
// They are not garanteed to be distinct.
func (items ProgressionQuestions) IdExercices() []editor.IdExercice {
	out := make([]editor.IdExercice, len(items))
	for index, target := range items {
		out[index] = target.IdExercice
	}
	return out
}

func SelectProgressionQuestionsByIdExercices(tx DB, idExercices ...editor.IdExercice) (ProgressionQuestions, error) {
	rows, err := tx.Query("SELECT * FROM progression_questions WHERE idexercice = ANY($1)", editor.IdExerciceArrayToPQ(idExercices))
	if err != nil {
		return nil, err
	}
	return ScanProgressionQuestions(rows)
}

func DeleteProgressionQuestionsByIdExercices(tx DB, idExercices ...editor.IdExercice) (ProgressionQuestions, error) {
	rows, err := tx.Query("DELETE FROM progression_questions WHERE idexercice = ANY($1) RETURNING *", editor.IdExerciceArrayToPQ(idExercices))
	if err != nil {
		return nil, err
	}
	return ScanProgressionQuestions(rows)
}

// SelectProgressionByIdStudentAndIdTask return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectProgressionByIdStudentAndIdTask(tx DB, idStudent teacher.IdStudent, idTask IdTask) (item Progression, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM progressions WHERE IdStudent = $1 AND IdTask = $2", idStudent, idTask)
	item, err = ScanProgression(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

// SelectProgressionByIdAndIdExercice return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectProgressionByIdAndIdExercice(tx DB, id IdProgression, idExercice editor.IdExercice) (item Progression, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM progressions WHERE Id = $1 AND IdExercice = $2", id, idExercice)
	item, err = ScanProgression(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func scanOneTask(row scanner) (Task, error) {
	var item Task
	err := row.Scan(
		&item.Id,
		&item.IdExercice,
	)
	return item, err
}

func ScanTask(row *sql.Row) (Task, error) { return scanOneTask(row) }

// SelectAll returns all the items in the tasks table.
func SelectAllTasks(db DB) (Tasks, error) {
	rows, err := db.Query("SELECT * FROM tasks")
	if err != nil {
		return nil, err
	}
	return ScanTasks(rows)
}

// SelectTask returns the entry matching 'id'.
func SelectTask(tx DB, id IdTask) (Task, error) {
	row := tx.QueryRow("SELECT * FROM tasks WHERE id = $1", id)
	return ScanTask(row)
}

// SelectTasks returns the entry matching the given 'ids'.
func SelectTasks(tx DB, ids ...IdTask) (Tasks, error) {
	rows, err := tx.Query("SELECT * FROM tasks WHERE id = ANY($1)", IdTaskArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanTasks(rows)
}

type Tasks map[IdTask]Task

func (m Tasks) IDs() []IdTask {
	out := make([]IdTask, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanTasks(rs *sql.Rows) (Tasks, error) {
	var (
		s   Task
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Tasks, 16)
	for rs.Next() {
		s, err = scanOneTask(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert one Task in the database and returns the item with id filled.
func (item Task) Insert(tx DB) (out Task, err error) {
	row := tx.QueryRow(`INSERT INTO tasks (
		idexercice
		) VALUES (
		$1
		) RETURNING *;
		`, item.IdExercice)
	return ScanTask(row)
}

// Update Task in the database and returns the new version.
func (item Task) Update(tx DB) (out Task, err error) {
	row := tx.QueryRow(`UPDATE tasks SET (
		idexercice
		) = (
		$1
		) WHERE id = $2 RETURNING *;
		`, item.IdExercice, item.Id)
	return ScanTask(row)
}

// Deletes the Task and returns the item
func DeleteTaskById(tx DB, id IdTask) (Task, error) {
	row := tx.QueryRow("DELETE FROM tasks WHERE id = $1 RETURNING *;", id)
	return ScanTask(row)
}

// Deletes the Task in the database and returns the ids.
func DeleteTasksByIDs(tx DB, ids ...IdTask) ([]IdTask, error) {
	rows, err := tx.Query("DELETE FROM tasks WHERE id = ANY($1) RETURNING id", IdTaskArrayToPQ(ids))
	if err != nil {
		return nil, err
	}
	return ScanIdTaskArray(rows)
}

// ByIdExercice returns a map with 'IdExercice' as keys.
func (items Tasks) ByIdExercice() map[editor.IdExercice]Tasks {
	out := make(map[editor.IdExercice]Tasks)
	for _, target := range items {
		dict := out[target.IdExercice]
		if dict == nil {
			dict = make(Tasks)
		}
		dict[target.Id] = target
		out[target.IdExercice] = dict
	}
	return out
}

// IdExercices returns the list of ids of IdExercice
// contained in this table.
// They are not garanteed to be distinct.
func (items Tasks) IdExercices() []editor.IdExercice {
	out := make([]editor.IdExercice, 0, len(items))
	for _, target := range items {
		out = append(out, target.IdExercice)
	}
	return out
}

func SelectTasksByIdExercices(tx DB, idExercices ...editor.IdExercice) (Tasks, error) {
	rows, err := tx.Query("SELECT * FROM tasks WHERE idexercice = ANY($1)", editor.IdExerciceArrayToPQ(idExercices))
	if err != nil {
		return nil, err
	}
	return ScanTasks(rows)
}

func DeleteTasksByIdExercices(tx DB, idExercices ...editor.IdExercice) ([]IdTask, error) {
	rows, err := tx.Query("DELETE FROM tasks WHERE idexercice = ANY($1) RETURNING id", editor.IdExerciceArrayToPQ(idExercices))
	if err != nil {
		return nil, err
	}
	return ScanIdTaskArray(rows)
}

// SelectTaskByIdAndIdExercice return zero or one item, thanks to a UNIQUE SQL constraint.
func SelectTaskByIdAndIdExercice(tx DB, id IdTask, idExercice editor.IdExercice) (item Task, found bool, err error) {
	row := tx.QueryRow("SELECT * FROM tasks WHERE Id = $1 AND IdExercice = $2", id, idExercice)
	item, err = ScanTask(row)
	if err == sql.ErrNoRows {
		return item, false, nil
	}
	return item, true, err
}

func (s *QuestionHistory) Scan(src interface{}) error  { return (*pq.BoolArray)(s).Scan(src) }
func (s QuestionHistory) Value() (driver.Value, error) { return pq.BoolArray(s).Value() }

func IdProgressionArrayToPQ(ids []IdProgression) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdProgressionArray scans the result of a query returning a
// list of ID's.
func ScanIdProgressionArray(rs *sql.Rows) ([]IdProgression, error) {
	defer rs.Close()
	ints := make([]IdProgression, 0, 16)
	var err error
	for rs.Next() {
		var s IdProgression
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdProgressionSet map[IdProgression]bool

func NewIdProgressionSetFrom(ids []IdProgression) IdProgressionSet {
	out := make(IdProgressionSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdProgressionSet) Add(id IdProgression) { s[id] = true }

func (s IdProgressionSet) Has(id IdProgression) bool { return s[id] }

func (s IdProgressionSet) Keys() []IdProgression {
	out := make([]IdProgression, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}

func IdTaskArrayToPQ(ids []IdTask) pq.Int64Array {
	out := make(pq.Int64Array, len(ids))
	for i, v := range ids {
		out[i] = int64(v)
	}
	return out
}

// ScanIdTaskArray scans the result of a query returning a
// list of ID's.
func ScanIdTaskArray(rs *sql.Rows) ([]IdTask, error) {
	defer rs.Close()
	ints := make([]IdTask, 0, 16)
	var err error
	for rs.Next() {
		var s IdTask
		if err = rs.Scan(&s); err != nil {
			return nil, err
		}
		ints = append(ints, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return ints, nil
}

type IdTaskSet map[IdTask]bool

func NewIdTaskSetFrom(ids []IdTask) IdTaskSet {
	out := make(IdTaskSet, len(ids))
	for _, key := range ids {
		out[key] = true
	}
	return out
}

func (s IdTaskSet) Add(id IdTask) { s[id] = true }

func (s IdTaskSet) Has(id IdTask) bool { return s[id] }

func (s IdTaskSet) Keys() []IdTask {
	out := make([]IdTask, 0, len(s))
	for k := range s {
		out = append(out, k)
	}
	return out
}
